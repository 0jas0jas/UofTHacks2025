input,time_complexity,space_complexity
"# This is the memoization approach of 
# 0 / 1 Knapsack in Python in simple 
# we can say recursion + memoization = DP 
 
 
defknapsack(wt, val, W, n): 
 
    # base conditions 
    ifn ==0orW ==0: 
        return0
    ift[n][W] !=-1: 
        returnt[n][W] 
 
    # choice diagram code 
    ifwt[n-1] <=W: 
        t[n][W] =max( 
            val[n-1] +knapsack( 
                wt, val, W-wt[n-1], n-1), 
            knapsack(wt, val, W, n-1)) 
        returnt[n][W] 
    elifwt[n-1] > W: 
        t[n][W] =knapsack(wt, val, W, n-1) 
        returnt[n][W] 
 
# Driver code 
if__name__ =='__main__': 
    profit =[60, 100, 120] 
    weight =[10, 20, 30] 
    W =50
    n =len(profit) 
     
    # We initialize the matrix with -1 at first. 
    t =[[-1fori inrange(W +1)] forj inrange(n +1)] 
    print(knapsack(weight, profit, W, n)) 
 
# This code is contributed by Prosun Kumar Sarkar 
",O(2N),O(N)
"# This is the memoization approach of 
# 0 / 1 Knapsack in Python in simple 
# we can say recursion + memoization = DP 
 
 
defknapsack(wt, val, W, n): 
 
    # base conditions 
    ifn ==0orW ==0: 
        return0
    ift[n][W] !=-1: 
        returnt[n][W] 
 
    # choice diagram code 
    ifwt[n-1] <=W: 
        t[n][W] =max( 
            val[n-1] +knapsack( 
                wt, val, W-wt[n-1], n-1), 
            knapsack(wt, val, W, n-1)) 
        returnt[n][W] 
    elifwt[n-1] > W: 
        t[n][W] =knapsack(wt, val, W, n-1) 
        returnt[n][W] 
 
# Driver code 
if__name__ =='__main__': 
    profit =[60, 100, 120] 
    weight =[10, 20, 30] 
    W =50
    n =len(profit) 
     
    # We initialize the matrix with -1 at first. 
    t =[[-1fori inrange(W +1)] forj inrange(n +1)] 
    print(knapsack(weight, profit, W, n)) 
 
# This code is contributed by Prosun Kumar Sarkar 
",O(N * W),O(N * W) + O(N)
"# A Dynamic Programming based Python 
# Program for 0-1 Knapsack problem 
# Returns the maximum value that can 
# be put in a knapsack of capacity W 
 
 
defknapSack(W, wt, val, n): 
    K =[[0forx inrange(W +1)] forx inrange(n +1)] 
 
    # Build table K[][] in bottom up manner 
    fori inrange(n +1): 
        forw inrange(W +1): 
            ifi ==0orw ==0: 
                K[i][w] =0
            elifwt[i-1] <=w: 
                K[i][w] =max(val[i-1] 
                              +K[i-1][w-wt[i-1]], 
                              K[i-1][w]) 
            else: 
                K[i][w] =K[i-1][w] 
 
    returnK[n][W] 
 
 
# Driver code 
if__name__ =='__main__': 
    profit =[60, 100, 120] 
    weight =[10, 20, 30] 
    W =50
    n =len(profit) 
    print(knapSack(W, weight, profit, n)) 
 
# This code is contributed by Bhavya Jain 
",O(N * W),O(N * W)
"# Python code to implement the above approach 
 
 
defknapSack(W, wt, val, n): 
     
    # Making the dp array 
    dp =[0fori inrange(W+1)] 
 
    # Taking first i elements 
    fori inrange(1, n+1): 
       
        # Starting from back, 
        # so that we also have data of 
        # previous computation when taking i-1 items 
        forw inrange(W, 0, -1): 
            ifwt[i-1] <=w: 
                 
                # Finding the maximum value 
                dp[w] =max(dp[w], dp[w-wt[i-1]]+val[i-1]) 
     
    # Returning the maximum value of knapsack 
    returndp[W] 
 
 
# Driver code 
if__name__ =='__main__': 
    profit =[60, 100, 120] 
    weight =[10, 20, 30] 
    W =50
    n =len(profit) 
    print(knapSack(W, weight, profit, n)) 
 
 
# This code is contributed by Suyash Saxena
",O(N * W),O(W)
"# Python3 program to print the path from root 
# node to destination node for N*N-1 puzzle 
# algorithm using Branch and Bound
# The solution assumes that instance of 
# puzzle is solvable

# Importing copy for deepcopy function
importcopy

# Importing the heap functions from python 
# library for Priority Queue
fromheapq importheappush, heappop

# This variable can be changed to change
# the program from 8 puzzle(n=3) to 15 
# puzzle(n=4) to 24 puzzle(n=5)...
n =3

# bottom, left, top, right
row =[ 1, 0, -1, 0]
col =[ 0, -1, 0, 1]

# A class for Priority Queue
classpriorityQueue:
    
    # Constructor to initialize a
    # Priority Queue
    def__init__(self):
        self.heap =[]

    # Inserts a new key 'k'
    defpush(self, k):
        heappush(self.heap, k)

    # Method to remove minimum element 
    # from Priority Queue
    defpop(self):
        returnheappop(self.heap)

    # Method to know if the Queue is empty
    defempty(self):
        ifnotself.heap:
            returnTrue
        else:
            returnFalse

# Node structure
classnode:
    
    def__init__(self, parent, mat, empty_tile_pos,
                 cost, level):
                     
        # Stores the parent node of the 
        # current node helps in tracing 
        # path when the answer is found
        self.parent =parent

        # Stores the matrix
        self.mat =mat

        # Stores the position at which the
        # empty space tile exists in the matrix
        self.empty_tile_pos =empty_tile_pos

        # Stores the number of misplaced tiles
        self.cost =cost

        # Stores the number of moves so far
        self.level =level

    # This method is defined so that the 
    # priority queue is formed based on 
    # the cost variable of the objects
    def__lt__(self, nxt):
        returnself.cost < nxt.cost

# Function to calculate the number of 
# misplaced tiles ie. number of non-blank
# tiles not in their goal position
defcalculateCost(mat, final) -> int:
    
    count =0
    fori inrange(n):
        forj inrange(n):
            if((mat[i][j]) and
                (mat[i][j] !=final[i][j])):
                count +=1
                
    returncount

defnewNode(mat, empty_tile_pos, new_empty_tile_pos,
            level, parent, final) -> node:
                
    # Copy data from parent matrix to current matrix
    new_mat =copy.deepcopy(mat)

    # Move tile by 1 position
    x1 =empty_tile_pos[0]
    y1 =empty_tile_pos[1]
    x2 =new_empty_tile_pos[0]
    y2 =new_empty_tile_pos[1]
    new_mat[x1][y1], new_mat[x2][y2] =new_mat[x2][y2], new_mat[x1][y1]

    # Set number of misplaced tiles
    cost =calculateCost(new_mat, final)

    new_node =node(parent, new_mat, new_empty_tile_pos,
                    cost, level)
    returnnew_node

# Function to print the N x N matrix
defprintMatrix(mat):
    
    fori inrange(n):
        forj inrange(n):
            print(""%d ""%(mat[i][j]), end ="" "")
            
        print()

# Function to check if (x, y) is a valid
# matrix coordinate
defisSafe(x, y):
    
    returnx >=0andx < n andy >=0andy < n

# Print path from root node to destination node
defprintPath(root):
    
    ifroot ==None:
        return
    
    printPath(root.parent)
    printMatrix(root.mat)
    print()

# Function to solve N*N - 1 puzzle algorithm
# using Branch and Bound. empty_tile_pos is
# the blank tile position in the initial state.
defsolve(initial, empty_tile_pos, final):
    
    # Create a priority queue to store live
    # nodes of search tree
    pq =priorityQueue()

    # Create the root node
    cost =calculateCost(initial, final)
    root =node(None, initial, 
                empty_tile_pos, cost, 0)

    # Add root to list of live nodes
    pq.push(root)

    # Finds a live node with least cost,
    # add its children to list of live 
    # nodes and finally deletes it from 
    # the list.
    whilenotpq.empty():

        # Find a live node with least estimated
        # cost and delete it from the list of 
        # live nodes
        minimum =pq.pop()

        # If minimum is the answer node
        ifminimum.cost ==0:
            
            # Print the path from root to
            # destination;
            printPath(minimum)
            return

        # Generate all possible children
        fori inrange(4):
            new_tile_pos =[
                minimum.empty_tile_pos[0] +row[i],
                minimum.empty_tile_pos[1] +col[i], ]
                
            ifisSafe(new_tile_pos[0], new_tile_pos[1]):
                
                # Create a child node
                child =newNode(minimum.mat,
                                minimum.empty_tile_pos,
                                new_tile_pos,
                                minimum.level +1,
                                minimum, final,)

                # Add child to list of live nodes
                pq.push(child)

# Driver Code

# Initial configuration
# Value 0 is used for empty space
initial =[ [ 1, 2, 3], 
            [ 5, 6, 0], 
            [ 7, 8, 4] ]

# Solvable Final configuration
# Value 0 is used for empty space
final =[ [ 1, 2, 3], 
          [ 5, 8, 6], 
          [ 0, 7, 4] ]

# Blank tile coordinates in 
# initial configuration
empty_tile_pos =[ 1, 2]

# Function call to solve the puzzle
solve(initial, empty_tile_pos, final)

# This code is contributed by Kevin Joshi
",O(N^2 * N!),O(N^2)
"# Python equivalent of above code 

# define a function to set the zeroes in the matrix
defsetZeroes(matrix):
    # get the length of the matrix
    rows =len(matrix)
    cols =len(matrix[0])

    # Iterate through each element of the matrix
    fori inrange(0, rows):
        forj inrange(0, cols):

            # If the element is 1, mark its
            # corresponding row and column using -1
            ifmatrix[i][j] ==1:

                # Mark all elements in the same column
                # as -1, except for other 1's
                ind =i -1
                whileind >=0:
                    ifmatrix[ind][j] !=1:
                        matrix[ind][j] =-1
                    ind -=1

                ind =i +1
                whileind < rows:
                    ifmatrix[ind][j] !=1:
                        matrix[ind][j] =-1
                    ind +=1

                # Mark all elements in the same row as
                # -1, except for other 1's
                ind =j -1
                whileind >=0:
                    ifmatrix[i][ind] !=1:
                        matrix[i][ind] =-1
                    ind -=1

                ind =j +1
                whileind < cols:
                    ifmatrix[i][ind] !=1:
                        matrix[i][ind] =-1
                    ind +=1

    # Iterate through the matrix again, setting all
    # -1's to 0
    fori inrange(0, rows):
        forj inrange(0, cols):
            ifmatrix[i][j] < 0:
                matrix[i][j] =1

# Test the setZeroes function with a sample input
if__name__ ==""__main__"":
    arr =[[1, 0, 2, 1],
           [3, 4, 5, 2],
           [0, 3, 0, 5]]
    setZeroes(arr)
    print(""The Final Matrix is:"")
    fori inrange(len(arr)):
        forj inrange(len(arr[0])):
            print(arr[i][j], end="" "")
        print()
",O((N*M)*(N + M)),O(1)
"# Python3 Code For A Boolean Matrix Question
R =3
C =4


defmodifyMatrix(mat):
    row =[0] *R
    col =[0] *C

    # Initialize all values of row[] as 0
    fori inrange(0, R):
        row[i] =0

    # Initialize all values of col[] as 0
    fori inrange(0, C):
        col[i] =0

    # Store the rows and columns to be marked
    # as 1 in row[] and col[] arrays respectively
    fori inrange(0, R):

        forj inrange(0, C):
            if(mat[i][j] ==1):
                row[i] =1
                col[j] =1

    # Modify the input matrix mat[] using the
    # above constructed row[] and col[] arrays
    fori inrange(0, R):

        forj inrange(0, C):
            if(row[i] ==1orcol[j] ==1):
                mat[i][j] =1

# A utility function to print a 2D matrix


defprintMatrix(mat):
    fori inrange(0, R):

        forj inrange(0, C):
            print(mat[i][j], end="" "")
        print()


# Driver Code
mat =[[1, 0, 0, 1],
       [0, 0, 1, 0],
       [0, 0, 0, 0]]

print(""Input Matrix"")
printMatrix(mat)

modifyMatrix(mat)

print(""Matrix after modification"")
printMatrix(mat)

# This code is contributed by Nikita Tiwari.
",O(M*N),O(M+N)
"# Python3 Code For A Boolean Matrix Question
defmodifyMatrix(mat):

    # variables to check if there are any 1
    # in first row and column
    row_flag =False
    col_flag =False

    # updating the first row and col
    # if 1 is encountered
    fori inrange(0, len(mat)):

        forj inrange(0, len(mat)):
            if(i ==0andmat[i][j] ==1):
                row_flag =True

            if(j ==0andmat[i][j] ==1):
                col_flag =True

            if(mat[i][j] ==1):
                mat[0][j] =1
                mat[i][0] =1

    # Modify the input matrix mat[] using the
    # first row and first column of Matrix mat
    fori inrange(1, len(mat)):

        forj inrange(1, len(mat) +1):
            if(mat[0][j] ==1ormat[i][0] ==1):
                mat[i][j] =1

    # modify first row if there was any 1
    if(row_flag ==True):
        fori inrange(0, len(mat)):
            mat[0][i] =1

    # modify first col if there was any 1
    if(col_flag ==True):
        fori inrange(0, len(mat)):
            mat[i][0] =1

# A utility function to print a 2D matrix


defprintMatrix(mat):

    fori inrange(0, len(mat)):
        forj inrange(0, len(mat) +1):
            print(mat[i][j], end="""")

        print()


# Driver Code
mat =[[1, 0, 0, 1],
       [0, 0, 1, 0],
       [0, 0, 0, 0]]

print(""Input Matrix :"")
printMatrix(mat)

modifyMatrix(mat)

print(""Matrix After Modification :"")
printMatrix(mat)

# This code is contributed by Nikita tiwari.
",O(M*N),O(1)
"# Python program to check if a binary tree is bst or not
# A binary tree node has data, pointer to left child
# and a pointer to right child
classNode:

    def__init__(self, data):
        self.data =data
        self.left =None
        self.right =None

defmaxValue(node):
    ifnode isNone:
        return0;
    
    leftMax =maxValue(node.left)
    rightMax =maxValue(node.right)
    
    value =0;
    ifleftMax > rightMax:
        value =leftMax
    else:
        value =rightMax
    
    ifvalue < node.data:
        value =node.data
    
    returnvalue
    
defminValue(node):
    ifnode isNone:
        return1000000000
    
    leftMax =minValue(node.left)
    rightMax =minValue(node.right)
    
    value =0
    ifleftMax < rightMax:
        value =leftMax
    else:
        value =rightMax
    
    ifvalue > node.data:
        value =node.data
    
    returnvalue

# Returns true if a binary tree is a binary search tree
defisBST(node):
    ifnode isNone:
        returnTrue
    
    # false if the max of the left is > than us
    if(node.left isnotNoneandmaxValue(node.left) > node.data):
        returnFalse
    
    # false if the min of the right is <= than us
    if(node.right isnotNoneandminValue(node.right) < node.data):
        returnFalse
    
    #false if, recursively, the left or right is not a BST
    if(isBST(node.left) isFalseorisBST(node.right) isFalse):
        returnFalse
    
    # passing all that, it's a BST
    returnTrue

# Driver code
if__name__ ==""__main__"":
  root =Node(4)
  root.left =Node(2)
  root.right =Node(5)
  # root.right.left = Node(7)
  root.left.left =Node(1)
  root.left.right =Node(3)

  # Function call
  ifisBST(root) isTrue:
      print(""Is BST"")
  else:
      print(""Not a BST"")

# This code is contributed by Yash Agarwal(yashagarwal2852002)
",O(N2),O(H)
"# Python program to check if a binary tree is bst or not

INT_MAX =4294967296
INT_MIN =-4294967296

# A binary tree node


classNode:

    # Constructor to create a new node
    def__init__(self, data):
        self.data =data
        self.left =None
        self.right =None


# Returns true if the given tree is a binary search tree
# (efficient version)
defisBST(node):
    return(isBSTUtil(node, INT_MIN, INT_MAX))

# Returns true if the given tree is a BST and its values
# >= min and <= max


defisBSTUtil(node, mini, maxi):

    # An empty tree is BST
    ifnode isNone:
        returnTrue

    # False if this node violates min/max constraint
    ifnode.data < mini ornode.data > maxi:
        returnFalse

    # Otherwise check the subtrees recursively
    # tightening the min or max constraint
    return(isBSTUtil(node.left, mini, node.data -1) and
            isBSTUtil(node.right, node.data+1, maxi))


# Driver code
if__name__ ==""__main__"":
  root =Node(4)
  root.left =Node(2)
  root.right =Node(5)
  root.left.left =Node(1)
  root.left.right =Node(3)

  # Function call
  if(isBST(root)):
      print(""Is BST"")
  else:
      print(""Not a BST"")

# This code is contributed by Nikhil Kumar Singh(nickzuck_007)
",O(N),O(1)
"# Python3 program to check
# if a given tree is BST.
importmath

# A binary tree node has data,
# pointer to left child and
# a pointer to right child
classNode:
    def__init__(self, data):
        self.data =data
        self.left =None
        self.right =None


defisBSTUtil(root, prev):

    # traverse the tree in inorder fashion
    # and keep track of prev node
    if(root !=None):
        if(isBSTUtil(root.left, prev) ==False):
            returnFalse

        # Allows only distinct valued nodes
        if(prev !=Noneand
                root.data <=prev.data):
            returnFalse

        prev =root
        returnisBSTUtil(root.right, prev)

    returnTrue


defisBST(root):
    prev =None
    returnisBSTUtil(root, prev)


# Driver Code
if__name__ =='__main__':
    root =Node(3)
    root.left =Node(2)
    root.right =Node(5)
    root.right.left =Node(1)
    root.right.right =Node(4)

    # Function call
    if(isBST(root) ==None):
        print(""Is BST"")
    else:
        print(""Not a BST"")

# This code is contributed by Srathore
",O(N),O(H)
"# Definition for a binary tree node.
classTreeNode:
    def__init__(self, val):
        self.val =val
        self.left =None
        self.right =None

defisValidBST(root):
    curr =root
    prev =None
    
    whilecurr !=None:
        ifcurr.left ==None: # case 1: no left child
            # process the current node
            ifprev !=Noneandprev.val >=curr.val:
                returnFalse
            prev =curr
            curr =curr.right
        else: # case 2: has a left child
            # find the inorder predecessor
            pred =curr.left
            whilepred.right !=Noneandpred.right !=curr:
                pred =pred.right
            
            ifpred.right ==None: # make threaded link
                pred.right =curr
                curr =curr.left
            else: # remove threaded link
                pred.right =None
                # process the current node
                ifprev !=Noneandprev.val >=curr.val:
                    returnFalse
                prev =curr
                curr =curr.right
    
    returnTrue# binary tree is a valid BST

# Driver Code
root =TreeNode(4)
root.left =TreeNode(2)
root.right =TreeNode(5)
root.left.left =TreeNode(1)
root.left.right =TreeNode(3)

# check if the binary tree is a valid BST
ifisValidBST(root):
    print(""The binary tree is a valid BST."")
else:
    print(""The binary tree is not a valid BST."")
",O(N),O(1)
"# Python3 program for activity selection problem.

# The following implementation assumes that the activities
# are already sorted according to their finish time

# Prints a maximum set of activities that can be done 
# by a single person, one at a time
defprintMaxActivities(s, f):
    n =len(f)
    print(""Following activities are selected"")

    # The first activity is always selected
    i =0
    print(i, end=' ')

    # Consider rest of the activities
    forj inrange(1, n):

        # If this activity has start time greater than
        # or equal to the finish time of previously
        # selected activity, then select it
        ifs[j] >=f[i]:
            print(j, end=' ')
            i =j


# Driver code
if__name__ =='__main__':
    s =[1, 3, 0, 5, 8, 5]
    f =[2, 4, 6, 7, 9, 9]

    # Function call
    printMaxActivities(s, f)

# This code is contributed by Nikhil Kumar Singh
",O(N),O(1)
"''' Python program for activity selection problem
 when input activities may not be sorted.'''


defMaxActivities(arr, n):
    selected =[]

    # Sort jobs according to finish time
    Activity.sort(key=lambdax: x[1])

    # The first activity always gets selected
    i =0
    selected.append(arr[i])

    forj inrange(1, n):

        '''If this activity has start time greater than or
           equal to the finish time of previously selected
           activity, then select it'''
        ifarr[j][0] >=arr[i][1]:
            selected.append(arr[j])
            i =j
    returnselected


# Driver code
if__name__ =='__main__':
    Activity =[[5, 9], [1, 2], [3, 4], [0, 6], [5, 7], [8, 9]]
    n =len(Activity)

    # Function call
    selected =MaxActivities(Activity, n)
    print(""Following activities are selected :"")
    print(selected[0], end ="""");
    fori inrange(1, len(selected)):
        print("","", end ="" "")
        print(selected[i], end ="""")

# This code is contributed by kshitijjainm
",O(N log N),O(1)
"# Python3 program for activity selection problem
# when input activities may not be sorted.
fromheapq importheappop, heappush

# Function to select activites


defSelectActivities(s, f):
    ans =[]
    p =[]

    # Pushing elements in the list
    fori, j inzip(s, f):
        heappush(p, (j, i))

    it =heappop(p)
    start =it[1]
    end =it[0]
    ans.append(it)

    # Sorting process
    whilep:
        it =heappop(p)
        ifit[1] >=end:
            start =it[1]
            end =it[0]
            ans.append(it)

    print(""Following Activities should be selected.\n"")
    forf, s inans:
        print(f""Activity started at {s} and ends at {f}"")


# Driver code
if__name__ ==""__main__"":
    s =[1, 3, 0, 5, 8, 5]
    finish =[2, 4, 6, 7, 9, 9]

    # Function call
    SelectActivities(s, finish)

# This code is contributed by kraanzu.
",O(N * log N),O(N)
"# Python program for implementation of
# Aho-Corasick algorithm for string matching

# defaultdict is used only for storing the final output
# We will return a dictionary where key is the matched word
# and value is the list of indexes of matched word
fromcollections importdefaultdict

# For simplicity, Arrays and Queues have been implemented using lists. 
# If you want to improve performance try using them instead
classAhoCorasick:
    def__init__(self, words):

        # Max number of states in the matching machine.
        # Should be equal to the sum of the length of all keywords.
        self.max_states =sum([len(word) forword inwords])

        # Maximum number of characters.
        # Currently supports only alphabets [a,z]
        self.max_characters =26

        # OUTPUT FUNCTION IS IMPLEMENTED USING out []
        # Bit i in this mask is 1 if the word with
        # index i appears when the machine enters this state.
        # Lets say, a state outputs two words ""he"" and ""she"" and
        # in our provided words list, he has index 0 and she has index 3
        # so value of out[state] for this state will be 1001
        # It has been initialized to all 0.
        # We have taken one extra state for the root.
        self.out =[0]*(self.max_states+1)

        # FAILURE FUNCTION IS IMPLEMENTED USING fail []
        # There is one value for each state + 1 for the root
        # It has been initialized to all -1
        # This will contain the fail state value for each state
        self.fail =[-1]*(self.max_states+1)

        # GOTO FUNCTION (OR TRIE) IS IMPLEMENTED USING goto [[]]
        # Number of rows = max_states + 1
        # Number of columns = max_characters i.e 26 in our case
        # It has been initialized to all -1.
        self.goto =[[-1]*self.max_characters for_ inrange(self.max_states+1)]
        
        # Convert all words to lowercase
        # so that our search is case insensitive
        fori inrange(len(words)):
          words[i] =words[i].lower()
          
        # All the words in dictionary which will be used to create Trie
        # The index of each keyword is important:
        # ""out[state] & (1 << i)"" is > 0 if we just found word[i]
        # in the text.
        self.words =words

        # Once the Trie has been built, it will contain the number
        # of nodes in Trie which is total number of states required <= max_states
        self.states_count =self.__build_matching_machine()


    # Builds the String matching machine.
    # Returns the number of states that the built machine has.
    # States are numbered 0 up to the return value - 1, inclusive.
    def__build_matching_machine(self):
        k =len(self.words)

        # Initially, we just have the 0 state
        states =1

        # Convalues for goto function, i.e., fill goto
        # This is same as building a Trie for words[]
        fori inrange(k):
            word =self.words[i]
            current_state =0

            # Process all the characters of the current word
            forcharacter inword:
                ch =ord(character) -97# Ascii value of 'a' = 97

                # Allocate a new node (create a new state)
                # if a node for ch doesn't exist.
                ifself.goto[current_state][ch] ==-1:
                    self.goto[current_state][ch] =states
                    states +=1

                current_state =self.goto[current_state][ch]

            # Add current word in output function
            self.out[current_state] |=(1<<i)

        # For all characters which don't have
        # an edge from root (or state 0) in Trie,
        # add a goto edge to state 0 itself
        forch inrange(self.max_characters):
            ifself.goto[0][ch] ==-1:
                self.goto[0][ch] =0
        
        # Failure function is computed in 
        # breadth first order using a queue
        queue =[]

        # Iterate over every possible input
        forch inrange(self.max_characters):

            # All nodes of depth 1 have failure
            # function value as 0. For example,
            # in above diagram we move to 0
            # from states 1 and 3.
            ifself.goto[0][ch] !=0:
                self.fail[self.goto[0][ch]] =0
                queue.append(self.goto[0][ch])

        # Now queue has states 1 and 3
        whilequeue:

            # Remove the front state from queue
            state =queue.pop(0)

            # For the removed state, find failure
            # function for all those characters
            # for which goto function is not defined.
            forch inrange(self.max_characters):

                # If goto function is defined for
                # character 'ch' and 'state'
                ifself.goto[state][ch] !=-1:

                    # Find failure state of removed state
                    failure =self.fail[state]

                    # Find the deepest node labeled by proper
                    # suffix of String from root to current state.
                    whileself.goto[failure][ch] ==-1:
                        failure =self.fail[failure]
                    
                    failure =self.goto[failure][ch]
                    self.fail[self.goto[state][ch]] =failure

                    # Merge output values
                    self.out[self.goto[state][ch]] |=self.out[failure]

                    # Insert the next level node (of Trie) in Queue
                    queue.append(self.goto[state][ch])
        
        returnstates


    # Returns the next state the machine will transition to using goto
    # and failure functions.
    # current_state - The current state of the machine. Must be between
    #             0 and the number of states - 1, inclusive.
    # next_input - The next character that enters into the machine.
    def__find_next_state(self, current_state, next_input):
        answer =current_state
        ch =ord(next_input) -97# Ascii value of 'a' is 97

        # If goto is not defined, use
        # failure function
        whileself.goto[answer][ch] ==-1:
            answer =self.fail[answer]

        returnself.goto[answer][ch]


    # This function finds all occurrences of all words in text.
    defsearch_words(self, text):
        # Convert the text to lowercase to make search case insensitive
        text =text.lower()

        # Initialize current_state to 0 
        current_state =0

        # A dictionary to store the result.
        # Key here is the found word
        # Value is a list of all occurrences start index
        result =defaultdict(list)

        # Traverse the text through the built machine
        # to find all occurrences of words
        fori inrange(len(text)):
            current_state =self.__find_next_state(current_state, text[i])

            # If match not found, move to next state
            ifself.out[current_state] ==0: continue

            # Match found, store the word in result dictionary
            forj inrange(len(self.words)):
                if(self.out[current_state] & (1<<j)) > 0:
                    word =self.words[j]

                    # Start index of word is (i-len(word)+1)
                    result[word].append(i-len(word)+1)

        # Return the final result dictionary
        returnresult

# Driver code
if__name__ ==""__main__"":
    words =[""he"", ""she"", ""hers"", ""his""]
    text =""ahishers""

    # Create an Object to initialize the Trie
    aho_chorasick =AhoCorasick(words)

    # Get the result
    result =aho_chorasick.search_words(text)

    # Print the result
    forword inresult:
        fori inresult[word]:
            print(""Word"", word, ""appears from"", i, ""to"", i+len(word)-1)
            
# This code is contributed by Md Azharuddin
",O(n + l + z),O(l * q)
"defrotate(L, d, n):
    k =L.index(d)
    new_lis =[]
    new_lis =L[k+1:]+L[0:k+1]
    returnnew_lis


if__name__ =='__main__':
    arr =[1, 2, 3, 4, 5, 6, 7]
    d =2
    N =len(arr)

    # Function call
    arr =rotate(arr, d, N)
    fori inarr:
        print(i, end="" "")
",O(N),O(N)
"# Python program to rotate an array by d elements

# Function to left rotate arr[] of size n by d
defRotate(arr, d, n):
  p =1
  while(p <=d):
    last =arr[0]
    fori inrange(n -1):
      arr[i] =arr[i +1]
    arr[n -1] =last
    p =p +1
    
# Function to print an array
defprintArray(arr, size):
  fori inrange(size):
    print(arr[i] ,end ="" "")
    
# Driver code
arr =[1, 2, 3, 4, 5, 6, 7]
N =len(arr)
d =2

# Function calling
Rotate(arr, d, N)
printArray(arr, N)

# This code is contributed by Atul_kumar_Shrivastava
",O(N*d),O(1)
"# Python3 program to rotate an array by
# d elements
# Function to left rotate arr[] of size n by d


defleftRotate(arr, d, n):
    d =d %n
    g_c_d =gcd(d, n)
    fori inrange(g_c_d):

        # move i-th values of blocks
        temp =arr[i]
        j =i
        while1:
            k =j +d
            ifk >=n:
                k =k -n
            ifk ==i:
                break
            arr[j] =arr[k]
            j =k
        arr[j] =temp

# UTILITY FUNCTIONS
# function to print an array


defprintArray(arr, size):
    fori inrange(size):
        print(""% d""%arr[i], end="" "")

# Function to get gcd of a and b


defgcd(a, b):
    ifb ==0:
        returna
    else:
        returngcd(b, a %b)


# Driver program to test above functions
arr =[1, 2, 3, 4, 5, 6, 7]
n =len(arr)
d =2
leftRotate(arr, d, n)
printArray(arr, n)

# This code is contributed by Shreyanshi Arun
",O(N),O(1)
"# Returns the new average
# after including x
defgetAvg(x, n, sum):
    sum=sum+x;
    returnfloat(sum) /n;

# Prints average of a 
# stream of numbers
defstreamAvg(arr, n):
    avg =0;
    sum=0;
    fori inrange(n):
        avg =getAvg(arr[i], i +1, sum);
        sum=avg *(i +1);
        print(""Average of "", end ="""");
        print(i +1, end ="""");
        print("" numbers is "", end ="""");
        print(avg);
    return;

# Driver Code
arr=[ 10, 20, 30, 
       40, 50, 60];
n =len(arr);
streamAvg(arr,n);

# This code is contributed by mits
",O(n),O(1)
"# Python code to delete a node in AVL tree
# Generic tree node class


classTreeNode():
    def__init__(self, val):
        self.count =1# assigning count variable so that during insertion in will be incremented for duplicate values
        # and during deletion, it will be decremented if has multiple copies.
        self.height =1
        self.val =val
        self.left =None
        self.right =None
# only insertion and deletion will be affected. if multiple copies are there, entry(count) will be printed during traversal.

# AVL tree class which supports insertion,
# deletion operations


classAVL_Tree(object):

    definsert(self, root, key):

        # Step 1 - Perform normal BST
        ifnotroot:
            returnTreeNode(key)
        elseifkey < root.val:
            root.left =self.insert(root.left, key)
        elseifkey > root.val:
            root.right =self.insert(root.right, key)
        else:
            root.count +=1# incrementing count if same entry is inserted.

        # Step 2 - Update the height of the
        # ancestor node
        root.height =1+max(self.getHeight(root.left),
                              self.getHeight(root.right))

        # Step 3 - Get the balance factor
        balance =self.getBalance(root)

        # Step 4 - If the node is unbalanced,
        # then try out the 4 cases
        # Case 1 - Left Left
        ifbalance > 1andkey < root.left.val:
            returnself.rightRotate(root)

        # Case 2 - Right Right
        ifbalance < -1andkey > root.right.val:
            returnself.leftRotate(root)

        # Case 3 - Left Right
        ifbalance > 1andkey > root.left.val:
            root.left =self.leftRotate(root.left)
            returnself.rightRotate(root)

        # Case 4 - Right Left
        ifbalance < -1andkey < root.right.val:
            root.right =self.rightRotate(root.right)
            returnself.leftRotate(root)

        returnroot

    # Recursive function to delete a node with
    # given key from subtree with given root.
    # It returns root of the modified subtree.
    defdelete(self, root, key):

        # Step 1 - Perform standard BST delete
        ifnotroot:
            returnroot

        elseifkey < root.val:
            root.left =self.delete(root.left, key)

        elseifkey > root.val:
            root.right =self.delete(root.right, key)

        else:
            ifroot.count > 1:  # if count is more than one i.e multiple copies are there
                root.count -=1# just decrement count
                returnroot   # so that one copy will be deleted and return

            ifroot.left isNone:
                temp =root.right
                root =None
                returntemp

            elseifroot.right isNone:
                temp =root.left
                root =None
                returntemp

            temp =self.getMinValueNode(root.right)
            root.val =temp.val
            root.right =self.delete(root.right,
                                     temp.val)

        # If the tree has only one node,
        # simply return it
        ifroot isNone:
            returnroot

        # Step 2 - Update the height of the
        # ancestor node
        root.height =1+max(self.getHeight(root.left),
                              self.getHeight(root.right))

        # Step 3 - Get the balance factor
        balance =self.getBalance(root)

        # Step 4 - If the node is unbalanced,
        # then try out the 4 cases
        # Case 1 - Left Left
        ifbalance > 1andself.getBalance(root.left) >=0:
            returnself.rightRotate(root)

        # Case 2 - Right Right
        ifbalance < -1andself.getBalance(root.right) <=0:
            returnself.leftRotate(root)

        # Case 3 - Left Right
        ifbalance > 1andself.getBalance(root.left) < 0:
            root.left =self.leftRotate(root.left)
            returnself.rightRotate(root)

        # Case 4 - Right Left
        ifbalance < -1andself.getBalance(root.right) > 0:
            root.right =self.rightRotate(root.right)
            returnself.leftRotate(root)

        returnroot

    defleftRotate(self, z):

        y =z.right
        T2 =y.left

        # Perform rotation
        y.left =z
        z.right =T2

        # Update heights
        z.height =1+max(self.getHeight(z.left),
                           self.getHeight(z.right))
        y.height =1+max(self.getHeight(y.left),
                           self.getHeight(y.right))

        # Return the new root
        returny

    defrightRotate(self, z):

        y =z.left
        T3 =y.right

        # Perform rotation
        y.right =z
        z.left =T3

        # Update heights
        z.height =1+max(self.getHeight(z.left),
                           self.getHeight(z.right))
        y.height =1+max(self.getHeight(y.left),
                           self.getHeight(y.right))

        # Return the new root
        returny

    defgetHeight(self, root):
        ifnotroot:
            return0

        returnroot.height

    defgetBalance(self, root):
        ifnotroot:
            return0

        returnself.getHeight(root.left) -self.getHeight(root.right)

    defgetMinValueNode(self, root):
        ifroot isNoneorroot.left isNone:
            returnroot

        returnself.getMinValueNode(root.left)

    defpreOrder(self, root):

        ifnotroot:
            return

        print(""{}({}) "".format(root.val, root.count), end="""")
        self.preOrder(root.left)
        self.preOrder(root.right)


myTree =AVL_Tree()
root =None
nums =[9, 5, 10, 5, 9, 7, 17]

fornum innums:
    root =myTree.insert(root, num)

# Preorder Traversal
print(""Preorder Traversal after insertion -"")
myTree.preOrder(root)
print()

# Delete
key =10
root =myTree.delete(root, key)
key =10
root =myTree.delete(root, key)
key =-1
root =myTree.delete(root, key)
key =0
root =myTree.delete(root, key)

# Preorder Traversal
print(""Preorder Traversal after deletion -"")
myTree.preOrder(root)
print()

# This code is contributed by Ajitesh Pathak
",O(N),O(1)
"# Python implementation of Binary Indexed Tree 
 
# Returns sum of arr[0..index]. This function assumes 
# that the array is preprocessed and partial sums of 
# array elements are stored in BITree[]. 
defgetsum(BITTree,i): 
    s =0#initialize result 
 
    # index in BITree[] is 1 more than the index in arr[] 
    i =i+1
 
    # Traverse ancestors of BITree[index] 
    whilei > 0: 
 
        # Add current element of BITree to sum 
        s +=BITTree[i] 
 
        # Move index to parent node in getSum View 
        i -=i & (-i) 
    returns 
 
# Updates a node in Binary Index Tree (BITree) at given index 
# in BITree. The given value 'val' is added to BITree[i] and 
# all of its ancestors in tree. 
defupdatebit(BITTree , n , i ,v): 
 
    # index in BITree[] is 1 more than the index in arr[] 
    i +=1
 
    # Traverse all ancestors and add 'val' 
    whilei <=n: 
 
        # Add 'val' to current node of BI Tree 
        BITTree[i] +=v 
 
        # Update index to that of parent in update View 
        i +=i & (-i) 
 
 
# Constructs and returns a Binary Indexed Tree for given 
# array of size n. 
defconstruct(arr, n): 
 
    # Create and initialize BITree[] as 0 
    BITTree =[0]*(n+1) 
 
    # Store the actual values in BITree[] using update() 
    fori inrange(n): 
        updatebit(BITTree, n, i, arr[i]) 
 
    # Uncomment below lines to see contents of BITree[] 
    #for i in range(1,n+1): 
    #     print BITTree[i], 
    returnBITTree 
 
 
# Driver code to test above methods 
freq =[2, 1, 1, 3, 2, 3, 4, 5, 6, 7, 8, 9] 
BITTree =construct(freq,len(freq)) 
print(""Sum of elements in arr[0..5] is ""+str(getsum(BITTree,5))) 
freq[3] +=6
updatebit(BITTree, len(freq), 3, 6) 
print(""Sum of elements in arr[0..5]""+
                    "" after update is ""+str(getsum(BITTree,5))) 
 
# This code is contributed by Raju Varshney 
",O(NLogN),O(N)
"# Python3 program to demonstrate Range Update
# and Range Queries using BIT

# Returns sum of arr[0..index]. This function assumes
# that the array is preprocessed and partial sums of
# array elements are stored in BITree[]


defgetSum(BITree: list, index: int) -> int:
    summ =0# Initialize result

    # index in BITree[] is 1 more than the index in arr[]
    index =index +1

    # Traverse ancestors of BITree[index]
    whileindex > 0:

        # Add current element of BITree to sum
        summ +=BITree[index]

        # Move index to parent node in getSum View
        index -=index & (-index)
    returnsumm

# Updates a node in Binary Index Tree (BITree) at given
# index in BITree. The given value 'val' is added to
# BITree[i] and all of its ancestors in tree.


defupdateBit(BITTree: list, n: int, index: int, val: int) -> None:

    # index in BITree[] is 1 more than the index in arr[]
    index =index +1

    # Traverse all ancestors and add 'val'
    whileindex <=n:

        # Add 'val' to current node of BI Tree
        BITTree[index] +=val

        # Update index to that of parent in update View
        index +=index & (-index)


# Returns the sum of array from [0, x]
defsummation(x: int, BITTree1: list, BITTree2: list) -> int:
    return(getSum(BITTree1, x) *x) -getSum(BITTree2, x)


defupdateRange(BITTree1: list, BITTree2: list, n: int, val: int, l: int,
                r: int) -> None:

    # Update Both the Binary Index Trees
    # As discussed in the article

    # Update BIT1
    updateBit(BITTree1, n, l, val)
    updateBit(BITTree1, n, r +1, -val)

    # Update BIT2
    updateBit(BITTree2, n, l, val *(l -1))
    updateBit(BITTree2, n, r +1, -val *r)


defrangeSum(l: int, r: int, BITTree1: list, BITTree2: list) -> int:

    # Find sum from [0,r] then subtract sum
    # from [0,l-1] in order to find sum from
    # [l,r]
    returnsummation(r, BITTree1, BITTree2) -summation(
        l -1, BITTree1, BITTree2)


# Driver Code
if__name__ ==""__main__"":
    n =5

    # BIT1 to get element at any index
    # in the array
    BITTree1 =[0] *(n +1)

    # BIT 2 maintains the extra term
    # which needs to be subtracted
    BITTree2 =[0] *(n +1)

    # Add 5 to all the elements from [0,4]
    l =0
    r =4
    val =5
    updateRange(BITTree1, BITTree2, n, val, l, r)

    # Add 10 to all the elements from [2,4]
    l =2
    r =4
    val =10
    updateRange(BITTree1, BITTree2, n, val, l, r)

    # Find sum of all the elements from
    # [1,4]
    l =1
    r =4
    print(""Sum of elements from [%d,%d] is %d""%
          (l, r, rangeSum(l, r, BITTree1, BITTree2)))

# This code is contributed by
# sanjeev2552
",O(q * log(N)),O(N)
"# Python3 program to demonstrate Range 
# Update and PoQueries Without using BIT 

# Updates such that getElement() gets an 
# increased value when queried from l to r. 
defupdate(arr, l, r, val):
    arr[l] +=val
    ifr +1< len(arr):
        arr[r +1] -=val

# Get the element indexed at i 
defgetElement(arr, i):
    
    # To get ith element sum of all the elements 
    # from 0 to i need to be computed 
    res =0
    forj inrange(i +1):
        res +=arr[j] 

    returnres

# Driver Code
if__name__ =='__main__': 
    arr =[0, 0, 0, 0, 0] 
    n =len(arr) 

    l =2
    r =4
    val =2
    update(arr, l, r, val) 

    # Find the element at Index 4 
    index =4
    print(""Element at index"", index, 
          ""is"", getElement(arr, index)) 

    l =0
    r =3
    val =4
    update(arr, l, r, val) 

    # Find the element at Index 3 
    index =3
    print(""Element at index"", index,
          ""is"", getElement(arr, index))

# This code is contributed by PranchalK
",O(q*n),O(n)
"# Python3 code to demonstrate Range Update and
# PoQueries on a Binary Index Tree

# Updates a node in Binary Index Tree (BITree) at given index
# in BITree. The given value 'val' is added to BITree[i] and
# all of its ancestors in tree.
defupdateBIT(BITree, n, index, val):
    
    # index in BITree[] is 1 more than the index in arr[]
    index =index +1

    # Traverse all ancestors and add 'val'
    while(index <=n):
        
        # Add 'val' to current node of BI Tree
        BITree[index] +=val

        # Update index to that of parent in update View
        index +=index & (-index)

# Constructs and returns a Binary Indexed Tree for given
# array of size n.
defconstructBITree(arr, n):
    
    # Create and initialize BITree[] as 0
    BITree =[0]*(n+1)

    # Store the actual values in BITree[] using update()
    fori inrange(n):
        updateBIT(BITree, n, i, arr[i])

    returnBITree

# SERVES THE PURPOSE OF getElement()
# Returns sum of arr[0..index]. This function assumes
# that the array is preprocessed and partial sums of
# array elements are stored in BITree[]
defgetSum(BITree, index):
    sum=0# Initialize result

    # index in BITree[] is 1 more than the index in arr[]
    index =index +1

    # Traverse ancestors of BITree[index]
    while(index > 0):
        
        # Add current element of BITree to sum
        sum+=BITree[index]

        # Move index to parent node in getSum View
        index -=index & (-index)
    returnsum

# Updates such that getElement() gets an increased
# value when queried from l to r.
defupdate(BITree, l, r, n, val):
    
    # Increase value at 'l' by 'val'
    updateBIT(BITree, n, l, val)

    # Decrease value at 'r+1' by 'val'
    updateBIT(BITree, n, r+1, -val)

# Driver code
arr =[0, 0, 0, 0, 0]
n =len(arr)
BITree =constructBITree(arr, n)

# Add 2 to all the element from [2,4]
l =2
r =4
val =2
update(BITree, l, r, n, val)

# Find the element at Index 4
index =4
print(""Element at index"", index, ""is"", getSum(BITree, index))

# Add 2 to all the element from [0,3]
l =0
r =3
val =4
update(BITree, l, r, n, val)

# Find the element at Index 3
index =3
print(""Element at index"", index, ""is"", getSum(BITree,index))

# This code is contributed by mohit kumar 29
",O(q * log n) + O(n * log n),O(n)
"# Python3 function to search a given key in a given BST

classNode:
    # Constructor to create a new node
    def__init__(self, key):
        self.key =key
        self.left =None
        self.right =None

# A utility function to insert
# a new node with the given key in BST
definsert(node, key):
    # If the tree is empty, return a new node
    ifnode isNone:
        returnNode(key)

    # Otherwise, recur down the tree
    ifkey < node.key:
        node.left =insert(node.left, key)
    elifkey > node.key:
        node.right =insert(node.right, key)

    # Return the (unchanged) node pointer
    returnnode

# Utility function to search a key in a BST
defsearch(root, key):
    # Base Cases: root is null or key is present at root
    ifroot isNoneorroot.key ==key:
        returnroot

    # Key is greater than root's key
    ifroot.key < key:
        returnsearch(root.right, key)

    # Key is smaller than root's key
    returnsearch(root.left, key)

# Driver Code
if__name__ =='__main__':
    root =None
    root =insert(root, 50)
    insert(root, 30)
    insert(root, 20)
    insert(root, 40)
    insert(root, 70)
    insert(root, 60)
    insert(root, 80)

    # Key to be found
    key =6

    # Searching in a BST
    ifsearch(root, key) isNone:
        print(key, ""not found"")
    else:
        print(key, ""found"")

    key =60

    # Searching in a BST
    ifsearch(root, key) isNone:
        print(key, ""not found"")
    else:
        print(key, ""found"")
",O(h),O(h)
"# Program to convert binary tree to BST

# A binary tree node
classNode:
    
    # Constructor to create a new node
    def__init__(self, data):
        self.data =data 
        self.left =None
        self.right =None

# Helper function to store the inorder traversal of a tree
defstoreInorder(root, inorder):
    
    # Base Case
    ifroot isNone:
        return
    
    # First store the left subtree
    storeInorder(root.left, inorder)
    
    # Copy the root's data
    inorder.append(root.data)

    # Finally store the right subtree
    storeInorder(root.right, inorder)

# A helper function to count nodes in a binary tree
defcountNodes(root):
    ifroot isNone:
        return0

    returncountNodes(root.left) +countNodes(root.right) +1

# Helper function that copies contents of sorted array 
# to Binary tree
defarrayToBST(arr, root):

    # Base Case
    ifroot isNone:
        return
    
    # First update the left subtree
    arrayToBST(arr, root.left)

    # now update root's data delete the value from array
    root.data =arr[0]
    arr.pop(0)

    # Finally update the right subtree
    arrayToBST(arr, root.right)

# This function converts a given binary tree to BST
defbinaryTreeToBST(root):
    
    # Base Case: Tree is empty
    ifroot isNone:
        return
    
    # Count the number of nodes in Binary Tree so that 
    # we know the size of temporary array to be created
    n =countNodes(root)

    # Create the temp array and store the inorder traversal 
    # of tree 
    arr =[]
    storeInorder(root, arr)
    
    # Sort the array
    arr.sort()

    # copy array elements back to binary tree
    arrayToBST(arr, root)

# Print the inorder traversal of the tree
defprintInorder(root):
    ifroot isNone:
        return
    printInorder(root.left)
    print(root.data,end="" "")
    printInorder(root.right)

# Driver program to test above function
root =Node(10)
root.left =Node(30)
root.right =Node(15)
root.left.left =Node(20)
root.right.right =Node(5)

# Convert binary tree to BST 
binaryTreeToBST(root)

print(""Following is the inorder traversal of the converted BST"")
printInorder(root)

# This code is contributed by Nikhil Kumar Singh(nickzuck_007)
",O(nlogn),O(n)
"# Definition for a binary tree node.
classTreeNode:
    def__init__(self, x):
        self.val =x
        self.left =None
        self.right =None

# Inorder traversal to store the nodes in a list
definorder(root, nodes):
    ifroot isNone:
        return
    inorder(root.left, nodes)
    nodes.append(root)
    inorder(root.right, nodes)

# Function to construct a binary search tree from a sorted list
defconstructBST(nodes, start, end):
    ifstart > end:
        returnNone
    mid =(start +end) //2
    root =nodes[mid]
    root.left =constructBST(nodes, start, mid -1)
    root.right =constructBST(nodes, mid +1, end)
    returnroot

# Function to convert a binary tree to a binary search tree
defconvertToBST(root):
    nodes =[]
    inorder(root, nodes)
    nodes.sort(key=lambdanode: node.val)
    returnconstructBST(nodes, 0, len(nodes) -1)

# Function to print the inorder traversal of a binary tree
defprintInorder(root):
    ifroot isNone:
        return
    printInorder(root.left)
    print(root.val, end="" "")
    printInorder(root.right)

# Driver code
if__name__ ==""__main__"":
    # Example binary tree
    root =TreeNode(10)
    root.left =TreeNode(30)
    root.right =TreeNode(15)
    root.left.left =TreeNode(20)
    root.left.right =TreeNode(5)

    # Convert binary tree to binary search tree
    bst =convertToBST(root)

    print(""Following is Inorder Traversal of the converted BST:"")
    printInorder(bst)
    print()
    
    
# by phasing17
",O(nlogn),O(n)
"# Python program to find out whether a 
# given graph is Bipartite or not

classGraph():

    def__init__(self, V):
        self.V =V
        self.graph =[[0forcolumn inrange(V)] \
                                forrow inrange(V)]

    # This function returns true if graph G[V][V] 
    # is Bipartite, else false
    defisBipartite(self, src):

        # Create a color array to store colors 
        # assigned to all vertices. Vertex
        # number is used as index in this array. 
        # The value '-1' of  colorArr[i] is used to 
        # indicate that no color is assigned to 
        # vertex 'i'. The value 1 is used to indicate 
        # first color is assigned and value 0
        # indicates second color is assigned.
        colorArr =[-1] *self.V

        # Assign first color to source
        colorArr[src] =1

        # Create a queue (FIFO) of vertex numbers and 
        # enqueue source vertex for BFS traversal
        queue =[]
        queue.append(src)

        # Run while there are vertices in queue 
        # (Similar to BFS)
        whilequeue:

            u =queue.pop()

            # Return false if there is a self-loop
            ifself.graph[u][u] ==1:
                returnFalse;

            forv inrange(self.V):

                # An edge from u to v exists and destination 
                # v is not colored
                ifself.graph[u][v] ==1andcolorArr[v] ==-1:

                    # Assign alternate color to this 
                    # adjacent v of u
                    colorArr[v] =1-colorArr[u]
                    queue.append(v)

                # An edge from u to v exists and destination 
                # v is colored with same color as u
                elifself.graph[u][v] ==1andcolorArr[v] ==colorArr[u]:
                    returnFalse

        # If we reach here, then all adjacent 
        # vertices can be colored with alternate 
        # color
        returnTrue

# Driver program to test above function
g =Graph(4)
g.graph =[[0, 1, 0, 1],
            [1, 0, 1, 0],
            [0, 1, 0, 1],
            [1, 0, 1, 0]
            ]
            
print(""Yes""ifg.isBipartite(0) else""No"")

# This code is contributed by Divyanshu Mehta
",O(V*V),O(V)
"# Python3 program to find out whether a
# given graph is Bipartite or not


classGraph():

    def__init__(self, V):
        self.V =V
        self.graph =[[0forcolumn inrange(V)]
                      forrow inrange(V)]

        self.colorArr =[-1fori inrange(self.V)]

    # This function returns true if graph G[V][V]
    # is Bipartite, else false
    defisBipartiteUtil(self, src):

        # Create a color array to store colors
        # assigned to all vertices. Vertex
        # number is used as index in this array.
        # The value '-1' of self.colorArr[i] is used
        # to indicate that no color is assigned to
        # vertex 'i'. The value 1 is used to indicate
        # first color is assigned and value 0
        # indicates second color is assigned.

        # Assign first color to source

        # Create a queue (FIFO) of vertex numbers and
        # enqueue source vertex for BFS traversal
        queue =[]
        queue.append(src)

        # Run while there are vertices in queue
        # (Similar to BFS)
        whilequeue:

            u =queue.pop()

            # Return false if there is a self-loop
            ifself.graph[u][u] ==1:
                returnFalse

            forv inrange(self.V):

                # An edge from u to v exists and
                # destination v is not colored
                if(self.graph[u][v] ==1and
                        self.colorArr[v] ==-1):

                    # Assign alternate color to
                    # this adjacent v of u
                    self.colorArr[v] =1-self.colorArr[u]
                    queue.append(v)

                # An edge from u to v exists and destination
                # v is colored with same color as u
                elif(self.graph[u][v] ==1and
                      self.colorArr[v] ==self.colorArr[u]):
                    returnFalse

        # If we reach here, then all adjacent
        # vertices can be colored with alternate
        # color
        returnTrue

    defisBipartite(self):
        self.colorArr =[-1fori inrange(self.V)]
        fori inrange(self.V):
            ifself.colorArr[i] ==-1:
                ifnotself.isBipartiteUtil(i):
                    returnFalse
        returnTrue


# Driver Code
g =Graph(4)
g.graph =[[0, 1, 0, 1],
           [1, 0, 1, 0],
           [0, 1, 0, 1],
           [1, 0, 1, 0]]

print(""Yes""ifg.isBipartite() else""No"")

# This code is contributed by Anshuman Sharma
",O(V*V),O(V)
"defisBipartite(V, adj):
    # vector to store colour of vertex
    # assigning all to -1 i.e. uncoloured
    # colours are either 0 or 1
    # for understanding take 0 as red and 1 as blue
    col =[-1]*(V)
  
    # queue for BFS storing {vertex , colour}
    q =[]
  
    #loop incase graph is not connected
    fori inrange(V):
      
        # if not coloured
        if(col[i] ==-1):
          
            # colouring with 0 i.e. red
            q.append([i, 0])
            col[i] =0
          
            whilelen(q) !=0:
                p =q[0]
                q.pop(0)
              
                # current vertex
                v =p[0]
                
                # colour of current vertex
                c =p[1]
                  
                # traversing vertexes connected to current vertex
                forj inadj[v]:
                  
                    # if already coloured with parent vertex color
                    # then bipartite graph is not possible
                    if(col[j] ==c):
                        returnFalse
                  
                    # if uncoloured
                    if(col[j] ==-1):
                      
                        # colouring with opposite color to that of parent
                        ifc ==1:
                            col[j] =0
                        else:
                            col[j] =1
                        q.append([j, col[j]])
    
    # if all vertexes are coloured such that
    # no two connected vertex have same colours
    returnTrue

V, E =4, 8

# adjacency list for storing graph
adj =[]
adj.append([1,3])
adj.append([0,2])
adj.append([1,3])
adj.append([0,2])
 
ans =isBipartite(V, adj)

# returns 1 if bipartite graph is possible
if(ans):
    print(""Yes"")
    
# returns 0 if bipartite graph is not possible
else:
    print(""No"")
    
    # This code is contributed by divyesh072019.
",O(V+E),O(V)
"# Python3 program to find out whether a given 
# graph is Bipartite or not using recursion. 
V =4

defcolorGraph(G, color, pos, c): 
    
    ifcolor[pos] !=-1andcolor[pos] !=c: 
        returnFalse
        
    # color this pos as c and all its neighbours and 1-c 
    color[pos] =c 
    ans =True
    fori inrange(0, V): 
        ifG[pos][i]: 
            ifcolor[i] ==-1: 
                ans &=colorGraph(G, color, i, 1-c) 
                
            ifcolor[i] !=-1andcolor[i] !=1-c: 
                returnFalse
         
        ifnotans: 
            returnFalse
     
    returnTrue
 
defisBipartite(G): 
    
    color =[-1] *V 
        
    #start is vertex 0 
    pos =0
    # two colors 1 and 0 
    returncolorGraph(G, color, pos, 1) 

if__name__ ==""__main__"": 
 
    G =[[0, 1, 0, 1], 
         [1, 0, 1, 0], 
         [0, 1, 0, 1], 
         [1, 0, 1, 0]] 
     
    ifisBipartite(G): print(""Yes"") 
    else: print(""No"") 

# This code is contributed by Rituraj Jain
",O(V+E),O(V)
"# Wrapper over the recursive function leftRotateRec() 
# It left rotates arr by d. 
defleftRotate(arr, d, n): 
    leftRotateRec(arr, 0, d, n); 
 
defleftRotateRec(arr, i, d, n): 
    ''' 
     * Return If number of elements to be  
     rotated is zero or equal to array size 
     '''
    if(d ==0ord ==n): 
        return; 
 
    ''' 
     * If number of elements to be rotated  
     is exactly half of array size 
     '''
    if(n -d ==d): 
        swap(arr, i, n -d +i, d); 
        return; 
 
    ''' If A is shorter '''
    if(d < n -d): 
        swap(arr, i, n -d +i, d); 
        leftRotateRec(arr, i, d, n -d); 
        ''' If B is shorter '''
    else: 
        swap(arr, i, d, n -d); 
         
        ''' This is tricky '''
        leftRotateRec(arr, n -d +i, 2*d -n, d);  
 
''' UTILITY FUNCTIONS '''
''' function to print an array '''
defprintArray(arr, size): 
    fori inrange(size): 
        print(arr[i], end ="" ""); 
    print(); 
 
''' 
 * This function swaps d elements starting at  
 * index fi with d elements starting at index si 
 '''
defswap(arr, fi, si, d): 
    fori inrange(d): 
        temp =arr[fi +i]; 
        arr[fi +i] =arr[si +i]; 
        arr[si +i] =temp; 
 
# Driver Code 
if__name__ =='__main__': 
    arr =[1, 2, 3, 4, 5, 6, 7]; 
    leftRotate(arr, 2, 7); 
    printArray(arr, 7); 
 
# This code is contributed by Rohit_ranjan
",O(n),O(log n)
"# Python3 code for above implementation 
 
# Wrapper over the recursive function leftRotateRec() 
# It left rotates arr by d. 
 
 
''' UTILITY FUNCTIONS '''
''' function to print an array '''
 
 
defprintArray(arr, size): 
    fori inrange(size): 
        print(arr[i], end="" "") 
    print() 
 
 
''' 
 * This function swaps d elements starting at  
 * index fi with d elements starting at index si 
 '''
 
 
defswap(arr, fi, si, d): 
    fori inrange(d): 
        temp =arr[fi +i] 
        arr[fi +i] =arr[si +i] 
        arr[si +i] =temp 
 
 
defleftRotate(arr, d, n): 
    if(d ==0ord ==n): 
        return
    i =d 
    j =n -d 
    while(i !=j): 
 
        if(i < j):  # A is shorter 
            swap(arr, d -i, d +j -i, i) 
            j -=i 
 
        else:  # B is shorter 
            swap(arr, d -i, d, j) 
            i -=j 
 
    swap(arr, d -i, d, i) 
 
 
    # Driver Code 
if__name__ =='__main__': 
    arr =[1, 2, 3, 4, 5, 6, 7] 
    leftRotate(arr, 2, 7) 
    printArray(arr, 7) 
",O(n),O(1)
"# Python3 program for Boggle game
# Let the given dictionary be following

dictionary =[""GEEKS"", ""FOR"", ""QUIZ"", ""GO""]
n =len(dictionary)
M =3
N =3

# A given function to check if a given string
# is present in dictionary. The implementation is
# naive for simplicity. As per the question
# dictionary is given to us.
defisWord(Str):
  
    # Linearly search all words
    fori inrange(n):
        if(Str==dictionary[i]):
            returnTrue
    returnFalse

# A recursive function to print all words present on boggle
deffindWordsUtil(boggle, visited, i, j, Str):
    # Mark current cell as visited and
    # append current character to str
    visited[i][j] =True
    Str=Str+boggle[i][j]
    
    # If str is present in dictionary,
    # then print it
    if(isWord(Str)):
        print(Str)
    
    # Traverse 8 adjacent cells of boggle[i,j]
    row =i -1
    whilerow <=i +1androw < M:
        col =j -1
        whilecol <=j +1andcol < N:
            if(row >=0andcol >=0andnotvisited[row][col]):
                findWordsUtil(boggle, visited, row, col, Str)
            col+=1
        row+=1
    
    # Erase current character from string and
    # mark visited of current cell as false
    Str="""" +Str[-1]
    visited[i][j] =False

# Prints all words present in dictionary.
deffindWords(boggle):
  
    # Mark all characters as not visited
    visited =[[Falsefori inrange(N)] forj inrange(M)]
    
    # Initialize current string
    Str=""""
    
    # Consider every character and look for all words
    # starting with this character
    fori inrange(M):
      forj inrange(N):
        findWordsUtil(boggle, visited, i, j, Str)

# Driver Code
boggle =[[""G"", ""I"", ""Z""], [""U"", ""E"", ""K""], [""Q"", ""S"", ""E""]]

print(""Following words of"", ""dictionary are present"")
findWords(boggle)

#  This code is contributed by divyesh072019.
",O(N2 *M2),O(N*M)
"defdfs(board, s, i, j, n, m, idx):
    ifi < 0ori >=n orj < 0orj >=m:
        returnFalse
    ifs[idx] !=board[i][j]:
        returnFalse
    ifidx ==len(s) -1:
        returnTrue
    temp =board[i][j]
    board[i][j] ='*'
    a =dfs(board, s, i, j+1, n, m, idx+1)
    b =dfs(board, s, i, j-1, n, m, idx+1)
    c =dfs(board, s, i+1, j, n, m, idx+1)
    d =dfs(board, s, i-1, j, n, m, idx+1)
    e =dfs(board, s, i+1, j+1, n, m, idx+1)
    f =dfs(board, s, i-1, j+1, n, m, idx+1)
    g =dfs(board, s, i+1, j-1, n, m, idx+1)
    h =dfs(board, s, i-1, j-1, n, m, idx+1)
    board[i][j] =temp
    returna orb orc ore orf org orh ord

defwordBoggle(board, dictionary):
    n =len(board)
    m =len(board[0])
    store =set()
    
    #     Let the given dictionary be following
    forword indictionary:
        fori inrange(n):
            forj inrange(m):
                ifdfs(board, word, i, j, n, m, 0):
                    store.add(word)
    forword instore:
        print(word)

boggle =[['G', 'I', 'Z'],
          ['U', 'E', 'K'],
          ['Q', 'S', 'E']]
dictionary =[""GEEKS"", ""FOR"", ""QUIZ"", ""GO""]
print(""Following words of dictionary are present:"")
wordBoggle(boggle, dictionary)

# This code is contributed by vikramshirsath177
",O(N*W + R*C^2),O(N*W + R*C)
"# Python3 Program to print BFS traversal
# from a given source vertex. BFS(int s)
# traverses vertices reachable from s.

fromcollections importdefaultdict


# This class represents a directed graph
# using adjacency list representation
classGraph:

    # Constructor
    def__init__(self):

        # Default dictionary to store graph
        self.graph =defaultdict(list)

    # Function to add an edge to graph
    defaddEdge(self, u, v):
        self.graph[u].append(v)

    # Function to print a BFS of graph
    defBFS(self, s):

        # Mark all the vertices as not visited
        visited =[False] *(max(self.graph) +1)

        # Create a queue for BFS
        queue =[]

        # Mark the source node as
        # visited and enqueue it
        queue.append(s)
        visited[s] =True

        whilequeue:

            # Dequeue a vertex from
            # queue and print it
            s =queue.pop(0)
            print(s, end="" "")

            # Get all adjacent vertices of the
            # dequeued vertex s.
            # If an adjacent has not been visited,
            # then mark it visited and enqueue it
            fori inself.graph[s]:
                ifvisited[i] ==False:
                    queue.append(i)
                    visited[i] =True


# Driver code
if__name__ =='__main__':

    # Create a graph given in
    # the above diagram
    g =Graph()
    g.addEdge(0, 1)
    g.addEdge(0, 2)
    g.addEdge(1, 2)
    g.addEdge(2, 0)
    g.addEdge(2, 3)
    g.addEdge(3, 3)

    print(""Following is Breadth First Traversal""
          "" (starting from vertex 2)"")
    g.BFS(2)

# This code is contributed by Neelam Yadav
",O(V+E),O(V)
"#  A C++ program to implement Cartesian Tree sort
#  Note that in this program we will build a min-heap
#  Cartesian Tree and not max-heap.
importqueue

''' A binary tree node has data, pointer to left child
   and a pointer to right child '''
classNode:
    def__init__(self, data):
        self.data =data
        self.left =None
        self.right =None

# This function sorts by pushing and popping the
# Cartesian Tree nodes in a pre-order like fashion
defpQBasedTraversal(root):
    # We will use a priority queue to sort the
    # partially-sorted data efficiently.
    # Unlike Heap, Cartesian tree makes use of
    # the fact that the data is partially sorted
    pQueue =queue.PriorityQueue()
    pQueue.put((root.data, root))
    
    # Resembles a pre-order traverse as first data
    # is printed then the left and then right child.
    whilenotpQueue.empty():
        popped_pair =pQueue.get()
        print(popped_pair[0], end=' ')

        ifpopped_pair[1].left isnotNone:
            pQueue.put((popped_pair[1].left.data, popped_pair[1].left))

        ifpopped_pair[1].right isnotNone:
            pQueue.put((popped_pair[1].right.data, popped_pair[1].right))

defbuildCartesianTreeUtil(root, arr, parent, leftchild, rightchild):
    ifroot ==-1:
        returnNone

    temp =Node(arr[root])
    temp.left =buildCartesianTreeUtil(leftchild[root], arr, parent, leftchild, rightchild)
    temp.right =buildCartesianTreeUtil(rightchild[root], arr, parent, leftchild, rightchild)

    returntemp

# A function to create the Cartesian Tree in O(N) time
defbuildCartesianTree(arr, n):
    # Arrays to hold the index of parent, left-child,
    # right-child of each number in the input array
    # Initialize all array values as -1
    parent =[-1] *n
    leftchild =[-1] *n
    rightchild =[-1] *n

    
    ''' 'root' and 'last' stores the index of the root and the
     last processed of the Cartesian Tree.
     Initially we take root of the Cartesian Tree as the
     first element of the input array. This can change
     according to the algorithm '''
    root, last =0, 0
    
    
    # Starting from the second element of the input array
    # to the last on scan across the elements, adding them
    # one at a time.
    fori inrange(1, n):
        last =i-1
        rightchild[i] =-1
            
            
        # Scan upward from the node's parent up to
        # the root of the tree until a node is found
        # whose value is smaller than the current one
        # This is the same as Step 2 mentioned in the
        # algorithm
        whilearr[last] >=arr[i] andlast !=root:
            last =parent[last]

        # arr[i] is the smallest element yet; make it
        # new root
        ifarr[last] >=arr[i]:
            parent[root] =i
            leftchild[i] =root
            root =i
        
        
        # Just insert it
        elifrightchild[last] ==-1:
            rightchild[last] =i
            parent[i] =last
            leftchild[i] =-1
        
        # Reconfigure links
        else:
            parent[rightchild[last]] =i
            leftchild[i] =rightchild[last]
            rightchild[last] =i
            parent[i] =last
        
    # Since the root of the Cartesian Tree has no
    # parent, so we assign it -1
    parent[root] =-1

    returnbuildCartesianTreeUtil(root, arr, parent, leftchild, rightchild)


# Sorts an input array
defprintSortedArr(arr, n):
    # Build a cartesian tree
    root =buildCartesianTree(arr, n)
    print(""The sorted array is-"")
    
    # Do pr-order traversal and insert
    # in priority queue
    pQBasedTraversal(root)

# Driver code

    '''  Given input array- {5,10,40,30,28},
        it's corresponding unique Cartesian Tree
        is-

        5
          \
          10
            \
             28
            /
          30
         /
        40
    '''
arr =[5, 10, 40, 30, 28]
n =len(arr)

printSortedArr(arr, n)

# This code is contributed by Prince Kumar
",O(1),O(n)
"# A O(n) python program to construct cartesian tree
# from a given array

# Define a Node class for the binary tree
classNode:
    def__init__(self, data):
        self.data =data
        self.left =None
        self.right =None

# Function to print the inorder traversal of the tree
defprintInorder(node):
    ifnode isNone:
        return
    printInorder(node.left)
    print(node.data, end="" "")
    printInorder(node.right)

# Recursive function to construct the Cartesian tree
defbuildCartesianTreeUtil(root, arr, parent, leftchild, rightchild):
    # If the root index is -1, return None
    ifroot ==-1:
        returnNone
    # Create a new node with the root's data
    temp =Node(arr[root])
    # Recursively construct the left and right subtrees
    temp.left =buildCartesianTreeUtil(leftchild[root], arr, parent, leftchild, rightchild)
    temp.right =buildCartesianTreeUtil(rightchild[root], arr, parent, leftchild, rightchild)
    # Return the constructed node
    returntemp

# Function to construct the Cartesian tree
defbuildCartesianTree(arr):
    n =len(arr)
    # Initialize arrays for parent, left child, and right child
    parent =[-1]*n
    leftchild =[-1]*n
    rightchild =[-1]*n

    # Set the root of the tree to be the first element of the input array
    root =0
    last =None

    # Iterate through the input array, adding each element to the tree
    fori inrange(1, n):
        last =i-1
        rightchild[i] =-1
        # Scan upward from the element's parent until a node is found whose value is greater than the current one
        whilelast !=root andarr[last] <=arr[i]:
            last =parent[last]
        # If the element is the largest so far, make it the new root
        ifarr[last] <=arr[i]:
            parent[root] =i
            leftchild[i] =root
            root =i
        # If there is no right child for the last node, insert the element as the right child
        elifrightchild[last] ==-1:
            rightchild[last] =i
            parent[i] =last
            leftchild[i] =-1
        # Else, reconfigure the links to insert the element as the right child
        else:
            parent[rightchild[last]] =i
            leftchild[i] =rightchild[last]
            rightchild[last] =i
            parent[i] =last

    # Set the root of the tree to have no parent
    parent[root] =-1
    # Return the constructed tree
    returnbuildCartesianTreeUtil(root, arr, parent, leftchild, rightchild)

# Driver program to test above functions
if__name__ =='__main__':
    arr =[5, 10, 40, 30, 28]
    root =buildCartesianTree(arr)
    print('Inorder traversal of the constructed tree :')
    printInorder(root)
",O(NlogN),O(n)
"# Python3 program to check for
# balanced brackets.

# function to check if
# brackets are balanced


defareBracketsBalanced(expr):
    stack =[]

    # Traversing the Expression
    forchar inexpr:
        ifchar in[""("", ""{"", ""[""]:

            # Push the element in the stack
            stack.append(char)
        else:

            # IF current character is not opening
            # bracket, then it must be closing.
            # So stack cannot be empty at this point.
            ifnotstack:
                returnFalse
            current_char =stack.pop()
            ifcurrent_char =='(':
                ifchar !="")"":
                    returnFalse
            ifcurrent_char =='{':
                ifchar !=""}"":
                    returnFalse
            ifcurrent_char =='[':
                ifchar !=""]"":
                    returnFalse

    # Check Empty Stack
    ifstack:
        returnFalse
    returnTrue


# Driver Code
if__name__ ==""__main__"":
    expr =""{()}[]""

    # Function call
    ifareBracketsBalanced(expr):
        print(""Balanced"")
    else:
        print(""Not Balanced"")

# This code is contributed by AnkitRai01 and improved
# by Raju Pitta
",O(N),O(N)
"defare_brackets_balanced(s):
    stack =[]
    forch ins:
        ifch in('(', '{', '['):
            stack.append(ch)
        else:
            ifstack and((stack[-1] =='('andch ==')') or
                          (stack[-1] =='{'andch =='}') or
                          (stack[-1] =='['andch ==']')):
                stack.pop()
            else:
                returnFalse
    returnnotstack

expr =""{()}[]""

# Function call
ifare_brackets_balanced(expr):
    print(""Balanced"")
else:
    print(""Not Balanced"")
",O(N),O(1)
"# Python3 program to Check if a given array contains duplicate
# elements within k distance from each other
defcheckDuplicatesWithinK(arr,  n,  k):

    # traversing the input array
    fori inrange(n):
        j =i +1
        range_ =k
        
        # searching in next k-1 elements if its duplicate
        # is present or not
        while(range_ > 0andj < n):
            if(arr[i] ==arr[j]):
                returnTrue
            j +=1
            range_ -=1

    returnFalse


# Driver method to test above method

arr =[10, 5, 3, 4, 3, 5, 6]
n =len(arr)
if(checkDuplicatesWithinK(arr, n, 3) ==True):
    print(""Yes"")
else:
    print(""No"")


# This article is contributed by Abhijeet Kumar(abhijeet19403)
",O(N*K),O(1)
"# A Python3 program to check if
# four given points form a square or not.
classPoint:
    
    # Structure of a point in 2D space
    def__init__(self, x, y):
        self.x =x
        self.y =y

# A utility function to find square of 
# distance from point 'p' to point 'q'
defdistSq(p, q):
    return(p.x -q.x) *(p.x -q.x) +\
           (p.y -q.y) *(p.y -q.y)

# This function returns true if (p1, p2, p3, p4) 
# form a square, otherwise false
defisSquare(p1, p2, p3, p4):

    d2 =distSq(p1, p2) # from p1 to p2
    d3 =distSq(p1, p3) # from p1 to p3
    d4 =distSq(p1, p4) # from p1 to p4

    ifd2 ==0ord3 ==0ord4 ==0:    
        returnFalse

    # If lengths if (p1, p2) and (p1, p3) are same, then
    # following conditions must be met to form a square.
    # 1) Square of length of (p1, p4) is same as twice
    # the square of (p1, p2)
    # 2) Square of length of (p2, p3) is same
    # as twice the square of (p2, p4)

    ifd2 ==d3 and2*d2 ==d4 and\
                    2*distSq(p2, p4) ==distSq(p2, p3):
        returnTrue

    # The below two cases are similar to above case
    ifd3 ==d4 and2*d3 ==d2 and\
                    2*distSq(p3, p2) ==distSq(p3, p4):
        returnTrue

    ifd2 ==d4 and2*d2 ==d3 and\
                    2*distSq(p2, p3) ==distSq(p2, p4):
        returnTrue

    returnFalse

# Driver Code
if__name__==""__main__"":
    p1 =Point(20, 10)
    p2 =Point(10, 20)
    p3 =Point(20, 20)
    p4 =Point(10, 10)
    
    ifisSquare(p1, p2, p3, p4):
        print('Yes') 
    else:
        print('No')

# This code is contributed by Mayank Chaudhary
# aka chaudhary_19
",O(1),O(1)
"# Python program to check binary tree is a subtree of
# another tree

# A binary tree node


classNode:

    # Constructor to create a new node
    def__init__(self, data):
        self.data =data
        self.left =None
        self.right =None

# A utility function to check whether trees with roots
# as root 1 and root2 are indetical or not


defareIdentical(root1, root2):

    # Base Case
    ifroot1 isNoneandroot2 isNone:
        returnTrue
    ifroot1 isNoneorroot2 isNone:
        returnFalse

    # Check fi the data of both roots is same and data of
    # left and right subtrees are also same
    return(root1.data ==root2.data and
            areIdentical(root1.left, root2.left)and
            areIdentical(root1.right, root2.right)
            )

# This function returns True if S is a subtree of T,
# otherwise False


defisSubtree(T, S):

    # Base Case
    ifS isNone:
        returnTrue

    ifT isNone:
        returnFalse

    # Check the tree with root as current node
    if(areIdentical(T, S)):
        returnTrue

    # IF the tree with root as current node doesn't match
    # then try left and right subtree one by one
    returnisSubtree(T.left, S) orisSubtree(T.right, S)


# Driver program to test above function

"""""" TREE 1
     Construct the following tree
              26
            /   \
          10     3
        /    \     \
      4      6      3
       \
        30
    """"""

T =Node(26)
T.right =Node(3)
T.right.right =Node(3)
T.left =Node(10)
T.left.left =Node(4)
T.left.left.right =Node(30)
T.left.right =Node(6)

"""""" TREE 2
     Construct the following tree
          10
        /    \
      4      6
       \
        30
    """"""
S =Node(10)
S.right =Node(6)
S.left =Node(4)
S.left.right =Node(30)

ifisSubtree(T, S):
    print(""Tree 2 is subtree of Tree 1"")
else:
    print(""Tree 2 is not a subtree of Tree 1"")

# This code is contributed by Nikhil Kumar Singh(nickzuck_007)
",O(M*N),O(n)
"# This python program tells if there exists a pair in array whose sum results in x.

# Function to find and print pair


defchkPair(A, size, x):
    fori inrange(0, size -1):
        forj inrange(i +1, size):
            if(A[i] +A[j] ==x):
                return1
    return0


if__name__ ==""__main__"":
    A =[0, -1, 2, -3, 1]
    x =-2
    size =len(A)

    if(chkPair(A, size, x)):
        print(""Yes"")

    else:
        print(""No"")

    # This code is contributed by rakeshsahni
",O(N2),O(1)
"# Python program to find if there are
# two elements with given sum

# function to check for the given sum
# in the array


defprintPairs(arr, arr_size, sum):

    # Create an empty hash map
    # using an hashmap allows us to store the indices
    hashmap ={}

    fori inrange(0, arr_size):
        temp =sum-arr[i]
        if(temp inhashmap):
            print('Yes')
            return
        hashmap[arr[i]] =i
    print(""No"")


# driver code
A =[1, 4, 45, 6, 10, 8]
n =16
printPairs(A, len(A), n)

# This code will also work in case the array has the same number twice
# and target is the sum of those numbers
# Eg: Array = [4,6,4] Target = 8

# This code is contributed by __Achyut Upadhyay__
",O(NlogN),O(1)
"# Python program to find if there are
# two elements with given sum

# function to check for the given sum
# in the array


defprintPairs(arr, arr_size, sum):

    # Create an empty hash map
    # using an hashmap allows us to store the indices
    hashmap ={}

    fori inrange(0, arr_size):
        temp =sum-arr[i]
        if(temp inhashmap):
            print('Yes')
            return
        hashmap[arr[i]] =i
    print(""No"")


# driver code
A =[1, 4, 45, 6, 10, 8]
n =16
printPairs(A, len(A), n)

# This code will also work in case the array has the same number twice
# and target is the sum of those numbers
# Eg: Array = [4,6,4] Target = 8

# This code is contributed by __Achyut Upadhyay__
",O(NlogN),O(1)
"# Python program to find if there are
# two elements with given sum

# function to check for the given sum
# in the array


defprintPairs(arr, arr_size, sum):

    # Create an empty hash map
    # using an hashmap allows us to store the indices
    hashmap ={}

    fori inrange(0, arr_size):
        temp =sum-arr[i]
        if(temp inhashmap):
            print('Yes')
            return
        hashmap[arr[i]] =i
    print(""No"")


# driver code
A =[1, 4, 45, 6, 10, 8]
n =16
printPairs(A, len(A), n)

# This code will also work in case the array has the same number twice
# and target is the sum of those numbers
# Eg: Array = [4,6,4] Target = 8

# This code is contributed by __Achyut Upadhyay__
",O(N),O(N)
"# Code in Python3 to tell if there
# exists a pair in array whose
# sum results in x.

# Function to print pairs


defprintPairs(a, n, x):

    rem =[]

    fori inrange(x):

        # Initializing the rem
        # values with 0's.
        rem.append(0)

    fori inrange(n):
        if(a[i] < x):

            # Perform the remainder operation
            # only if the element is x, as
            # numbers greater than x can't
            # be used to get a sum x.Updating
            # the count of remainders.
            rem[a[i] %x] +=1

    # Traversing the remainder list from
    # start to middle to find pairs
    fori inrange(1, x //2):
        if(rem[i] > 0andrem[x -i] > 0):

            # The elements with remainders
            # i and x-i will result to a
            # sum of x. Once we get two
            # elements which add up to x,
            # we print x and break.
            print(""Yes"")
            break

    # Once we reach middle of
    # remainder array, we have to
    # do operations based on x.
    if(i >=x //2):
        if(x %2==0):
            if(rem[x //2] > 1):

                # If x is even and we have more
                # than 1 elements with remainder
                # x/2, then we will have two
                # distinct elements which add up
                # to x. if we dont have than 1
                # element, print ""No"".
                print(""Yes"")
            else:
                print(""No"")
        else:

            # When x is odd we continue
            # the same process which we
            # did in previous loop.
            if(rem[x //2] > 0and
                    rem[x -x //2] > 0):
                print(""Yes"")
            else:
                print(""No"")


# Driver Code
A =[1, 4, 45, 6, 10, 8]
n =16
arr_size =len(A)

# Function calling
printPairs(A, arr_size, n)

# This code is contributed by subhammahato348
",O(N+X),O(X)
"# A Python3 program to find if 2 given line segments intersect or not 
 
classPoint: 
    def__init__(self, x, y): 
        self.x =x 
        self.y =y 
 
# Given three collinear points p, q, r, the function checks if  
# point q lies on line segment 'pr'  
defonSegment(p, q, r): 
    if( (q.x <=max(p.x, r.x)) and(q.x >=min(p.x, r.x)) and
           (q.y <=max(p.y, r.y)) and(q.y >=min(p.y, r.y))): 
        returnTrue
    returnFalse
 
deforientation(p, q, r): 
    # to find the orientation of an ordered triplet (p,q,r) 
    # function returns the following values: 
    # 0 : Collinear points 
    # 1 : Clockwise points 
    # 2 : Counterclockwise 
     
    # See https://www.geeksforgeeks.org/orientation-3-ordered-points/amp/  
    # for details of below formula.  
     
    val =(float(q.y -p.y) *(r.x -q.x)) -(float(q.x -p.x) *(r.y -q.y)) 
    if(val > 0): 
         
        # Clockwise orientation 
        return1
    elif(val < 0): 
         
        # Counterclockwise orientation 
        return2
    else: 
         
        # Collinear orientation 
        return0
 
# The main function that returns true if  
# the line segment 'p1q1' and 'p2q2' intersect. 
defdoIntersect(p1,q1,p2,q2): 
     
    # Find the 4 orientations required for  
    # the general and special cases 
    o1 =orientation(p1, q1, p2) 
    o2 =orientation(p1, q1, q2) 
    o3 =orientation(p2, q2, p1) 
    o4 =orientation(p2, q2, q1) 
 
    # General case 
    if((o1 !=o2) and(o3 !=o4)): 
        returnTrue
 
    # Special Cases 
 
    # p1 , q1 and p2 are collinear and p2 lies on segment p1q1 
    if((o1 ==0) andonSegment(p1, p2, q1)): 
        returnTrue
 
    # p1 , q1 and q2 are collinear and q2 lies on segment p1q1 
    if((o2 ==0) andonSegment(p1, q2, q1)): 
        returnTrue
 
    # p2 , q2 and p1 are collinear and p1 lies on segment p2q2 
    if((o3 ==0) andonSegment(p2, p1, q2)): 
        returnTrue
 
    # p2 , q2 and q1 are collinear and q1 lies on segment p2q2 
    if((o4 ==0) andonSegment(p2, q1, q2)): 
        returnTrue
 
    # If none of the cases 
    returnFalse
 
# Driver program to test above functions: 
p1 =Point(1, 1) 
q1 =Point(10, 1) 
p2 =Point(1, 2) 
q2 =Point(10, 2) 
 
ifdoIntersect(p1, q1, p2, q2): 
    print(""Yes"") 
else: 
    print(""No"") 
 
p1 =Point(10, 0) 
q1 =Point(0, 10) 
p2 =Point(0, 0) 
q2 =Point(10,10) 
 
ifdoIntersect(p1, q1, p2, q2): 
    print(""Yes"") 
else: 
    print(""No"") 
 
p1 =Point(-5,-5) 
q1 =Point(0, 0) 
p2 =Point(1, 1) 
q2 =Point(10, 10) 
 
ifdoIntersect(p1, q1, p2, q2): 
    print(""Yes"") 
else: 
    print(""No"") 
     
# This code is contributed by Ansh Riyal 
",O(1),O(1)
"# Class Node, similar to the linked list 
classNode: 
    def__init__(self,data): 
        self.data =data 
        self.next=None
",O(N),O(1)
"# Python program to delete a given key from linked list 
classNode: 
    def__init__(self, data): 
        self.data =data 
        self.next=None
 
# Function to insert a node at the 
# beginning of a Circular linked list 
 
 
defpush(head, data): 
    # Create a new node and make head as next of it. 
    newP =Node(data) 
    newP.next=head 
 
    # If linked list is not NULL then 
    # set the next of last node 
    ifhead !=None: 
        # Find the node before head and 
        # update next of it. 
        temp =head 
        while(temp.next!=head): 
            temp =temp.next
        temp.next=newP 
    else: 
        newP.next=newP 
    head =newP 
    returnhead 
 
# Function to print nodes in a given circular linked list 
 
 
defprintList(head): 
    ifhead ==None: 
        print(""List is Empty"") 
        return
    temp =head.next
    print(head.data, end=' ') 
    if(head !=None): 
        while(temp !=head): 
            print(temp.data, end="" "") 
            temp =temp.next
    print() 
 
# Function to delete a given node 
# from the list 
 
 
defdeleteNode(head, key): 
    # If linked list is empty 
    if(head ==None): 
        return
 
    # If the list contains only a 
    # single node 
    if(head.data ==key andhead.next==head): 
        head =None
        return
 
    last =head 
 
    # If head is to be deleted 
    if(head.data ==key): 
        # Find the last node of the list 
        while(last.next!=head): 
            last =last.next
 
        # Point last node to the next of 
        # head i.e. the second node 
        # of the list 
        last.next=head.next
        head =last.next
        return
 
    # Either the node to be deleted is 
    # not found or the end of list 
    # is not reached 
    while(last.next!=head andlast.next.data !=key): 
        last =last.next
 
    # If node to be deleted was found 
    if(last.next.data ==key): 
        d =last.next
        last.next=d.next
        d =None
    else: 
        print(""Given node is not found in the list!!!"") 
 
 
# Driver code 
# Initialize lists as empty 
head =None
 
# Created linked list will be 
# 2->5->7->8->10 
head =push(head, 2) 
head =push(head, 5) 
head =push(head, 7) 
head =push(head, 8) 
head =push(head, 10) 
 
print(""List Before Deletion: "") 
printList(head) 
 
deleteNode(head, 7) 
print(""List After Deletion: "") 
printList(head) 
",O(N),O(1)
"# Python3 program for the above operation 
defaddToEmpty(self, data): 
 
        if(self.last !=None): 
            returnself.last 
 
        # Creating the newnode temp 
        temp =Node(data) 
        self.last =temp 
 
        # Creating the link 
        self.last.next=self.last 
        returnself.last 
  # this code is contributed by shivanisinghss2110 
",O(1),O(1)
"# Python3 program for the above operation 
 
defaddBegin(self, data): 
 
    if(self.last ==None): 
        returnself.addToEmpty(data) 
 
    temp =Node(data) 
    temp.next=self.last.next
    self.last.next=temp 
 
    returnself.last 
  # this code is contributed by shivanisinghss2110 
",O(1),O(1)
"# Python3 program for the above operation 
 
defaddEnd(self, data): 
 
    if(self.last ==None): 
        returnself.addToEmpty(data) 
 # Assigning the data. 
    temp =Node(data) 
 
  # Adjusting the links. 
    temp.next=self.last.next
    self.last.next=temp 
    self.last =temp 
 
    returnself.last 
 
   # This code is contributed by shivanisinghss2110 
",O(1),O(1)
"# Python3 program for the above operation 
 
defaddAfter(self, data, item): 
 
    if(self.last ==None): 
        returnNone
 
    temp =Node(data) 
    p =self.last.next
    whilep: 
        if(p.data ==item): 
            temp.next=p.next
            p.next=temp 
 
            if(p ==self.last): 
                self.last =temp 
                returnself.last 
            else: 
                returnself.last 
        p =p.next
        if(p ==self.last.next): 
            print(item, ""not present in the list"") 
            break
 
# This code is contributed by shivanisinghss2110 
",O(N),O(1)
"# Python3 program for the above methods 
 
 
classNode: 
    def__init__(self, data): 
        self.data =data 
        self.next=0
 
 
classCircularLinkedList: 
    def__init__(self): 
        self.last =None
 
    # This function is only for empty list 
    defaddToEmpty(self, data): 
        if(self.last !=None): 
            returnself.last 
        # Creating the newnode temp 
        temp =Node(data) 
        self.last =temp 
        # Creating the link 
        self.last.next=self.last 
        returnself.last 
 
    defaddBegin(self, data): 
        if(self.last ==None): 
            returnself.addToEmpty(data) 
        temp =Node(data) 
        temp.next=self.last.next
        self.last.next=temp 
        returnself.last 
 
    defaddEnd(self, data): 
        if(self.last ==None): 
            returnself.addToEmpty(data) 
        temp =Node(data) 
        temp.next=self.last.next
        self.last.next=temp 
        self.last =temp 
        returnself.last 
 
    defaddAfter(self, data, item): 
 
        if(self.last ==None): 
            returnNone
 
        temp =Node(data) 
        p =self.last.next
        whilep: 
            if(p.data ==item): 
                temp.next=p.next
                p.next=temp 
 
                if(p ==self.last): 
                    self.last =temp 
                    returnself.last 
                else: 
                    returnself.last 
            p =p.next
            if(p ==self.last.next): 
                print(item, ""not present in the list"") 
                break
 
    deftraverse(self): 
        if(self.last ==None): 
            print(""List is empty"") 
            return
        temp =self.last.next
        whiletemp: 
            print(temp.data, end="" "") 
            temp =temp.next
            iftemp ==self.last.next: 
                break
 
 
# Driver Code 
if__name__ =='__main__': 
    llist =CircularLinkedList() 
    last =llist.addToEmpty(6) 
    last =llist.addBegin(4) 
    last =llist.addBegin(2) 
    last =llist.addEnd(8) 
    last =llist.addEnd(12) 
    last =llist.addAfter(10, 8) 
    llist.traverse() 
# This code is contributed by 
# Aditya Singh 
",O(N),O(1)
"# A hashmap based Python program to clone a binary
# tree with random pointers

classNode:
    def__init__(self, key):
        self.key =key
        self.left =None
        self.right =None
        self.random =None

# Helper function that allocates a new Node with the
# given data and None left, right and random pointers.
defnew_node(key):
    temp =Node(key)
    returntemp

# Given a binary tree, print its Nodes in inorder
defprint_inorder(node):
    ifnode ==None:
        return
    # First recur on left subtree
    print_inorder(node.left)
    # then print data of Node and its random
    print(""["", node.key, end="", "")
    ifnode.random ==None:
        print(""None], "", end="""")
    else:
        print(node.random.key, ""], "", end="""")
    # now recur on right subtree
    print_inorder(node.right)

# This function creates clone by copying key
# and left and right pointers. This function also
# stores mapping from given tree node to clone.
defcopy_left_right_node(tree_node, mymap):
    iftree_node ==None:
        returnNone
    clone_node =new_node(tree_node.key)
    mymap[tree_node] =clone_node
    clone_node.left =copy_left_right_node(tree_node.left, mymap)
    clone_node.right =copy_left_right_node(tree_node.right, mymap)
    returnclone_node

# This function copies random node by using the hashmap built by
# copy_left_right_node()
defcopy_random(tree_node, mymap):
    iftree_node isNone:
        return
    iftree_node.random isnotNone:
        mymap[tree_node].random =mymap[tree_node.random]
    copy_random(tree_node.left, mymap)
    copy_random(tree_node.right, mymap)

# This function makes the clone of given tree. It mainly uses
# copy_left_right_node() and copy_random()
defclone_tree(tree):
    iftree ==None:
        returnNone
    mymap ={}
    new_tree =copy_left_right_node(tree, mymap)
    copy_random(tree, mymap)
    returnnew_tree

# Driver code
if__name__ ==""__main__"":
    # Test Case 1
    tree =Node(1)
    tree.left =Node(2)
    tree.right =Node(3)
    tree.left.left =Node(4)
    tree.left.right =Node(5)
    tree.random =tree.left.right
    tree.left.left.random =tree
    tree.left.right.random =tree.right

    # Test Case 2
    # tree = None

    # Test Case 3
    # tree = newNode(1)

    # Test Case 4
    """"""
    tree = newNode(1)
    tree.left = newNode(2)
    tree.right = newNode(3)
    tree.random = tree.right
    tree.left.random = tree
    """"""

    print(""Inorder traversal of original binary tree is:"")
    print_inorder(tree)

    clone =clone_tree(tree)

    print(""\n\nInorder traversal of cloned binary tree is:"")
    print_inorder(clone)
",O(n),O(n)
"# Python Equivalent
importmath

# A structure to represent a Point in 2D plane
classPoint:
    def__init__(self, x, y):
        self.x =x
        self.y =y

# Needed to sort array of points according to X coordinate
defcompareX(a, b):
    p1,  p2 =a, b
    return(p1.x !=p2.x) *(p1.x -p2.x) +(p1.y -p2.y)

# Needed to sort array of points according to Y coordinate
defcompareY(a, b):
    p1,  p2 =a, b
    return(p1.y !=p2.y) *(p1.y -p2.y) +(p1.x -p2.x)

# A utility function to find the distance between two points
defdist(p1, p2):
    returnmath.sqrt((p1.x -p2.x)**2+(p1.y -p2.y)**2)

# A Brute Force method to return the smallest distance between two points
# in P[] of size n
defbruteForce(P, n):
    min=float('inf')
    fori inrange(n):
        forj inrange(i+1, n):
            ifdist(P[i], P[j]) < min:
                min=dist(P[i], P[j])
    returnmin

# A utility function to find a minimum of two float values
defmin(x, y):
    returnx ifx < y elsey

# A utility function to find the distance between the closest points of
# strip of a given size. All points in strip[] are sorted according to
# y coordinate. They all have an upper bound on minimum distance as d.
# Note that this method seems to be a O(n^2) method, but it's a O(n)
# method as the inner loop runs at most 6 times
defstripClosest(strip, size, d):
    min=d  # Initialize the minimum distance as d

    # Pick all points one by one and try the next points till the difference
    # between y coordinates is smaller than d.
    # This is a proven fact that this loop runs at most 6 times
    fori inrange(size):
        forj inrange(i+1, size):
            if(strip[j].y -strip[i].y) < min:
                ifdist(strip[i],strip[j]) < min:
                    min=dist(strip[i], strip[j])

    returnmin

# A recursive function to find the smallest distance. The array Px contains
# all points sorted according to x coordinates and Py contains all points
# sorted according to y coordinates
defclosestUtil(Px, Py, n):
    # If there are 2 or 3 points, then use brute force
    ifn <=3:
        returnbruteForce(Px, n)

    # Find the middle point
    mid =n //2
    midPoint =Px[mid]


    # Divide points in y sorted array around the vertical line.
    # Assumption: All x coordinates are distinct.
    Pyl =[None] *mid   # y sorted points on left of vertical line
    Pyr =[None] *(n-mid)  # y sorted points on right of vertical line
    li =ri =0# indexes of left and right subarrays
    fori inrange(n):
        if((Py[i].x < midPoint.x or(Py[i].x ==midPoint.x andPy[i].y < midPoint.y)) andli<mid):
            Pyl[li] =Py[i]
            li +=1
        else:
            Pyr[ri] =Py[i]
            ri +=1

    # Consider the vertical line passing through the middle point
    # calculate the smallest distance dl on left of middle point and
    # dr on right side
    dl =closestUtil(Px, Pyl, mid)
    dr =closestUtil(Px[mid:], Pyr, n-mid)

    # Find the smaller of two distances
    d =min(dl, dr)

    # Build an array strip[] that contains points close (closer than d)
    # to the line passing through the middle point
    strip =[None] *n
    j =0
    fori inrange(n):
        ifabs(Py[i].x -midPoint.x) < d:
            strip[j] =Py[i]
            j +=1

    # Find the closest points in strip.  Return the minimum of d and closest
    # distance is strip[]
    returnstripClosest(strip, j, d)

# The main function that finds the smallest distance
# This method mainly uses closestUtil()
defclosest(P, n):
    Px =P
    Py =P
    Px.sort(key=lambdax:x.x)
    Py.sort(key=lambdax:x.y)

    # Use recursive function closestUtil() to find the smallest distance
    returnclosestUtil(Px, Py, n)

# Driver program to test above functions
if__name__ =='__main__':
    P =[Point(2, 3), Point(12, 30), Point(40, 50), Point(5, 1), Point(12, 10), Point(3, 4)]
    n =len(P)
    print(""The smallest distance is"", closest(P, n))
",T(nLogn),O(log n)
"importmath


classPoint:
    def__init__(self, x, y):
        self.x =x
        self.y =y


defcompareX(a, b):
    p1 =a
    p2 =b
    return(p1.x -p2.x)


defcompareY(a, b):
    p1 =a
    p2 =b
    return(p1.y -p2.y)


defdist(p1, p2):
    returnmath.sqrt((p1.x -p2.x)*(p1.x -p2.x) +(p1.y -p2.y)*(p1.y -p2.y))


defbruteForce(P, n):
    min_dist =float(""inf"")
    fori inrange(n):
        forj inrange(i+1, n):
            ifdist(P[i], P[j]) < min_dist:
                min_dist =dist(P[i], P[j])
    returnmin_dist


defmin(x, y):
    returnx ifx < y elsey


defstripClosest(strip, size, d):
    min_dist =d
    strip =sorted(strip, key=lambdapoint: point.y)

    fori inrange(size):
        forj inrange(i+1, size):
            if(strip[j].y -strip[i].y) >=min_dist:
                break
            ifdist(strip[i], strip[j]) < min_dist:
                min_dist =dist(strip[i], strip[j])
    returnmin_dist


defclosestUtil(P, n):
    ifn <=3:
        returnbruteForce(P, n)
    mid =n//2
    midPoint =P[mid]
    dl =closestUtil(P, mid)
    dr =closestUtil(P[mid:], n -mid)
    d =min(dl, dr)
    strip =[]
    fori inrange(n):
        ifabs(P[i].x -midPoint.x) < d:
            strip.append(P[i])
    returnmin(d, stripClosest(strip, len(strip), d))


defclosest(P, n):
    P =sorted(P, key=lambdapoint: point.x)
    returnclosestUtil(P, n)


if__name__ ==""__main__"":
    P =[Point(x=2, y=3), Point(x=12, y=30),
         Point(x=40, y=50), Point(x=5, y=1), Point(x=12, y=10), Point(x=3, y=4)]
    n =len(P)
    print(""The smallest distance is"", closest(P, n))
",T(n x Logn x Logn),O(log n)
"# Recursive Python3 program for
# coin change problem.

# Returns the count of ways we can sum
# coins[0...n-1] coins to get sum ""sum""


defcount(coins, n, sum):

    # If sum is 0 then there is 1
    # solution (do not include any coin)
    if(sum==0):
        return1

    # If sum is less than 0 then no
    # solution exists
    if(sum< 0):
        return0

    # If there are no coins and sum
    # is greater than 0, then no
    # solution exist
    if(n <=0):
        return0

    # count is sum of solutions (i)
    # including coins[n-1] (ii) excluding coins[n-1]
    returncount(coins, n -1, sum) +count(coins, n, sum-coins[n-1])


# Driver program to test above function
coins =[1, 2, 3]
n =len(coins)
print(count(coins, n, 5))

# This code is contributed by Smitha Dinesh Semwal
",O(2sum),O(sum)
"# Python program for the above approach

# Recursive function to count the numeber of distinct ways
# to make the sum by using n coins


defcount(coins, sum, n, dp):
  # Base Case
    if(sum==0):
        dp[n][sum] =1
        returndp[n][sum]

     # If number of coins is 0 or sum is less than 0 then there is no way to make the sum.
    if(n ==0orsum< 0):
        return0

     # If the subproblem is previously calculated then simply return the result
    if(dp[n][sum] !=-1):
        returndp[n][sum]

      # Two options for the current coin

    dp[n][sum] =count(coins, sum-coins[n -1], n, dp) +\
        count(coins, sum, n -1, dp)

    returndp[n][sum]


# Driver code
if__name__ =='__main__':
    tc =1
    while(tc !=0):
        n =3
        sum=5
        coins =[1, 2, 3]
        dp =[[-1fori inrange(sum+1)] forj inrange(n+1)]
        res =count(coins, sum, n, dp)
        print(res)
        tc -=1
",O(N*sum),O(N*sum)
"# Function to calculate the total distinct ways to make a sum using n coins of different denominations
defcount(coins, n, target_sum):
    # 2D dp array where n is the number of coin denominations and target_sum is the target sum
    dp =[[0forj inrange(target_sum +1)] fori inrange(n +1)]

    # Represents the base case where the target sum is 0, and there is only one way to make change: by not selecting any coin
    dp[0][0] =1
    fori inrange(1, n +1):
        forj inrange(target_sum +1):
            # Add the number of ways to make change without using the current coin
            dp[i][j] +=dp[i -1][j]

            ifj -coins[i -1] >=0:
                # Add the number of ways to make change using the current coin
                dp[i][j] +=dp[i][j -coins[i -1]]

    returndp[n][target_sum]

# Driver Code
if__name__ ==""__main__"":
    coins =[1, 2, 3]
    n =3
    target_sum =5
    print(count(coins, n, target_sum))
",O(N*sum),O(N*sum)
"# Iterative program to connect all the adjacent nodes at the same level in a binary tree
classnewnode:
    def__init__(self, data):
        self.data =data
        self.left =self.right =self.nextRight =None

#   setting right pointer to next right node

#              10 ----------> NULL
#             /  \
#           8 --->2 --------> NULL
#          /
#         3 ----------------> NULL


defconnect(root):

    # Base condition
    ifroot isNone:
        return

    # Create an empty queue like level order traversal
    queue =[]
    queue.append(root)
    whilelen(queue) !=0:

        # size indicates no. of nodes at current level
        size =len(queue)

        # for keeping track of previous node
        prev =newnode(None)
        fori inrange(size):
            temp =queue.pop(0)
            iftemp.left:
                queue.append(temp.left)
            iftemp.right:
                queue.append(temp.right)
            ifprev !=None:
                prev.nextRight =temp
                prev =temp
        prev.nextRight =None


# Driver Code
if__name__ =='__main__':

    # Constructed binary tree is
    # 10
    #     / \
    # 8     2
    # /
    # 3
    root =newnode(10)
    root.left =newnode(8)
    root.right =newnode(2)
    root.left.left =newnode(3)

    # Populates nextRight pointer in all nodes
    connect(root)

    # Let us check the values of nextRight pointers
    print(""Following are populated nextRight"",
          ""pointers in the tree (-1 is printed"",
          ""if there is no nextRight)"")
    print(""nextRight of"", root.data, ""is "", end="""")
    ifroot.nextRight:
        print(root.nextRight.data)
    else:
        print(-1)
    print(""nextRight of"", root.left.data, ""is "", end="""")
    ifroot.left.nextRight:
        print(root.left.nextRight.data)
    else:
        print(-1)
    print(""nextRight of"", root.right.data, ""is "", end="""")
    ifroot.right.nextRight:
        print(root.right.nextRight.data)
    else:
        print(-1)
    print(""nextRight of"", root.left.left.data, ""is "", end="""")
    ifroot.left.left.nextRight:
        print(root.left.left.nextRight.data)
    else:
        print(-1)

# This code is contributed by Vivek Maddeshiya
",O(N),O(N)
"# Python3 program to connect nodes at same
# level using extended pre-order traversal


classnewnode:
    def__init__(self, data):
        self.data =data
        self.left =self.right =self.nextRight =None

# Sets the nextRight of root and calls
# connectRecur() for other nodes


defconnect(p):

    # Set the nextRight for root
    p.nextRight =None

    # Set the next right for rest of
    # the nodes (other than root)
    connectRecur(p)

# Set next right of all descendants of p.
# Assumption: p is a complete binary tree


defconnectRecur(p):

    # Base case
    if(notp):
        return

    # Set the nextRight pointer for p's
    # left child
    if(p.left):
        p.left.nextRight =p.right

    # Set the nextRight pointer for p's right
    # child p.nextRight will be None if p is
    # the right most child at its level
    if(p.right):
        ifp.nextRight:
            p.right.nextRight =p.nextRight.left
        else:
            p.right.nextRight =None

    # Set nextRight for other nodes in
    # pre order fashion
    connectRecur(p.left)
    connectRecur(p.right)


# Driver Code
if__name__ =='__main__':

    # Constructed binary tree is
    # 10
    #     / \
    # 8     2
    # /
    # 3
    root =newnode(10)
    root.left =newnode(8)
    root.right =newnode(2)
    root.left.left =newnode(3)

    # Populates nextRight pointer in all nodes
    connect(root)

    # Let us check the values of nextRight pointers
    print(""Following are populated nextRight"",
          ""pointers in the tree (-1 is printed"",
          ""if there is no nextRight)"")
    print(""nextRight of"", root.data, ""is "", end="""")
    ifroot.nextRight:
        print(root.nextRight.data)
    else:
        print(-1)
    print(""nextRight of"", root.left.data, ""is "", end="""")
    ifroot.left.nextRight:
        print(root.left.nextRight.data)
    else:
        print(-1)
    print(""nextRight of"", root.right.data, ""is "", end="""")
    ifroot.right.nextRight:
        print(root.right.nextRight.data)
    else:
        print(-1)
    print(""nextRight of"", root.left.left.data, ""is "", end="""")
    ifroot.left.left.nextRight:
        print(root.left.left.nextRight.data)
    else:
        print(-1)

# This code is contributed by PranchalK
",O(N),O(N)
"# Python program to construct tree using inorder and 
# preorder traversals

# A binary tree node 
classNode:
    
    # Constructor to create a new node
    def__init__(self, data):
        self.data =data
        self.left =None
        self.right =None

""""""Recursive function to construct binary of size len from
   Inorder traversal in[] and Preorder traversal pre[].  Initial values
   of inStrt and inEnd should be 0 and len -1.  The function doesn't
   do any error checking for cases where inorder and preorder
   do not form a tree """"""
defbuildTree(inOrder, preOrder, inStrt, inEnd):
    
    if(inStrt > inEnd):
        returnNone

    # Pick current node from Preorder traversal using
    # preIndex and increment preIndex
    tNode =Node(preOrder[buildTree.preIndex])
    buildTree.preIndex +=1

    # If this node has no children then return
    ifinStrt ==inEnd :
        returntNode

    # Else find the index of this node in Inorder traversal
    inIndex =search(inOrder, inStrt, inEnd, tNode.data)
    
    # Using index in Inorder Traversal, construct left 
    # and right subtrees
    tNode.left =buildTree(inOrder, preOrder, inStrt, inIndex-1)
    tNode.right =buildTree(inOrder, preOrder, inIndex +1, inEnd)

    returntNode

# UTILITY FUNCTIONS
# Function to find index of value in arr[start...end]
# The function assumes that value is present in inOrder[]

defsearch(arr, start, end, value):
    fori inrange(start, end +1):
        ifarr[i] ==value:
            returni

defprintInorder(node):
    ifnode isNone:
        return
    
    # first recur on left child
    printInorder(node.left)
    
    # then print the data of node
    print(node.data,end=' ')

    # now recur on right child
    printInorder(node.right)
    
# Driver program to test above function
inOrder =['D', 'B', 'E', 'A', 'F', 'C']
preOrder =['A', 'B', 'D', 'E', 'C', 'F']
# Static variable preIndex
buildTree.preIndex =0
root =buildTree(inOrder, preOrder, 0, len(inOrder)-1)

# Let us test the build tree by printing Inorder traversal
print(""Inorder traversal of the constructed tree is"")
printInorder(root)

# This code is contributed by Nikhil Kumar Singh(nickzuck_007)
",O(n^2),O(n)
"# Python3 program to construct tree using inorder
# and preorder traversals 

# A binary tree node has data, pointer to left child
# and a pointer to right child 
classNode:
    
    def__init__(self, x):
        
        self.data =x
        self.left =None
        self.right =None

# Recursive function to construct binary of size
# len from Inorder traversal in[] and Preorder traversal
# pre[]. Initial values of inStrt and inEnd should be
# 0 and len -1. The function doesn't do any error
# checking for cases where inorder and preorder
# do not form a tree 
defbuildTree(inn, pre, inStrt, inEnd):
    
    globalpreIndex, mp

    if(inStrt > inEnd):
        returnNone

    # Pick current node from Preorder traversal
    # using preIndex and increment preIndex 
    curr =pre[preIndex]
    preIndex +=1
    tNode =Node(curr)

    # If this node has no children then return 
    if(inStrt ==inEnd):
        returntNode

    # Else find the index of this 
    # node in Inorder traversal 
    inIndex =mp[curr]

    # Using index in Inorder traversal, 
    # construct left and right subtress 
    tNode.left =buildTree(inn, pre, inStrt,
                           inIndex -1)
    tNode.right =buildTree(inn, pre, inIndex +1,
                            inEnd)

    returntNode

# This function mainly creates an 
# unordered_map, then calls buildTree()
defbuldTreeWrap(inn, pre, lenn):
    
    globalmp
    
    # Store indexes of all items so that we
    # we can quickly find later
    # unordered_map<char, int> mp;
    fori inrange(lenn):
        mp[inn[i]] =i

    returnbuildTree(inn, pre, 0, lenn -1)

# This function is here just to test buildTree() 
defprintInorder(node):

    if(node ==None):
        return
        
    printInorder(node.left)
    print(node.data, end ="" "")
    printInorder(node.right)

# Driver code
if__name__ =='__main__':
    
    mp ={}
    preIndex =0

    inn =[ 'D', 'B', 'E', 'A', 'F', 'C']
    pre =[ 'A', 'B', 'D', 'E', 'C', 'F']
    lenn =len(inn)

    root =buldTreeWrap(inn, pre,lenn)

    # Let us test the built tree by printing
    # Inorder traversal 
    print(""Inorder traversal of ""
          ""the constructed tree is"")
    
    printInorder(root)

# This code is contributed by mohit kumar 29
",O(n),O(n)
"# Python3 program to construct a tree using 
# inorder and preorder traversal 
classTreeNode:
    
    def__init__(self, x):      
        self.val =x
        self.left =None
        self.right =None

s =set()
st =[]

# Function to build tree using given traversal 
defbuildTree(preorder, inorder, n):
    root =None; 
    
    pre =0
    in_t =0
    
    whilepre < n:
        node =None; 
        
        whileTrue:    
            node =TreeNode(preorder[pre])
            
            if(root ==None):            
                root =node; 
             
            if(len(st) > 0):        
                if(st[-1] ins):                
                    s.discard(st[-1]); 
                    st[-1].right =node; 
                    st.pop(); 
            
                else:                
                    st[-1].left =node; 
                        
            st.append(node); 
            
            ifpre>=n orpreorder[pre] ==inorder[in_t]:
                pre +=1
                break
            pre +=1
            
        node =None; 
        
        while(len(st) > 0andin_t < n andst[-1].val ==inorder[in_t]):        
            node =st[-1]; 
            st.pop(); 
            in_t +=1
    

        if(node !=None):        
            s.add(node); 
            st.append(node); 

    returnroot; 

# Function to print tree in_t Inorder 
defprintInorder( node): 

    if(node ==None):
        return; 

    ''' first recur on left child '''
    printInorder(node.left); 

    ''' then print data of node '''
    print(node.val, end="" ""); 

    ''' now recur on right child '''
    printInorder(node.right); 

# Driver code 
if__name__=='__main__':
    
    in_t =[ 9, 8, 4, 2, 10, 5, 10, 1, 6, 3, 13, 12, 7]
    pre =[ 1, 2, 4, 8, 9, 5, 10, 10, 3, 6, 7, 12, 13]
    l =len(in_t) 

    root =buildTree(pre, in_t, l); 

    printInorder(root); 
    
    # This code is contributed by rutvik_56.
",O(n),O(n)
"# Python program to convert infix expression to postfix


# Class to convert the expression
classConversion:

    # Constructor to initialize the class variables
    def__init__(self, capacity):
        self.top =-1
        self.capacity =capacity
        
        # This array is used a stack
        self.array =[]
        
        # Precedence setting
        self.output =[]
        self.precedence ={'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}

    # Check if the stack is empty
    defisEmpty(self):
        returnTrueifself.top ==-1elseFalse

    # Return the value of the top of the stack
    defpeek(self):
        returnself.array[-1]

    # Pop the element from the stack
    defpop(self):
        ifnotself.isEmpty():
            self.top -=1
            returnself.array.pop()
        else:
            return""$""

    # Push the element to the stack
    defpush(self, op):
        self.top +=1
        self.array.append(op)

    # A utility function to check is the given character
    # is operand
    defisOperand(self, ch):
        returnch.isalpha()

    # Check if the precedence of operator is strictly
    # less than top of stack or not
    defnotGreater(self, i):
        try:
            a =self.precedence[i]
            b =self.precedence[self.peek()]
            returnTrueifa <=b elseFalse
        exceptKeyError:
            returnFalse

    # The main function that
    # converts given infix expression
    # to postfix expression
    definfixToPostfix(self, exp):

        # Iterate over the expression for conversion
        fori inexp:
            
            # If the character is an operand,
            # add it to output
            ifself.isOperand(i):
                self.output.append(i)

            # If the character is an '(', push it to stack
            elifi =='(':
                self.push(i)

            # If the scanned character is an ')', pop and
            # output from the stack until and '(' is found
            elifi ==')':
                while((notself.isEmpty()) and
                      self.peek() !='('):
                    a =self.pop()
                    self.output.append(a)
                if(notself.isEmpty() andself.peek() !='('):
                    return-1
                else:
                    self.pop()

            # An operator is encountered
            else:
                while(notself.isEmpty() andself.notGreater(i)):
                    self.output.append(self.pop())
                self.push(i)

        # Pop all the operator from the stack
        whilenotself.isEmpty():
            self.output.append(self.pop())

        forch inself.output:
            print(ch, end="""")


# Driver code
if__name__ =='__main__':
    exp =""a+b*(c^d-e)^(f+g*h)-i""
    obj =Conversion(len(exp))

    # Function call
    obj.infixToPostfix(exp)

# This code is contributed by Nikhil Kumar Singh(nickzuck_007)
",O(N),O(N)
"# Python3 program to find convex hull of a set of points. Refer  
# https://www.geeksforgeeks.org/orientation-3-ordered-points/ 
# for explanation of orientation() 
 
# point class with x, y as point  
classPoint: 
    def__init__(self, x, y): 
        self.x =x 
        self.y =y 
 
defLeft_index(points): 
     
    ''' 
    Finding the left most point 
    '''
    minn =0
    fori inrange(1,len(points)): 
        ifpoints[i].x < points[minn].x: 
            minn =i 
        elifpoints[i].x ==points[minn].x: 
            ifpoints[i].y > points[minn].y: 
                minn =i 
    returnminn 
 
deforientation(p, q, r): 
    ''' 
    To find orientation of ordered triplet (p, q, r).  
    The function returns following values  
    0 --> p, q and r are collinear  
    1 --> Clockwise  
    2 --> Counterclockwise  
    '''
    val =(q.y -p.y) *(r.x -q.x) -\ 
          (q.x -p.x) *(r.y -q.y) 
 
    ifval ==0: 
        return0
    elifval > 0: 
        return1
    else: 
        return2
 
defconvexHull(points, n): 
     
    # There must be at least 3 points  
    ifn < 3: 
        return
 
    # Find the leftmost point 
    l =Left_index(points) 
 
    hull =[] 
     
    ''' 
    Start from leftmost point, keep moving counterclockwise  
    until reach the start point again. This loop runs O(h)  
    times where h is number of points in result or output.  
    '''
    p =l 
    q =0
    while(True): 
         
        # Add current point to result  
        hull.append(p) 
 
        ''' 
        Search for a point 'q' such that orientation(p, q,  
        x) is counterclockwise for all points 'x'. The idea  
        is to keep track of last visited most counterclock-  
        wise point in q. If any point 'i' is more counterclock-  
        wise than q, then update q.  
        '''
        q =(p +1) %n 
 
        fori inrange(n): 
             
            # If i is more counterclockwise  
            # than current q, then update q  
            if(orientation(points[p],  
                           points[i], points[q]) ==2): 
                q =i 
 
        ''' 
        Now q is the most counterclockwise with respect to p  
        Set p as q for next iteration, so that q is added to  
        result 'hull'  
        '''
        p =q 
 
        # While we don't come to first point 
        if(p ==l): 
            break
 
    # Print Result  
    foreach inhull: 
        print(points[each].x, points[each].y) 
 
# Driver Code 
points =[] 
points.append(Point(0, 3)) 
points.append(Point(2, 2)) 
points.append(Point(1, 1)) 
points.append(Point(2, 1)) 
points.append(Point(3, 0)) 
points.append(Point(0, 0)) 
points.append(Point(3, 3)) 
 
convexHull(points, len(points)) 
 
# This code is contributed by  
# Akarsh Somani, IIIT Kalyani 
",O(m * n),O(n)
"# A Python3 program to count the number 
# of rectangular islands where every 
# island is separated by a line

# Size of given matrix is M X N
M =6
N =3

# This function takes a matrix of 'X' and 'O'
# and returns the number of rectangular 
# islands of 'X' where no two islands are 
# row-wise or column-wise adjacent, the islands 
# may be diagonally adjacent
defcountIslands(mat):

    count =0; # Initialize result

    # Traverse the input matrix
    fori inrange(0, M):
    
        forj inrange(0, N):
        
            # If current cell is 'X', then check
            # whether this is top-leftmost of a
            # rectangle. If yes, then increment count
            if(mat[i][j] =='X'):
            
                if((i ==0ormat[i -1][j] =='O') and
                    (j ==0ormat[i][j -1] =='O')):
                    count =count +1
            
    returncount

# Driver Code
mat =[['O', 'O', 'O'],
       ['X', 'X', 'O'],
       ['X', 'X', 'O'],
       ['O', 'O', 'X'],
       ['O', 'O', 'X'],
       ['X', 'X', 'O']]
                
print(""Number of rectangular islands is"", 
                       countIslands(mat))

# This code is contributed by iAyushRaj
",O(M x N),O(1)
"# Size of given matrix is M X N
M =6
N =3

# This function takes a matrix of 'X' and 'O'
# and returns the number of rectangular islands
# of 'X' where no two islands are row-wise or
# column-wise adjacent, the islands may be diagonally
# adjacent
defcountIslands(mat):
    dp =[[0] *N for_ inrange(M)]  # DP table to store count of islands
    count =0# Initialize result

    # Traverse the input matrix
    fori inrange(M):
        forj inrange(N):
            # If current cell is 'O', then no island can be formed
            ifmat[i][j] =='O':
                dp[i][j] =0
            else:
                # If this is the first column or the cell above is 'O',
                # then this cell is the top-leftmost of a rectangle
                ifj ==0ormat[i][j -1] =='O':
                    dp[i][j] =1
                else:
                    dp[i][j] =dp[i][j -1] +1

                # Increment count by the value in the DP table
                count +=dp[i][j]

    returncount

# Driver program to test above function
if__name__ ==""__main__"":
    mat =[['O', 'O', 'O'],
           ['X', 'X', 'O'],
           ['X', 'X', 'O'],
           ['O', 'O', 'X'],
           ['O', 'O', 'X'],
           ['X', 'X', 'O']]
    
    print(""Number of rectangular islands is"", countIslands(mat))

# This code is contributed by Shivam Tiwari
",O(M x N),O(1)
"# Python3 program to
# count trailing 0s
# in n!

# Function to return
# trailing 0s in
# factorial of n


deffindTrailingZeros(n):
    # Negative Number Edge Case
    if(n < 0):
        return-1

    # Initialize result
    count =0

    # Keep dividing n by
    # 5 & update Count
    while(n >=5):
        n //=5
        count +=n

    returncount


# Driver program
n =100
print(""Count of trailing 0s ""+
      ""in 100! is"", findTrailingZeros(n))

# This code is contributed by Uttam Singh
",O(log5n),O(1)
"# Python3 program to Create a matrix with
# alternating rectangles of O and X

# Function to print alternating rectangles 
# of 0 and X 
deffill0X(m, n):
    
    # k - starting row index 
    # m - ending row index 
    # l - starting column index 
    # n - ending column index 
    # i - iterator 
    i, k, l =0, 0, 0

    # Store given number of rows and 
    # columns for later use 
    r =m
    c =n 

    # A 2D array to store the output 
    # to be printed 
    a =[[None] *n fori inrange(m)] 
    x ='X'# Initialize the character to
            # be stored in a[][] 

    # Fill characters in a[][] in spiral form. 
    # Every iteration fills one rectangle of 
    # either Xs or Os 
    whilek < m andl < n:
        
        # Fill the first row from the 
        # remaining rows
        fori inrange(l, n):
            a[k][i] =x 
        k +=1

        # Fill the last column from 
        # the remaining columns
        fori inrange(k, m):
            a[i][n -1] =x 
        n -=1

        # Fill the last row from the 
        # remaining rows 
        ifk < m:
            fori inrange(n -1, l -1, -1):
                a[m -1][i] =x 
            m -=1

        # Print the first column from 
        # the remaining columns 
        ifl < n:
            fori inrange(m -1, k -1, -1):
                a[i][l] =x 
            l +=1

        # Flip character for next iteration
        x ='X'ifx =='0'else'0'

    # Print the filled matrix 
    fori inrange(r):
        forj inrange(c):
            print(a[i][j], end ="" "")
        print()

# Driver Code
if__name__ =='__main__':
    
    print(""Output for m = 5, n = 6"") 
    fill0X(5, 6) 

    print(""Output for m = 4, n = 4"") 
    fill0X(4, 4) 

    print(""Output for m = 3, n = 4"") 
    fill0X(3, 4)
    
# This code is contributed by pranchalK
",O(mn),O(mn)
"# Program to delete a node in a doubly-linked list 
 
# for Garbage collection 
importgc 
 
# A node of the doubly linked list 
classNode: 
     
    # Constructor to create a new node 
    def__init__(self, data): 
        self.data =data  
        self.next=None
        self.prev =None
 
classDoublyLinkedList: 
     # Constructor for empty Doubly Linked List 
    def__init__(self): 
        self.head =None
  
   # Function to delete a node in a Doubly Linked List. 
   # head_ref --> pointer to head node pointer. 
   # dele --> pointer to node to be deleted 
 
    defdeleteNode(self, dele): 
         
        # Base Case 
        ifself.head isNoneordele isNone: 
            return
         
        # If node to be deleted is head node 
        ifself.head ==dele: 
            self.head =dele.next
 
        # Change next only if node to be deleted is NOT 
        # the last node 
        ifdele.nextisnotNone: 
            dele.next.prev =dele.prev 
     
        # Change prev only if node to be deleted is NOT  
        # the first node 
        ifdele.prev isnotNone: 
            dele.prev.next=dele.next
        # Finally, free the memory occupied by dele 
        # Call python garbage collector 
        gc.collect() 
 
 
    # Given a reference to the head of a list and an 
    # integer, inserts a new node on the front of list 
    defpush(self, new_data): 
  
        # 1. Allocates node 
        # 2. Put the data in it 
        new_node =Node(new_data) 
  
        # 3. Make next of new node as head and 
        # previous as None (already None) 
        new_node.next=self.head 
  
        # 4. change prev of head node to new_node 
        ifself.head isnotNone: 
            self.head.prev =new_node 
  
        # 5. move the head to point to the new node 
        self.head =new_node 
 
 
    defprintList(self, node): 
        while(node isnotNone): 
            print(node.data,end=' ') 
            node =node.next
 
 
# Driver program to test the above functions 
 
# Start with empty list 
dll =DoublyLinkedList() 
 
# Let us create the doubly linked list 10<->8<->4<->2 
dll.push(2); 
dll.push(4); 
dll.push(8); 
dll.push(10); 
 
print(""\n Original Linked List"",end=' ') 
dll.printList(dll.head) 
 
# delete nodes from doubly linked list 
dll.deleteNode(dll.head) 
dll.deleteNode(dll.head.next) 
dll.deleteNode(dll.head.next) 
# Modified linked list will be NULL<-8->NULL 
print(""\n Modified Linked List"",end=' ') 
dll.printList(dll.head) 
 
# This code is contributed by Nikhil Kumar Singh(nickzuck_007) 
",O(1),O(1)
"# Python code to delete a node in AVL tree
# Generic tree node class
classTreeNode(object):
    def__init__(self, val):
        self.val =val
        self.left =None
        self.right =None
        self.height =1

# AVL tree class which supports insertion,
# deletion operations
classAVL_Tree(object):

    definsert(self, root, key):
        
        # Step 1 - Perform normal BST
        ifnotroot:
            returnTreeNode(key)
        elifkey < root.val:
            root.left =self.insert(root.left, key)
        else:
            root.right =self.insert(root.right, key)

        # Step 2 - Update the height of the 
        # ancestor node
        root.height =1+max(self.getHeight(root.left),
                          self.getHeight(root.right))

        # Step 3 - Get the balance factor
        balance =self.getBalance(root)

        # Step 4 - If the node is unbalanced,
        # then try out the 4 cases
        # Case 1 - Left Left
        ifbalance > 1andkey < root.left.val:
            returnself.rightRotate(root)

        # Case 2 - Right Right
        ifbalance < -1andkey > root.right.val:
            returnself.leftRotate(root)

        # Case 3 - Left Right
        ifbalance > 1andkey > root.left.val:
            root.left =self.leftRotate(root.left)
            returnself.rightRotate(root)

        # Case 4 - Right Left
        ifbalance < -1andkey < root.right.val:
            root.right =self.rightRotate(root.right)
            returnself.leftRotate(root)

        returnroot

    # Recursive function to delete a node with
    # given key from subtree with given root.
    # It returns root of the modified subtree.
    defdelete(self, root, key):

        # Step 1 - Perform standard BST delete
        ifnotroot:
            returnroot

        elifkey < root.val:
            root.left =self.delete(root.left, key)

        elifkey > root.val:
            root.right =self.delete(root.right, key)

        else:
            ifroot.left isNone:
                temp =root.right
                root =None
                returntemp

            elifroot.right isNone:
                temp =root.left
                root =None
                returntemp

            temp =self.getMinValueNode(root.right)
            root.val =temp.val
            root.right =self.delete(root.right,
                                      temp.val)

        # If the tree has only one node,
        # simply return it
        ifroot isNone:
            returnroot

        # Step 2 - Update the height of the 
        # ancestor node
        root.height =1+max(self.getHeight(root.left),
                            self.getHeight(root.right))

        # Step 3 - Get the balance factor
        balance =self.getBalance(root)

        # Step 4 - If the node is unbalanced, 
        # then try out the 4 cases
        # Case 1 - Left Left
        ifbalance > 1andself.getBalance(root.left) >=0:
            returnself.rightRotate(root)

        # Case 2 - Right Right
        ifbalance < -1andself.getBalance(root.right) <=0:
            returnself.leftRotate(root)

        # Case 3 - Left Right
        ifbalance > 1andself.getBalance(root.left) < 0:
            root.left =self.leftRotate(root.left)
            returnself.rightRotate(root)

        # Case 4 - Right Left
        ifbalance < -1andself.getBalance(root.right) > 0:
            root.right =self.rightRotate(root.right)
            returnself.leftRotate(root)

        returnroot

    defleftRotate(self, z):

        y =z.right
        T2 =y.left

        # Perform rotation
        y.left =z
        z.right =T2

        # Update heights
        z.height =1+max(self.getHeight(z.left), 
                         self.getHeight(z.right))
        y.height =1+max(self.getHeight(y.left), 
                         self.getHeight(y.right))

        # Return the new root
        returny

    defrightRotate(self, z):

        y =z.left
        T3 =y.right

        # Perform rotation
        y.right =z
        z.left =T3

        # Update heights
        z.height =1+max(self.getHeight(z.left),
                          self.getHeight(z.right))
        y.height =1+max(self.getHeight(y.left),
                          self.getHeight(y.right))

        # Return the new root
        returny

    defgetHeight(self, root):
        ifnotroot:
            return0

        returnroot.height

    defgetBalance(self, root):
        ifnotroot:
            return0

        returnself.getHeight(root.left) -self.getHeight(root.right)

    defgetMinValueNode(self, root):
        ifroot isNoneorroot.left isNone:
            returnroot

        returnself.getMinValueNode(root.left)

    defpreOrder(self, root):

        ifnotroot:
            return

        print(""{0} "".format(root.val), end="""")
        self.preOrder(root.left)
        self.preOrder(root.right)


myTree =AVL_Tree()
root =None
nums =[9, 5, 10, 0, 6, 11, -1, 1, 2]

fornum innums:
    root =myTree.insert(root, num)

# Preorder Traversal
print(""Preorder Traversal after insertion -"")
myTree.preOrder(root)
print()

# Delete
key =10
root =myTree.delete(root, key)

# Preorder Traversal
print(""Preorder Traversal after deletion -"")
myTree.preOrder(root)
print()

# This code is contributed by Ajitesh Pathak
",O(Log n),O(1)
"# Python3 program to implement optimized delete in BST.

classNode:
    def__init__(self, key):
        self.key =key
        self.left =None
        self.right =None

# A utility function to do inorder traversal of BST
definorder(root):
    ifroot isnotNone:
        inorder(root.left)
        print(root.key, end=' ')
        inorder(root.right)

# A utility function to insert a new node with given key in BST
definsert(node, key):
    # If the tree is empty, return a new node
    ifnode isNone:
        returnNode(key)

    # Otherwise, recur down the tree
    ifkey < node.key:
        node.left =insert(node.left, key)
    else:
        node.right =insert(node.right, key)

    # return the (unchanged) node pointer
    returnnode

# Given a binary search tree and a key, this function
# deletes the key and returns the new root
defdeleteNode(root, k):
    # Base case
    ifroot isNone:
        returnroot

    # Recursive calls for ancestors of
    # node to be deleted
    ifroot.key > k:
        root.left =deleteNode(root.left, k)
        returnroot
    elifroot.key < k:
        root.right =deleteNode(root.right, k)
        returnroot

    # We reach here when root is the node
    # to be deleted.

    # If one of the children is empty
    ifroot.left isNone:
        temp =root.right
        delroot
        returntemp
    elifroot.right isNone:
        temp =root.left
        delroot
        returntemp

    # If both children exist
    else:

        succParent =root

        # Find successor
        succ =root.right
        whilesucc.left isnotNone:
            succParent =succ
            succ =succ.left

        # Delete successor.  Since successor
        # is always left child of its parent
        # we can safely make successor's right
        # right child as left of its parent.
        # If there is no succ, then assign
        # succ.right to succParent.right
        ifsuccParent !=root:
            succParent.left =succ.right
        else:
            succParent.right =succ.right

        # Copy Successor Data to root
        root.key =succ.key

        # Delete Successor and return root
        delsucc
        returnroot

# Driver Code
if__name__ =='__main__':
    # Let us create following BST
    #          50
    #       /     \
    #      30      70
    #     /  \    /  \
    #   20   40  60   80
    root =None
    root =insert(root, 50)
    root =insert(root, 30)
    root =insert(root, 20)
    root =insert(root, 40)
    root =insert(root, 70)
    root =insert(root, 60)

    print(""Original BST: "", end='')
    inorder(root)

    print(""\n\nDelete a Leaf Node: 20"")
    root =deleteNode(root, 20)
    print(""Modified BST tree after deleting Leaf Node:"")
    inorder(root)

    print(""\n\nDelete Node with single child: 70"")
    root =deleteNode(root, 70)
    print(""Modified BST tree after deleting single child Node:"")
    inorder(root)

    print(""\n\nDelete Node with both child: 50"")
    root =deleteNode(root, 50)
    print(""Modified BST tree after deleting both child Node:"")
    inorder(root)
",O(h),O(n)
"fromtyping importList

# Set the number of dimensions for each point
k =2

# Define a class for each node in the K-Dimensional Tree
classNode:
    def__init__(self, point: List[int]):
        # The point in the tree is stored in this node
        self.point =point
        # The left child node
        self.left =None
        # The right child node
        self.right =None

# Function to insert a new point into the tree
definsert(root, point: List[int]):
    # If the tree is empty, return a new node with the point
    ifnotroot:
        returnNode(point)

    # Start from the root node
    current_node =root
    # Find the correct leaf node to insert the new point
    whilecurrent_node:
        # If the new point is smaller than the current node's point in the current dimension, go to the left child node
        next_node =current_node.left ifpoint[k-1] < current_node.point[k-1] elsecurrent_node.right
        # If the next node doesn't exist, we have found the correct leaf node to insert the new point
        ifnotnext_node:
            break
        # If the next node exists, continue searching in the tree
        current_node =next_node

    # Insert the new point as a left or right child node of the correct leaf node
    ifpoint[k-1] < current_node.point[k-1]:
        current_node.left =Node(point)
    else:
        current_node.right =Node(point)
    returnroot

# Function to copy the values of one point to another
defcopyPoint(p1, p2):
    fori inrange(k):
        p1[i] =p2[i]

# Function to find the node with the minimum value in a subtree
defminValueNode(node):
    current_node =node
    # Go to the leftmost leaf node in the subtree
    whilecurrent_node.left:
        current_node =current_node.left
    returncurrent_node

# Recursive function to delete a node from the tree
defdeleteNodeRec(root, point, depth):
    # If the tree is empty or the node is not found, return None
    ifnotroot:
        returnNone

    # Calculate the current dimension based on the depth
    current_depth =depth %k
    # If the point to be deleted is smaller than the current node's point in the current dimension, go to the left subtree
    ifpoint[current_depth] < root.point[current_depth]:
        root.left =deleteNodeRec(root.left, point, depth +1)
    # If the point to be deleted is larger than the current node's point in the current dimension, go to the right subtree
    elifpoint[current_depth] > root.point[current_depth]:
        root.right =deleteNodeRec(root.right, point, depth +1)
    # If the point to be deleted is equal to the current node's point, delete the node
    else:
        # If the node has no left child, return its right child
        ifnotroot.left:
            returnroot.right
        elifnotroot.right:
            returnroot.left
        else:
            temp =minValueNode(root.right)
            copyPoint(root.point, temp.point)
            root.right =deleteNodeRec(root.right, temp.point, depth +1)
    returnroot

defdeleteNode(root, point):
    returndeleteNodeRec(root, point, 0)

# Driver program to test above functions
if__name__ ==""__main__"":
    root =None
    points =[[30, 40], [5, 25], [70, 70], [10, 12], [50, 30], [35, 45]]
    n =len(points)

    fori inrange(n):
        root =insert(root, points[i])

    # Delete (30, 40)
    root =deleteNode(root, points[0])

    print(""Root after deletion of (30, 40)"")
    print(root.point[0], root.point[1])

# This code is contributed by Vikram_Shirsat
",O(log N),O(N)
"# Python3 program to print DFS traversal
# from a given  graph
fromcollections importdefaultdict


# This class represents a directed graph using
# adjacency list representation
classGraph:

    # Constructor
    def__init__(self):

        # Default dictionary to store graph
        self.graph =defaultdict(list)

    
    # Function to add an edge to graph
    defaddEdge(self, u, v):
        self.graph[u].append(v)

    
    # A function used by DFS
    defDFSUtil(self, v, visited):

        # Mark the current node as visited
        # and print it
        visited.add(v)
        print(v, end=' ')

        # Recur for all the vertices
        # adjacent to this vertex
        forneighbour inself.graph[v]:
            ifneighbour notinvisited:
                self.DFSUtil(neighbour, visited)

    
    # The function to do DFS traversal. It uses
    # recursive DFSUtil()
    defDFS(self, v):

        # Create a set to store visited vertices
        visited =set()

        # Call the recursive helper function
        # to print DFS traversal
        self.DFSUtil(v, visited)


# Driver's code
if__name__ ==""__main__"":
    g =Graph()
    g.addEdge(0, 1)
    g.addEdge(0, 2)
    g.addEdge(1, 2)
    g.addEdge(2, 0)
    g.addEdge(2, 3)
    g.addEdge(3, 3)

    print(""Following is Depth First Traversal (starting from vertex 2)"")
    
    # Function call
    g.DFS(2)

# This code is contributed by Neelam Yadav
",O(V + E),O(V + E)
"''' Python3 Program to implement a stack 
that supports findMiddle() 
and deleteMiddle in O(1) time '''

''' A Doubly Linked List Node '''


classDLLNode:

    def__init__(self, d):
        self.prev =None
        self.data =d
        self.next=None


''' Representation of the stack 
data structure that supports 
findMiddle() in O(1) time. The 
Stack is implemented using 
Doubly Linked List. It maintains 
pointer to head node, pointer 
to middle node and count of 
nodes '''


classmyStack:

    def__init__(self):
        self.head =None
        self.mid =None
        self.count =0


''' Function to create the stack data structure '''


defcreateMyStack():
    ms =myStack()
    ms.count =0
    returnms


''' Function to push an element to the stack '''


defpush(ms, new_data):
    ''' allocate DLLNode and put in data '''
    new_DLLNode =DLLNode(new_data)

    ''' Since we are adding at the beginning, 
    prev is always NULL '''
    new_DLLNode.prev =None

    ''' link the old list of the new DLLNode '''
    new_DLLNode.next=ms.head

    ''' Increment count of items in stack '''
    ms.count +=1

    ''' Change mid pointer in two cases 
    1) Linked List is empty 
    2) Number of nodes in linked list is odd '''
    if(ms.count ==1):
        ms.mid =new_DLLNode

    else:
        ms.head.prev =new_DLLNode

        # Update mid if ms->count is odd
        if((ms.count %2) !=0):
            ms.mid =ms.mid.prev

    ''' move head to point to the new DLLNode '''
    ms.head =new_DLLNode


''' Function to pop an element from stack '''


defpop(ms):
    ''' Stack underflow '''
    if(ms.count ==0):

        print(""Stack is empty"")
        return-1

    head =ms.head
    item =head.data
    ms.head =head.next

    # If linked list doesn't become empty,
    # update prev of new head as NULL
    if(ms.head !=None):
        ms.head.prev =None
    ms.count -=1

    # update the mid pointer when
    # we have even number of elements
    # in the stack, i,e move down
    # the mid pointer.
    if(ms.count %2==0):
        ms.mid =ms.mid.next
    returnitem

# Function for finding middle of the stack


deffindMiddle(ms):
    if(ms.count ==0):
        print(""Stack is empty now"")
        return-1
    returnms.mid.data

defdeleteMiddle(ms):
  if(ms.count ==0):
    print(""Stack is empty now"")
    return
  ms.count-=1
  ms.mid.next.prev=ms.mid.prev
  ms.mid.prev.next=ms.mid.next
  
  ifms.count %2==1:
    ms.mid=ms.mid.next
  else:
    ms.mid=ms.mid.prev

# Driver code
if__name__ =='__main__':

    ms =createMyStack()
    push(ms, 11)
    push(ms, 22)
    push(ms, 33)
    push(ms, 44)
    push(ms, 55)
    push(ms, 66)
    push(ms, 77)
    push(ms, 88)
    push(ms, 99)

    print(""Popped : ""+
          str(pop(ms)))
    print(""Popped : ""+
          str(pop(ms)))
    print(""Middle Element : ""+
          str(findMiddle(ms)))
    deleteMiddle(ms)
    print(""New Middle Element : ""+
          str(findMiddle(ms)))

    # This code is contributed by rutvik_56.
    # Updated by Amsavarthan Lv
",O(1),O(n)
"# Python approach for above code
st =[]
dq =[]

defadd(data):
    dq.append(data)
    if(len(dq) > len(st) +1):
        temp =dq[0]
        dq.pop(0)
        st.append(temp)

defpop():
    data =dq[len(dq) -1]
    dq.pop()
    if(len(st) > len(dq)):
        temp =st[0]
        st.pop()
        dq.insert(temp,0)

defgetMiddleElement():
    returndq[0]

defdeleteMiddleElement():
    dq.pop(0)
    if(len(st) > len(dq)):  # new middle element
        temp =st[0] # should come at front of deque
        st.pop()
        dq.insert(temp,0)

add(2)
add(5)
print(""Middle Element: "", getMiddleElement())
add(3)
add(7)
add(4)
print(""Middle Element: "", getMiddleElement())
deleteMiddleElement()
print(""Middle Element: "", getMiddleElement())
deleteMiddleElement()
print(""Middle Element: "", getMiddleElement())
pop()
pop()
deleteMiddleElement()

# This code is contributed by adityamaharshi21
",O(1),O(n)
"# Python3 program for the 
# above approach 
# A simple stack class with   
# basic stack functionalities 
classstack: 
 
  def__init__(self): 
 
    self.array =[] 
    self.top =-1
    self.max=100
 
  # Stack's member method to check  
  # if the stack is empty 
  defisEmpty(self): 
 
    ifself.top ==-1: 
      returnTrue
    else: 
      returnFalse
 
  # Stack's member method to check 
  # if the stack is full   
  defisFull(self):   
     
    ifself.top ==self.max-1: 
      returnTrue
    else: 
      returnFalse
 
  # Stack's member method to  
  # insert an element to it    
 
  defpush(self, data): 
 
    ifself.isFull(): 
      print('Stack OverFlow') 
      return
    else: 
      self.top +=1
      self.array.append(data)      
 
  # Stack's member method to  
  # remove an element from it  
  defpop(self): 
 
    ifself.isEmpty(): 
      print('Stack UnderFlow') 
      return
    else:  
      self.top -=1
      returnself.array.pop() 
 
# A class that supports all the stack   
# operations and one additional  
# operation getMin() that returns the  
# minimum element from stack at  
# any time.  This class inherits from 
# the stack class and uses an  
# auxiliary stack that holds  
# minimum elements   
classSpecialStack(stack): 
 
  def__init__(self): 
    super().__init__() 
    self.Min=stack()   
 
  # SpecialStack's member method to  
  # insert an element to it. This method  
  # makes sure that the min stack is also 
  # updated with appropriate minimum 
  # values  
  defpush(self, x): 
 
    ifself.isEmpty(): 
      super().push(x) 
      self.Min.push(x) 
    else: 
      super().push(x) 
      y =self.Min.pop() 
      self.Min.push(y) 
      ifx <=y: 
        self.Min.push(x) 
      else: 
        self.Min.push(y)   
 
  # SpecialStack's member method to   
  # remove an element from it. This  
  # method removes top element from  
  # min stack also.  
  defpop(self): 
 
    x =super().pop() 
    self.Min.pop() 
    returnx   
 
  # SpecialStack's member method  
  # to get minimum element from it. 
  defgetmin(self): 
 
    x =self.Min.pop() 
    self.Min.push(x) 
    returnx 
 
# Driver code 
if__name__ =='__main__': 
   
  s =SpecialStack() 
  s.push(10) 
  s.push(20) 
  s.push(30) 
  print(s.getmin()) 
  s.push(5) 
  print(s.getmin()) 
 
# This code is contributed by rachitkatiyar99
",O(1),O(n)
"''' SpecialStack's member method to  
insert an element to it. This method 
makes sure that the min stack is  
also updated with appropriate minimum 
values '''
 
defpush(x): 
    if(isEmpty() ==True): 
        super.append(x); 
        min.append(x); 
     
    else: 
        super.append(x); 
        y =min.pop(); 
        min.append(y); 
 
        ''' push only when the incoming  
           element of main stack is smaller  
        than or equal to top of auxiliary stack '''
        if(x <=y): 
            min.append(x); 
     
 
 
''' SpecialStack's member method to  
   remove an element from it. This method 
   removes top element from min stack also. '''
defpop(): 
    x =super.pop(); 
    y =min.pop(); 
 
    ''' Push the popped element y back  
       only if it is not equal to x '''
    if(y !=x): 
        min.append(y); 
    returnx; 
 
 
# This code contributed by umadevi9616  
",O(1),O(n)
"# A special stack having peek() pop() and 
# push() along with additional getMin() that 
# returns minimum value in a stack without 
# using extra space and all operations in O(1) 
# time.. ???? 
classSpecialStack: 
 
    def__init__(self): 
        # Sentinel value for min 
        self.minm =-1
 
        # DEMO_VALUE 
        SpecialStack.demoVal =9999
        self.st =[] 
 
    defgetMin(self): 
        print(""min is: "", self.minm) 
 
    defpush(self, val): 
 
        # If stack is empty OR current element 
        # is less than min, update min. 
        iflen(self.st) ==0orval < self.minm: 
            self.minm =val 
 
        # Encode the current value with 
        # demoVal, combine with min and 
        # insert into stack 
        self.st.append(val*self.demoVal +self.minm) 
        print(""pushed: "", val) 
 
    defpop(self): 
 
        # if stack is empty return -1 
        iflen(self.st) ==0: 
            print(""stack underflow"") 
            return-1
 
        val =self.st.pop() 
 
        # If stack is empty, there would 
        # be no min value present, so 
        # make min as -1 
        iflen(self.st) !=0: 
            self.minm =self.st[-1] %self.demoVal 
        else: 
            self.minm =-1
 
        print(""popped: "", val //self.demoVal) 
 
        # Decode actual value from 
        # encoded value 
        returnval //self.demoVal 
 
    defpeek(self): 
 
        # Decode actual value 
        # from encoded value 
        returnself.st[-1] //self.demoVal 
 
# Driver Code 
if__name__ ==""__main__"": 
    s =SpecialStack() 
 
    arr =[3, 2, 6, 1, 8, 5, 5, 5, 5] 
 
    fori inrange(len(arr)): 
        s.push(arr[i]) 
        s.getMin() 
 
    print(""\n"") 
    fori inrange(len(arr)): 
        s.pop() 
        s.getMin() 
 
        # This code is contributed by pankajkumar70792.
",O(1),O(1)
"# Python program to detect cycle
# in a graph

fromcollections importdefaultdict


classGraph():
    def__init__(self, vertices):
        self.graph =defaultdict(list)
        self.V =vertices

    defaddEdge(self, u, v):
        self.graph[u].append(v)

    defisCyclicUtil(self, v, visited, recStack):

        # Mark current node as visited and
        # adds to recursion stack
        visited[v] =True
        recStack[v] =True

        # Recur for all neighbours
        # if any neighbour is visited and in
        # recStack then graph is cyclic
        forneighbour inself.graph[v]:
            ifvisited[neighbour] ==False:
                ifself.isCyclicUtil(neighbour, visited, recStack) ==True:
                    returnTrue
            elifrecStack[neighbour] ==True:
                returnTrue

        # The node needs to be popped from
        # recursion stack before function ends
        recStack[v] =False
        returnFalse

    # Returns true if graph is cyclic else false
    defisCyclic(self):
        visited =[False] *(self.V +1)
        recStack =[False] *(self.V +1)
        fornode inrange(self.V):
            ifvisited[node] ==False:
                ifself.isCyclicUtil(node, visited, recStack) ==True:
                    returnTrue
        returnFalse


# Driver code
if__name__ =='__main__':
    g =Graph(4)
    g.addEdge(0, 1)
    g.addEdge(0, 2)
    g.addEdge(1, 2)
    g.addEdge(2, 0)
    g.addEdge(2, 3)
    g.addEdge(3, 3)

    ifg.isCyclic() ==1:
        print(""Graph contains cycle"")
    else:
        print(""Graph doesn't contain cycle"")

# Thanks to Divyanshu Mehta for contributing this code
",O(V + E),O(V)
"fromcollections importdeque

classGraph:
    def__init__(self, V):
        self.V =V
        self.adj =[[] for_ inrange(V)]

    defaddEdge(self, v, w):
        self.adj[v].append(w)

    defisCyclic(self):
        inDegree =[0] *self.V
        q =deque()
        visited =0

        # Calculate in-degree of each vertex
        foru inrange(self.V):
            forv inself.adj[u]:
                inDegree[v] +=1

        # Enqueue vertices with 0 in-degree
        foru inrange(self.V):
            ifinDegree[u] ==0:
                q.append(u)

        # BFS traversal
        whileq:
            u =q.popleft()
            visited +=1

            # Reduce in-degree of adjacent vertices
            forv inself.adj[u]:
                inDegree[v] -=1
                # If in-degree becomes 0, enqueue the vertex
                ifinDegree[v] ==0:
                    q.append(v)

        returnvisited !=self.V  # If not all vertices are visited, there is a cycle

# Main driver code
g =Graph(6)
g.addEdge(0, 1)
g.addEdge(0, 2)
g.addEdge(1, 3)
g.addEdge(4, 1)
g.addEdge(4, 5)
g.addEdge(5, 3)

ifg.isCyclic():
    print(""Graph contains a cycle."")
else:
    print(""Graph does not contain a cycle."")
# This code is contributed by Rishabh Mathur
",O(V + E),O(V)
"# Python Program to detect cycle in an undirected graph
fromcollections importdefaultdict

# This class represents a undirected
# graph using adjacency list representation


classGraph:

    def__init__(self, vertices):

        # No. of vertices
        self.V =vertices  # No. of vertices

        # Default dictionary to store graph
        self.graph =defaultdict(list)

    # Function to add an edge to graph
    defaddEdge(self, v, w):

        # Add w to v_s list
        self.graph[v].append(w)

        # Add v to w_s list
        self.graph[w].append(v)

    # A recursive function that uses
    # visited[] and parent to detect
    # cycle in subgraph reachable from vertex v.
    defisCyclicUtil(self, v, visited, parent):

        # Mark the current node as visited
        visited[v] =True

        # Recur for all the vertices
        # adjacent to this vertex
        fori inself.graph[v]:

            # If the node is not
            # visited then recurse on it
            ifvisited[i] ==False:
                if(self.isCyclicUtil(i, visited, v)):
                    returnTrue
            # If an adjacent vertex is
            # visited and not parent
            # of current vertex,
            # then there is a cycle
            elifparent !=i:
                returnTrue

        returnFalse

    # Returns true if the graph
    # contains a cycle, else false.

    defisCyclic(self):

        # Mark all the vertices
        # as not visited
        visited =[False]*(self.V)

        # Call the recursive helper
        # function to detect cycle in different
        # DFS trees
        fori inrange(self.V):

            # Don't recur for u if it
            # is already visited
            ifvisited[i] ==False:
                if(self.isCyclicUtil
                   (i, visited, -1)) ==True:
                    returnTrue

        returnFalse


# Create a graph given in the above diagram
g =Graph(5)
g.addEdge(1, 0)
g.addEdge(1, 2)
g.addEdge(2, 0)
g.addEdge(0, 3)
g.addEdge(3, 4)

ifg.isCyclic():
    print(""Graph contains cycle"")
else:
    print(""Graph doesn't contain cycle "")
g1 =Graph(3)
g1.addEdge(0, 1)
g1.addEdge(1, 2)


ifg1.isCyclic():
    print(""Graph contains cycle"")
else:
    print(""Graph doesn't contain cycle "")

# This code is contributed by Neelam Yadav
",O(V+E),O(V)
"# Python3 Program to Detect  
# if two integers have  
# opposite signs. 
defoppositeSigns(x, y): 
    return((x ^ y) < 0); 
  
x =100
y =1
  
if(oppositeSigns(x, y) ==True): 
    print(""Signs are opposite"")
else: 
    print(""Signs are not opposite"")
  
# This article is contributed by Prerna Saini.
",O(1),O(1)
"defoppositeSigns(x, y):

    return(y >=0) if(x < 0) else(y < 0);

# This code is contributed by shivanisingjss2110
",O(1),O(1)
"defoppositeSigns(x, y):

    return((x ^ y) >> 31)
  
# this code is contributed by shivanisinghss2110
",O(1),O(1)
"# Python Program to detect
# if two integers have opposite signs.

defoppositeSigns(x,y):
    product =x*y
    return(product<0)

# driver code
x =100
y =-100
if(oppositeSigns(x, y) ==True):
  print(""Signs are opposite"")  
else:
  print(""Signs are not opposite"")
  
# this code is contributed by shinjanpatra
",O(1),O(1)
"# Python3 program to find the diameter of binary tree

# A binary tree node


classNode:

    # Constructor to create a new node
    def__init__(self, data):
        self.data =data
        self.left =None
        self.right =None


# The function Compute the ""height"" of a tree. Height is the
# number of nodes along the longest path from the root node
# down to the farthest leaf node.

defheight(node):

    # Base Case : Tree is empty
    ifnode isNone:
        return0

    # If tree is not empty then height = 1 + max of left
    # height and right heights
    return1+max(height(node.left), height(node.right))

# Function to get the diameter of a binary tree


defdiameter(root):

    # Base Case when tree is empty
    ifroot isNone:
        return0

    # Get the height of left and right sub-trees
    lheight =height(root.left)
    rheight =height(root.right)

    # Get the diameter of left and right sub-trees
    ldiameter =diameter(root.left)
    rdiameter =diameter(root.right)

    # Return max of the following tree:
    # 1) Diameter of left subtree
    # 2) Diameter of right subtree
    # 3) Height of left subtree + height of right subtree +1
    returnmax(lheight +rheight +1, max(ldiameter, rdiameter))


# Driver Code
if__name__ ==""__main__"":
    """"""
    Constructed binary tree is 
                1
              /   \
            2      3
          /  \
        4     5
    """"""

    root =Node(1)
    root.left =Node(2)
    root.right =Node(3)
    root.left.left =Node(4)
    root.left.right =Node(5)

    # Function Call
    print(diameter(root))

# This code is contributed by Nikhil Kumar Singh(nickzuck_007)
",O(N2),O(N)
"# Python3 program to find the diameter of a binary tree
# A binary tree Node


classNode:

    # Constructor to create a new Node
    def__init__(self, data):
        self.data =data
        self.left =self.right =None

# utility class to pass height object


classHeight:
    def__init(self):
        self.h =0

# Optimised recursive function to find diameter
# of binary tree


defdiameterOpt(root, height):

    # to store height of left and right subtree
    lh =Height()
    rh =Height()

    # base condition- when binary tree is empty
    ifroot isNone:
        height.h =0
        return0

    # ldiameter --> diameter of left subtree
    # rdiameter  --> diameter of right subtree

    # height of left subtree and right subtree is obtained from lh and rh
    # and returned value of function is stored in ldiameter and rdiameter

    ldiameter =diameterOpt(root.left, lh)
    rdiameter =diameterOpt(root.right, rh)

    # height of tree will be max of left subtree
    # height and right subtree height plus1

    height.h =max(lh.h, rh.h) +1

    # return maximum of the following
    # 1)left diameter
    # 2)right diameter
    # 3)left height + right height + 1
    returnmax(lh.h +rh.h +1, max(ldiameter, rdiameter))

# function to calculate diameter of binary tree


defdiameter(root):
    height =Height()
    returndiameterOpt(root, height)


# Driver Code
if__name__ ==""__main__"":
    root =Node(1)
    root.left =Node(2)
    root.right =Node(3)
    root.left.left =Node(4)
    root.left.right =Node(5)

    """"""
  Constructed binary tree is 
              1
          /   \
          2      3
        /  \
      4     5
  """"""

    print(""The diameter of the binary tree is:"", end="" "")
    # Function Call
    print(diameter(root))

# This code is contributed by Shweta Singh(shweta44)
",O(N),O(N)
"# Python3 code to implement the above approach that uses the
# morris traversal algorithm

# A tree node
classNode:
    def__init__(self, data):
        self.data =data
        self.left =None
        self.right =None

# Create a new node
defnewNode(data):
    node =Node(data)
    returnnode

# Morris traversal to find the diameter of the binary tree
deffindDiameter(root):
    ans =0
    curr =root

    whilecurr isnotNone:
        ifcurr.left isNone:
            curr =curr.right
        else:
            pre =curr.left
            whilepre.right isnotNoneandpre.right !=curr:
                pre =pre.right
            ifpre.right isNone:
                pre.right =curr
                curr =curr.left
            else:
                pre.right =None
                leftHeight =0
                rightHeight =0
                temp =curr.left
                whiletemp isnotNone:
                    leftHeight +=1
                    temp =temp.right
                temp =curr.right
                whiletemp isnotNone:
                    rightHeight +=1
                    temp =temp.left
                ans =max(ans, leftHeight +rightHeight +1)
                curr =curr.right
    returnans


# Driver code
if__name__ =='__main__':
    # Create the given binary tree
    root =newNode(1)
    root.left =newNode(2)
    root.right =newNode(3)
    root.left.left =newNode(4)
    root.left.right =newNode(5)

    # Find the diameter of the binary tree using Morris
    # traversal
    diameter =findDiameter(root)

    # Print the diameter of the binary tree
    print(""The diameter of given binary tree is"", diameter)
",O(N),O(h)
"# Python 3 program to demonstrate implementation 
# of k stacks in a single array in time and space 
# efficient way 
classKStacks:
    
    def__init__(self, k, n):
        self.k =k # Number of stacks.
        self.n =n # Total size of array holding 
                   # all the 'k' stacks.

        # Array which holds 'k' stacks.
        self.arr =[0] *self.n

        # All stacks are empty to begin with 
        # (-1 denotes stack is empty).
        self.top =[-1] *self.k

        # Top of the free stack.
        self.free =0

        # Points to the next element in either
        # 1. One of the 'k' stacks or,
        # 2. The 'free' stack.
        self.next=[i +1fori inrange(self.n)]
        self.next[self.n -1] =-1

    # Check whether given stack is empty.
    defisEmpty(self, sn):
        returnself.top[sn] ==-1

    # Check whether there is space left for 
    # pushing new elements or not.
    defisFull(self):
        returnself.free ==-1

    # Push 'item' onto given stack number 'sn'.
    defpush(self, item, sn):
        ifself.isFull():
            print(""Stack Overflow"")
            return

        # Get the first free position 
        # to insert at.
        insert_at =self.free

        # Adjust the free position.
        self.free =self.next[self.free]

        # Insert the item at the free 
        # position we obtained above.
        self.arr[insert_at] =item

        # Adjust next to point to the old
        # top of stack element.
        self.next[insert_at] =self.top[sn]

        # Set the new top of the stack.
        self.top[sn] =insert_at

    # Pop item from given stack number 'sn'.
    defpop(self, sn):
        ifself.isEmpty(sn):
            returnNone

        # Get the item at the top of the stack.
        top_of_stack =self.top[sn]

        # Set new top of stack.
        self.top[sn] =self.next[self.top[sn]]

        # Push the old top_of_stack to 
        # the 'free' stack.
        self.next[top_of_stack] =self.free
        self.free =top_of_stack

        returnself.arr[top_of_stack]

    defprintstack(self, sn):
        top_index =self.top[sn]
        while(top_index !=-1):
            print(self.arr[top_index])
            top_index =self.next[top_index]

# Driver Code
if__name__ ==""__main__"":
    
    # Create 3 stacks using an 
    # array of size 10.
    kstacks =KStacks(3, 10)

    # Push some items onto stack number 2.
    kstacks.push(15, 2)
    kstacks.push(45, 2)

    # Push some items onto stack number 1.
    kstacks.push(17, 1)
    kstacks.push(49, 1)
    kstacks.push(39, 1)

    # Push some items onto stack number 0.
    kstacks.push(11, 0)
    kstacks.push(9, 0)
    kstacks.push(7, 0)

    print(""Popped element from stack 2 is ""+
                         str(kstacks.pop(2)))
    print(""Popped element from stack 1 is ""+
                         str(kstacks.pop(1)))
    print(""Popped element from stack 0 is ""+
                         str(kstacks.pop(0)))

    kstacks.printstack(0)

# This code is contributed by Varun Patil
",O(1),O(N)
"# Python program to evaluate value of a postfix expression


# Class to convert the expression
classEvaluate:

    # Constructor to initialize the class variables
    def__init__(self, capacity):
        self.top =-1
        self.capacity =capacity
        
        # This array is used a stack
        self.array =[]

    # Check if the stack is empty
    defisEmpty(self):
        returnTrueifself.top ==-1elseFalse

    # Return the value of the top of the stack
    defpeek(self):
        returnself.array[-1]

    # Pop the element from the stack
    defpop(self):
        ifnotself.isEmpty():
            self.top -=1
            returnself.array.pop()
        else:
            return""$""

    # Push the element to the stack
    defpush(self, op):
        self.top +=1
        self.array.append(op)

    # The main function that converts given infix expression
    # to postfix expression
    defevaluatePostfix(self, exp):

        # Iterate over the expression for conversion
        fori inexp:

            # If the scanned character is an operand
            # (number here) push it to the stack
            ifi.isdigit():
                self.push(i)

            # If the scanned character is an operator,
            # pop two elements from stack and apply it.
            else:
                val1 =self.pop()
                val2 =self.pop()
                self.push(str(eval(val2 +i +val1)))

        returnint(self.pop())



# Driver code
if__name__ =='__main__':
    exp =""231*+9-""
    obj =Evaluate(len(exp))
    
    # Function call
    print(""postfix evaluation: %d""%(obj.evaluatePostfix(exp)))

    
# This code is contributed by Nikhil Kumar Singh(nickzuck_007)
",O(N),O(N)
"# Python program to evaluate value of a postfix
# expression with integers containing multiple digits


classevalpostfix:
    def__init__(self):
        self.stack =[]
        self.top =-1

    defpop(self):
        ifself.top ==-1:
            return
        else:
            self.top -=1
            returnself.stack.pop()

    defpush(self, i):
        self.top +=1
        self.stack.append(i)

    defcentralfunc(self, ab):
        fori inab:

            # If the component of the list is an integer
            try:
                self.push(int(i))
            
            # If the component of the list is not an integer,
            # it must be an operator. Using ValueError, we can
            # evaluate components of the list other than type int
            exceptValueError:
                val1 =self.pop()
                val2 =self.pop()
                ifi =='/':
                    self.push(val2 /val1)
                else:
                    
                    # Switch statement to perform operation
                    switcher ={'+': val2 +val1, '-': val2 -
                                val1, '*': val2 *val1, '^': val2**val1}
                    self.push(switcher.get(i))
        returnint(self.pop())



# Driver code
if__name__ =='__main__':
    str='100 200 + 2 / 5 * 7 +'
    
    # Splitting the given string to obtain
    # integers and operators into a list
    strconv =str.split(' ')
    obj =evalpostfix()
    print(obj.centralfunc(strconv))

# This code is contributed by Amarnath Reddy
",O(N),O(N)
"# Python code for the above approach:

# Function to find minimum selections
defminSelections(n):
    ans =0
    fori inrange(1, n +1):
        ans =ans +(n/i)
    returnans

# Driver's code
N =3
print('%.8f'%minSelections(N))

# This code is contributed by Pushpesh Raj.
",O(N),O(1)
"classNode:
    def__init__(self, value=None, left=None, right=None, next=None):
        self.value =value
        self.left =left
        self.right =right
        self.next=next

classStack:
    def__init__(self):
        self.head =None

    defpush(self, node):
        ifnotself.head:
            self.head =node
        else:
            node.next=self.head
            self.head =node

    defpop(self):
        ifself.head:
            popped =self.head
            self.head =self.head.next
            returnpopped
        else:
            raiseException(""Stack is empty"")

classExpressionTree:
    definorder(self, x):
        ifnotx:
            return
        self.inorder(x.left)
        print(x.value, end="" "")
        self.inorder(x.right)

defmain():
    s =""ABC*+D/""
    stack =Stack()
    tree =ExpressionTree()
    forc ins:
        ifc in""+-*/^"":
            z =Node(c)
            x =stack.pop()
            y =stack.pop()
            z.left =y
            z.right =x
            stack.push(z)
        else:
            stack.push(Node(c))
    print(""The Inorder Traversal of Expression Tree: "", end="""")
    tree.inorder(stack.pop())

if__name__ ==""__main__"":
    main()
",O(n),O(n)
"# A binary tree node
classNode:
    # Constructor to create a new node
    def__init__(self, data):
        self.data =data
        self.left =None
        self.right =None

# Binary Search Tree
classBinarySearchTree:
    # Constructor to create a new BST
    def__init__(self):
        self.root =None

    # Function to insert an element in BST
    definsertRec(self, root, data):
        # Base Case: If the tree is empty
        ifroot isNone:
            root =Node(data)
            returnroot
        # Otherwise recur down the tree
        ifdata < root.data:
            root.left =self.insertRec(root.left, data)
        elifdata > root.data:
            root.right =self.insertRec(root.right, data)
        returnroot

    # Function to insert an element in BST
    definsert(self, data):
        self.root =self.insertRec(self.root, data)

    # Function to check if pair is present
    defisPairPresent(self, root, temp, target):
        iftemp isNone:
            returnFalse
        returnself.search(root, temp, target -temp.data) or\
            self.isPairPresent(root, temp.left, target) or\
            self.isPairPresent(root, temp.right, target)

    # Function to search an element in BST
    defsearch(self, root, temp, k):
        # Base case
        ifroot isNone:
            returnFalse

        c =root
        flag =False
        whilec isnotNoneandflag ==False:
            ifc.data ==k andtemp !=c:
                flag =True
                print(""Pair Found: "", c.data, ""+"", temp.data)
                returnTrue
            elifk < c.data:
                c =c.left
            else:
                c =c.right
        returnFalse

# Driver program
if__name__ =='__main__':
    bst =BinarySearchTree()
    """"""
                    15
                /     \
            10      20
            / \     / \
            8 12 16 25 
    """"""
    bst.insert(15)
    bst.insert(10)
    bst.insert(20)
    bst.insert(8)
    bst.insert(12)
    bst.insert(16)
    bst.insert(25)

    test =bst.isPairPresent(bst.root, bst.root, 35)
    ifnottest:
        print(""No such values are found!"")
",O(N2logN),O(logN)
"# Python3 code to find a pair with given sum
# in a Balanced BST
classNode:
    
    # Construct to create a new Node
    def__init__(self, key):
        
        self.data =key
        self.left =self.right =None

# A utility function to insert a new
# Node with given key in BST
definsert(root: Node, key: int):
    
    # If the tree is empty, return a new Node
    ifroot isNone:
        returnNode(key)

    # Otherwise, recur down the tree
    ifroot.data > key:
        root.left =insert(root.left, key)

    elifroot.data < key:
        root.right =insert(root.right, key)

    # return the (unchanged) Node pointer
    returnroot

# Function that adds values of given BST into
# ArrayList and hence returns the ArrayList
deftree_to_list(root: Node, arr: list):
    
    ifnotroot:
        returnarr

    tree_to_list(root.left, arr)
    arr.append(root.data)
    tree_to_list(root.right, arr)

    returnarr

# Function that checks if there is a pair present
defisPairPresent(root: Node, target: int) -> bool:
    
    # This list a1 is passed as an argument
    # in treeToList method which is later 
    # on filled by the values of BST
    arr1 =[]
    
    # a2 list contains all the values of BST
    # returned by treeToList method
    arr2 =tree_to_list(root, arr1)
    
    # Starting index of a2
    start =0
    
    # Ending index of a2
    end =len(arr2) -1

    whilestart < end:
        
        # If target found
        ifarr2[start] +arr2[end] ==target:
            print(f""Pair Found: {arr2[start]} + {arr2[end]} = {target}"")
            returnTrue
            
        # Decrements end
        ifarr2[start] +arr2[end] > target:
            end -=1
            
        # Increments start
        ifarr2[start] +arr2[end] < target:
            start +=1

    print(""No such values are found!"")
    returnFalse

# Driver code
if__name__ ==""__main__"":
    
    root =None
    root =insert(root, 15)
    root =insert(root, 10)
    root =insert(root, 20)
    root =insert(root, 8)
    root =insert(root, 12)
    root =insert(root, 16)
    root =insert(root, 25)

    isPairPresent(root, 33)

# This code is contributed by shindesharad71
",O(n),O(n)
"#  In a balanced binary search tree
# isPairPresent two element which sums to
# a given value time O(n) space O(logn)
MAX_SIZE=100

# A BST node
classNode:
    def__init__(self,val):
        self.val =val
        self.left =self.right =None

# Stack type
classStack:
    def__init__(self):
        self.size =0
        self.top =0
        self.array =[]

# A utility function to create a stack of given size
defcreateStack(size):
    stack =Stack()
    stack.size =size
    stack.top =-1
    stack.array =[0fori inrange(stack.size)]
    returnstack

# BASIC OPERATIONS OF STACK
defisFull(stack):
    return1if(stack.top -1==stack.size) else0

defisEmpty(stack):
    return1ifstack.top ==-1else0

defpush(stack,node):
    if(isFull(stack)==1):
        return
    stack.array[stack.top+1] =node
    stack.top +=1

defpop(stack):
    if(isEmpty(stack) ==1):
        returnNone
    x =stack.array[stack.top]
    stack.top -=1
    returnx

# Returns true if a pair with target
# sum exists in BST, otherwise False
defisPairPresent(root,target):
    # Create two stacks. s1 is used for
    # normal inorder traversal and s2 is
    # used for reverse inorder traversal
    s1 =createStack(MAX_SIZE)
    s2 =createStack(MAX_SIZE)

    # Note the sizes of stacks is MAX_SIZE,
    # we can find the tree size and fix stack size
    # as O(Logn) for balanced trees like AVL and Red Black
    # tree. We have used MAX_SIZE to keep the code simple

    # done1, val1 and curr1 are used for
    # normal inorder traversal using s1
    # done2, val2 and curr2 are used for
    # reverse inorder traversal using s2
    done1,done2 =False,False
    val1,val2 =0,0
    curr1,curr2 =root,root

    # The loop will break when we either
# find a pair or one of the two
    # traversals is complete
    while(True):
    
        # Find next node in normal Inorder
        # traversal. See following post
        # https:# www.geeksforgeeks.org/inorder-tree-traversal-without-recursion/
        while(done1 ==False):
            if(curr1 !=None):
                push(s1, curr1)
                curr1 =curr1.left
            else:
                if(isEmpty(s1) ==1):
                    done1 =True
                else:
                    curr1 =pop(s1)
                    val1 =curr1.val
                    curr1 =curr1.right
                    done1 =True

        # Find next node in REVERSE Inorder traversal. The only
        # difference between above and below loop is, in below loop
        # right subtree is traversed before left subtree
        while(done2 ==False):
            if(curr2 !=None):
                push(s2, curr2)
                curr2 =curr2.right
            else:
                if(isEmpty(s2) ==1):
                    done2 =True
                else:
                    curr2 =pop(s2)
                    val2 =curr2.val
                    curr2 =curr2.left
                    done2 =True

        # If we find a pair, then print the pair and return. The first
        # condition makes sure that two same values are not added
        if((val1 !=val2) and(val1 +val2) ==target):
            print(""Pair Found: ""+str(val1)+"" + ""+str(val2)+"" = ""+str(target))
            returnTrue

        # If sum of current values is smaller,
        # then move to next node in
        # normal inorder traversal
        elif((val1 +val2) < target):
            done1 =False

        # If sum of current values is greater,
        # then move to next node in
        # reverse inorder traversal
        elif((val1 +val2) > target):
            done2 =False

        # If any of the inorder traversals is
        # over, then there is no pair
        # so return False
        if(val1 >=val2):
            returnFalse

# Driver program to test above functions

            #     15
            #     / \
            # 10 20
            # / \ / \
            # 8 12 16 25 
root =Node(15)
root.left =Node(10)
root.right =Node(20)
root.left.left =Node(8)
root.left.right =Node(12)
root.right.left =Node(16)
root.right.right =Node(25)

target =33
if(isPairPresent(root, target) ==False):
    print(""<br>No such values are found"")
    
# This code is contributed by shinjanpatra
",O(n),O(logn)
"# Python program to find circular tour for a truck

# A petrol pump has petrol and distance to next petrol pump
classpetrolPump:
    def__init__(self, petrol, distance):
        self.petrol =petrol
        self.distance =distance

# The function returns starting point if there is a
# possible solution, otherwise returns -1
defprintTour(arr, n):
    start =0

    fori inrange(n):
      
        # Identify the first petrol pump from where we
        # might get a full circular tour
        ifarr[i].petrol >=arr[i].distance:
            start =i
            break
            
    # To store the excess petrol
    curr_petrol =0
    fori inrange(start, n):
        curr_petrol +=(arr[i].petrol -arr[i].distance)

        # If at any point remaining petrol is less than 0,
        # it means that we cannot start our journey from
        # current start
        if(curr_petrol < 0):

            # We move to the next petrol pump
            i +=1

            # We try to identify the next petrol pump from
            # where we might get a full circular tour
            while(i < n):
                if(arr[i].petrol >=arr[i].distance):
                    start =i

                    # Reset rem_petrol
                    curr_petrol =0
                    break
                i +=1

        else:
            # Move to the next petrolpump if curr_petrol is
            # >= 0
            i +=1

    ''' If remaining petrol is less than 0 while we reach the
     first petrol pump, it means no circular tour is
     possible '''
    if(curr_petrol < 0):
        return-1

    fori inrange(start):
        curr_petrol +=(arr[i].petrol -arr[i].distance)

        ''' If remaining petrol is less than 0 at any point
         before we reach initial start, it means no
         circular tour is possible '''
        if(curr_petrol < 0):
            return-1

    ''' If we have successfully reached intial_start, it
     means can get a circular tour from final_start, hence
     return it '''
    returnstart

# Driver code
arr =[petrolPump(6, 4), petrolPump(3, 6), petrolPump(7, 3)]
start =printTour(arr, len(arr))
ifstart ==-1:
    print(""No solution"")
else:
    print(""Start = {}"".format(start))

# This code is contributed by jainlovely450
",O(N),O(1)
"# Python program to find circular tour for a truck

# A petrol pump has petrol and distance to next petrol pump
classpetrolPump:
    def__init__(self, petrol, distance):
        self.petrol =petrol
        self.distance =distance

# The function returns starting point if there is a
# possible solution, otherwise returns -1
defprintTour(arr, n):
    start =0

    fori inrange(n):
      
        # Identify the first petrol pump from where we
        # might get a full circular tour
        ifarr[i].petrol >=arr[i].distance:
            start =i
            break
            
    # To store the excess petrol
    curr_petrol =0
    fori inrange(start, n):
        curr_petrol +=(arr[i].petrol -arr[i].distance)

        # If at any point remaining petrol is less than 0,
        # it means that we cannot start our journey from
        # current start
        if(curr_petrol < 0):

            # We move to the next petrol pump
            i +=1

            # We try to identify the next petrol pump from
            # where we might get a full circular tour
            while(i < n):
                if(arr[i].petrol >=arr[i].distance):
                    start =i

                    # Reset rem_petrol
                    curr_petrol =0
                    break
                i +=1

        else:
            # Move to the next petrolpump if curr_petrol is
            # >= 0
            i +=1

    ''' If remaining petrol is less than 0 while we reach the
     first petrol pump, it means no circular tour is
     possible '''
    if(curr_petrol < 0):
        return-1

    fori inrange(start):
        curr_petrol +=(arr[i].petrol -arr[i].distance)

        ''' If remaining petrol is less than 0 at any point
         before we reach initial start, it means no
         circular tour is possible '''
        if(curr_petrol < 0):
            return-1

    ''' If we have successfully reached intial_start, it
     means can get a circular tour from final_start, hence
     return it '''
    returnstart

# Driver code
arr =[petrolPump(6, 4), petrolPump(3, 6), petrolPump(7, 3)]
start =printTour(arr, len(arr))
ifstart ==-1:
    print(""No solution"")
else:
    print(""Start = {}"".format(start))

# This code is contributed by jainlovely450
",O(N),O(1)
"# Python program to find circular tour for a truck

# A petrol pump has petrol and distance to next petrol pump
classpetrolPump:
    def__init__(self,a, b):
        self.petrol =a;
        self.distance =b;
    
# The function returns starting point if there is a
# possible solution, otherwise returns -1
defprintTour( p, n):

    # deficit is used to store the value of the capacity as
    # soon as the value of capacity becomes negative so as
    # not to traverse the array twice in order to get the
    # solution
    start =0;
    deficit =0;
    capacity =0;
    fori inrange(n):
        capacity +=p[i].petrol -p[i].distance;
        if(capacity < 0):
            # If this particular step is not done then the
            # between steps would be redundant
            start =i +1;
            deficit +=capacity;
            capacity =0;
        
    if(capacity +deficit >=0):
        returnstart;
    else:
        return-1;

# Driver code
if__name__ =='__main__':
    arr =[petrolPump(6, 4),petrolPump(3, 6),petrolPump(7, 3)] ;

    n =len(arr);
    start =printTour(arr, n);

    if(start ==-1):
        print(""No solution"");
    else:
        print(""Start = "", start);


# This code is contributed by Rajput-Ji 
",O(N),O(1)
"# Python program to find circular tour for a truck

# A petrol pump has petrol and distance to next petrol pump
classpetrolPump:
    def__init__(self,a, b):
        self.petrol =a;
        self.distance =b;


# The function returns starting point if there is a
# possible solution, otherwise returns -1
defprintTour( p, n):
    # storing the difference between petrol and distance
    v=[];
    fori inrange(0,n):
       v.append(p[i].petrol-p[i].distance);
    
    
    # pref array will store the difference of petrol and distance 
    # till the i'th position
    
    pref=[0]*(n);
    pref[0]=v[0];
    fori inrange(0,n):
       pref[i]=pref[i-1]+v[i];
    
    # suff array will store the difference of petrol and distance 
    # till the i'th position from the end
    
    suff=[0]*n;
    suff[n-1]=v[n-1];
    fori inrange(n-2,-1):
       suff[i]=suff[i+1]+v[i];
    
    flag=0;
    ans=-1;
    
    fori inrange(0,n):
       # when the pref array will become 0 first time then we will
       # store the next index of it
       # if the pref of i'th pos minus pref of last index where pref 
       # array became negative is less than 0
       # then we will update the ans
       
       if((ans==-1andpref[i]<0) or(ans!=-1andpref[i]-pref[ans-1]<0)):
            ans=i+1;
    
    # no index in pref array is less than 0
    if(ans==-1):
       return0;
    
    # if at i'th position pref array become 0
    elif(ans<n):
        if(pref[ans-1]+suff[ans]>=0):
            returnans;
       
    # if at n'th position pref array become 0
    elif(ans==n):
       if(suff[ans-1]+pref[ans-2]>=0):
           returnn-1;
       
    # if no index is picked as starting point
    return-1;

if__name__ =='__main__':
    arr =[petrolPump(6, 4),petrolPump(3, 6),petrolPump(7, 3)] ;
 
    n =len(arr);
    start =printTour(arr, n);
 
    if(start ==-1):
        print(""No solution"");
    else:
        print(""Start = "", start);

        # This code is contributed by ratiagrawal.
",O(N),O(1)
"classSolution():
    #Solution class carries method for printing itinerary
    def__init__(self):
        pass
    #method for printing itinerary
    defprintItinerary(self,d):
        # First step : create a reversed mapping. Here also for storing key value pairs dictionary is used.
        reverse_d =dict()
        fori ind:
            reverse_d[d[i]] =i
        # Second step : find the starting point. Starting point will be that value which is not present in 'd' as key.
        fori inreverse_d:
            ifreverse_d[i] notinreverse_d:
                starting_pt =reverse_d[i]
                break;
        #Third step : simply proceed one by one to print whole route. Assuming that there exist Starting point.
        while(starting_pt ind):
            print(starting_pt,""->"",d[starting_pt],end="", "")
            starting_pt =d[starting_pt]
        #method prints here only. Does not return anything.


if__name__==""__main__"":
    # Mapping using inbuilt data structure 'dictionary'
    d =dict()
    d[""Chennai""] =""Banglore""
    d[""Bombay""] =""Delhi""
    d[""Goa""] =""Chennai""
    d[""Delhi""] =""Goa""

    # call for method that would print itinerary.
    obj =Solution()
    obj.printItinerary(d)
",O(n),O(n)
"# A simple inorder traversal based Python3
# program to find k-th smallest element
# in a BST.

# A BST node


classNode:

    def__init__(self, key):

        self.data =key
        self.left =None
        self.right =None

# Recursive function to insert an key into BST


definsert(root, x):

    if(root ==None):
        returnNode(x)
    if(x < root.data):
        root.left =insert(root.left, x)
    elif(x > root.data):
        root.right =insert(root.right, x)
    returnroot

# Function to find k'th largest element
# in BST. Here count denotes the number
# of nodes processed so far


defkthSmallest(root):

    globalk

    # Base case
    if(root ==None):
        returnNone

    # Search in left subtree
    left =kthSmallest(root.left)

    # If k'th smallest is found in
    # left subtree, return it
    if(left !=None):
        returnleft

    # If current element is k'th
    # smallest, return it
    k -=1
    if(k ==0):
        returnroot

    # Else search in right subtree
    returnkthSmallest(root.right)

# Function to find k'th largest element in BST


defprintKthSmallest(root):

    res =kthSmallest(root)

    if(res ==None):
        print(""There are less than k nodes in the BST"")
    else:
        print(""K-th Smallest Element is "", res.data)


# Driver code
if__name__ =='__main__':

    root =None
    keys =[20, 8, 22, 4, 12, 10, 14]

    forx inkeys:
        root =insert(root, x)

    k =3

    printKthSmallest(root)

# This code is contributed by mohit kumar 29
",O(n),O(h)
"# A BST node
classNode:
    def__init__(self, x):
        self.data =x
        self.left =None
        self.right =None
        self.lCount =0

# Recursive function to insert a key into BST
definsert(root, x):
    ifroot isNone:
        returnNode(x)

    # If a node is inserted in the left subtree, then lCount of
    # this node is increased. For simplicity, we are
    # assuming that all keys (tried to be inserted) are
    # distinct.
    ifx < root.data:
        root.left =insert(root.left, x)
        root.lCount +=1
    elifx > root.data:
        root.right =insert(root.right, x)
    returnroot

# Preorder traversal function
defpreorder(root, v):
    ifroot isNone:
        return
    v.append(root.data)
    preorder(root.left, v)
    preorder(root.right, v)

# Main function
if__name__ =='__main__':
    root =None
    keys =[20, 8, 22, 4, 12, 10, 14]
    forx inkeys:
        root =insert(root, x)
    k =4
    v =[]
    preorder(root, v)

    # Sorting the given list
    v.sort()

    # Return the kth smallest element
    print(v[k-1])
",O(nlogn),O(n)
"# A simple inorder traversal based Python3
# program to find k-th smallest element in a BST.

# A BST node
classnewNode:
    
    def__init__(self, x):
        
        self.data =x
        self.left =None
        self.right =None
        self.lCount =0

# Recursive function to insert
# an key into BST
definsert(root, x):
    
    if(root ==None):
        returnnewNode(x)

    # If a node is inserted in left subtree,
    # then lCount of this node is increased. 
    # For simplicity, we are assuming that 
    # all keys (tried to be inserted) are
    # distinct. 
    if(x < root.data):
        root.left =insert(root.left, x)
        root.lCount +=1

    elif(x > root.data):
        root.right =insert(root.right, x);
        
    returnroot

# Function to find k'th largest element
# in BST. Here count denotes the number 
# of nodes processed so far
defkthSmallest(root, k):
    
    # Base case
    if(root ==None):
        returnNone
        
    count =root.lCount +1
    
    if(count ==k):
        returnroot

    if(count > k):
        returnkthSmallest(root.left, k)

    # Else search in right subtree
    returnkthSmallest(root.right, k -count)

# Driver code
if__name__ =='__main__':
    
    root =None
    keys =[ 20, 8, 22, 4, 12, 10, 14]

    forx inkeys:
        root =insert(root, x)

    k =4
    res =kthSmallest(root, k)
    
    if(res ==None):
        print(""There are less than k nodes in the BST"")
    else:
        print(""K-th Smallest Element is"", res.data)
        
# This code is contributed by bgangwar59
",O(h),O(h)
"# Python code to implement the iterative approach

# Definition of a BST node


classNode:
    def__init__(self, key):
        self.data =key
        self.left =None
        self.right =None

# Function to insert a new node in BST


definsert(root, key):
    # If the tree is empty, return a new node
    ifroot isNone:
        returnNode(key)

    # Otherwise, recur down the tree
    ifkey < root.data:
        root.left =insert(root.left, key)
    elifkey > root.data:
        root.right =insert(root.right, key)

    # Return the (unchanged) node pointer
    returnroot

# Function to find the k-th smallest
# element in BST


defkthSmallest(root, k):
    # Create an empty stack
    stack =[]

    # Loop until stack is empty or
    # k becomes zero
    whileroot isnotNoneorlen(stack) > 0:

        # Push all the left subtree
        # nodes onto the stack
        whileroot isnotNone:
            stack.append(root)
            root =root.left

        # Pop the top node from the
        # stack and check if it is
        # the k-th element
        root =stack.pop()
        k -=1

        ifk ==0:
            returnroot.data

        # Set root to the right child
        # and continue with the traversal
        root =root.right

    # If k is greater than the number
    # of nodes in BST, return -1
    return-1


# Driver Code
if__name__ =='__main__':
    root =None
    keys =[20, 8, 22, 4, 12, 10, 14]

    # Insert all the keys into BST
    forx inkeys:
        root =insert(root, x)

    k =4

    # Find the k-th smallest element in BST
    kth_smallest =kthSmallest(root, k)
    ifkth_smallest !=-1:
        print(""K-th smallest element in BST is:"", kth_smallest)
    else:
        print(""Invalid input"")
",O(h+k),O(h+k)
"# A recursive function used by longestPath. See below
# link for details
# https:#www.geeksforgeeks.org/topological-sorting/
deftopologicalSortUtil(v):
    globalStack, visited, adj
    visited[v] =True

    # Recur for all the vertices adjacent to this vertex
    # list<AdjListNode>::iterator i
    fori inadj[v]:
        if(notvisited[i[0]]):
            topologicalSortUtil(i[0])

    # Push current vertex to stack which stores topological
    # sort
    Stack.append(v)

# The function to find longest distances from a given vertex.
# It uses recursive topologicalSortUtil() to get topological
# sorting.
deflongestPath(s):
    globalStack, visited, adj, V
    dist =[-10**9fori inrange(V)]

    # Call the recursive helper function to store Topological
    # Sort starting from all vertices one by one
    fori inrange(V):
        if(visited[i] ==False):
            topologicalSortUtil(i)
    # print(Stack)

    # Initialize distances to all vertices as infinite and
    # distance to source as 0
    dist[s] =0
    # Stack.append(1)

    # Process vertices in topological order
    while(len(Stack) > 0):
      
        # Get the next vertex from topological order
        u =Stack[-1]
        delStack[-1]
        #print(u)

        # Update distances of all adjacent vertices
        # list<AdjListNode>::iterator i
        if(dist[u] !=10**9):
            fori inadj[u]:
                # print(u, i)
                if(dist[i[0]] < dist[u] +i[1]):
                    dist[i[0]] =dist[u] +i[1]

    # Print calculated longest distances
    # print(dist)
    fori inrange(V):
        print(""INF "",end="""") if (dist[i] == -10**9) else print(dist[i],end="""")

# Driver code
if__name__ =='__main__':
    V, Stack, visited =6, [], [Falsefori inrange(7)]
    adj =[[] fori inrange(7)]
    
    # Create a graph given in the above diagram.
    # Here vertex numbers are 0, 1, 2, 3, 4, 5 with
    # following mappings:
    # 0=r, 1=s, 2=t, 3=x, 4=y, 5=z
    adj[0].append([1, 5])
    adj[0].append([2, 3])
    adj[1].append([3, 6])
    adj[1].append([2, 2])
    adj[2].append([4, 4])
    adj[2].append([5, 2])
    adj[2].append([3, 7])
    adj[3].append([5, 1])
    adj[3].append([4, -1])
    adj[4].append([5, -2])

    s =1
    print(""Following are longest distances from source vertex "",s)
    longestPath(s)

    # This code is contributed by mohit kumar 29.
",O(V+E),O(V + E)
"# A python program to demonstrate find minimum on KD tree

# Number of dimensions
k =2

classNode:
    def__init__(self, point):
        self.point =point
        self.left =None
        self.right =None

# A method to create a node of K D tree
defnewNode(arr):
    temp =Node(arr)
    returntemp

# Inserts a new node and returns root of modified tree
# The parameter depth is used to decide axis of comparison
definsertRec(root, point, depth):
    # Tree is empty?
    ifroot isNone:
        returnnewNode(point)

    # Calculate current dimension (cd) of comparison
    cd =depth %k

    # Compare the new point with root on current dimension 'cd'
    # and decide the left or right subtree
    ifpoint[cd] < root.point[cd]:
        root.left =insertRec(root.left, point, depth +1)
    else:
        root.right =insertRec(root.right, point, depth +1)

    returnroot

# Function to insert a new point with given point in
# KD Tree and return new root. It mainly uses above recursive
# function ""insertRec()""
definsert(root, point):
    returninsertRec(root, point, 0)

# A utility function to find minimum of three integers
defmin_3(x, y, z):
    returnmin(x, y, z)

# Recursively finds minimum of d'th dimension in KD tree
# The parameter depth is used to determine current axis.
deffindMinRec(root, d, depth):
    # Base cases
    ifroot isNone:
        returnfloat('inf')

    # Current dimension is computed using current depth and total
    # dimensions (k)
    cd =depth %k

    # Compare point with root with respect to cd (Current dimension)
    ifcd ==d:
        ifroot.left isNone:
            returnroot.point[d]
        returnmin(root.point[d], findMinRec(root.left, d, depth +1),findMinRec(root.right, d, depth +1))

    # If current dimension is different then minimum can be anywhere
    # in this subtree
    returnmin_3(root.point[d], findMinRec(root.left, d, depth +1), findMinRec(root.right, d, depth +1))

# A wrapper over findMinRec(). Returns minimum of d'th dimension
deffindMin(root, d):
    # Pass current level or depth as 0
    returnfindMinRec(root, d, 0)

# Driver program to test above functions
if__name__ ==""__main__"":
    root =None
    points =[ [30, 40], [5, 25], [70, 70], [10, 12], [50, 30], [35, 45] ]

    n =len(points)

    fori inrange(n):
        root =insert(root, points[i])

    print(""Minimum of 0'th dimension is"", findMin(root, 0))
    print(""Minimum of 1'th dimension is"", findMin(root, 1))
    
# This code is contributed by Vikram_Shirsat
",O(k log n),O(n)
"classSolution():
    def__init__(self):
        pass

    defassignAndPrint(self,t):
        #We will directly permute over t. Access 2nd element(i.e. manager) of certain tuple and assign the relation in
        # dictionary. We will assign list of employees to a particular manager so that with iterations, we can append
        # more employees to that list and list grows.
        d =dict()
        forpair int:
            if(pair[0]==pair[1]):  # because we dont want to assign self managing role
                continue
            ifpair[0] notind:  # assign employee a empty list of employees
                d[pair[0]] =[]
            # for managers -
            ifpair[1] notind:
                d[pair[1]] =[pair[0]]
            else:
                d[pair[1]].append(pair[0])
        #print(d)
        # now we know how many employees are directly under a particular manager.
        # now lets count the total number of employees under a particular manager.
        c =dict()   # store    manager:count of employee    as key value
        formanager ind:
            c[manager] =len(d[manager])
            foremployee ind[manager]:
                c[manager] +=len(d[employee])
            print(""{} : {}"".format(manager,c[manager]))     # prints which manager has total how many employees
        # Note : Employees having no employees under are also considered as managed with 0 employees.


if__name__==""__main__"":
    # t is tuple containing employee and boss pair.
    t =((""A"", ""C""),(""B"", ""C""),(""C"", ""F""),(""D"", ""E""),(""E"", ""F""),(""F"", ""F""))
    obj =Solution()
    obj.assignAndPrint(t)
",O(n*log n),O(n)
"# Python3 program to find the maximum depth of tree

# A binary tree node


classNode:

    # Constructor to create a new node
    def__init__(self, data):
        self.data =data
        self.left =None
        self.right =None

# Compute the ""maxDepth"" of a tree -- the number of nodes
# along the longest path from the root node down to the
# farthest leaf node


defmaxDepth(node):
    ifnode isNone:
        return0

    else:

        # Compute the depth of each subtree
        lDepth =maxDepth(node.left)
        rDepth =maxDepth(node.right)

        # Use the larger one
        if(lDepth > rDepth):
            returnlDepth+1
        else:
            returnrDepth+1


# Driver program to test above function
root =Node(1)
root.left =Node(2)
root.right =Node(3)
root.left.left =Node(4)
root.left.right =Node(5)


print(""Height of tree is %d""%(maxDepth(root)))

# This code is contributed by Amit Srivastav
",O(N),O(N)
"# Python code to implement the approach

# A Tree node


classNode:

    def__init__(self):
        self.key =0
        self.left, self.right =None, None

# Utility function to create a new node


defnewNode(key):

    temp =Node()
    temp.key =key
    temp.left, temp.right =None, None
    returntemp


# Function to find the height(depth) of the tree
defheight(root):

    # Initialising a variable to count the
    # height of tree
    depth =0

    q =[]

    # appending first level element along with None
    q.append(root)
    q.append(None)
    while(len(q) > 0):
        temp =q[0]
        q =q[1:]

        # When None encountered, increment the value
        if(temp ==None):
            depth +=1

        # If None not encountered, keep moving
        if(temp !=None):
            if(temp.left):
                q.append(temp.left)

            if(temp.right):
                q.append(temp.right)

        # If queue still have elements left,
        # append None again to the queue.
        elif(len(q) > 0):
            q.append(None)
    returndepth

# Driver program


# Let us create Binary Tree shown in above example
root =newNode(1)
root.left =newNode(2)
root.right =newNode(3)

root.left.left =newNode(4)
root.left.right =newNode(5)

print(f""Height(Depth) of tree is: {height(root)}"")


# This code is contributed by shinjanpatra
",O(N),O(N)
"# Python3 program to find the height of a tree 
  
# A binary tree node 
classNode: 
  
    # Constructor to create a new node 
    def__init__(self, data): 
        self.key =data 
        self.left =None
        self.right =None
  
# Function to find height of tree 
defheight(root): 
    # Base Case 
    ifroot isNone: 
        return0
  
    # Create an empty queue for level order traversal 
    q =[] 
  
    # Enqueue Root and initialize height 
    q.append(root) 
    height =0
  
    # Loop while queue is not empty 
    whileq: 
  
        # nodeCount (queue size) indicates number of nodes 
        # at current level 
        nodeCount =len(q) 
  
        # Dequeue all nodes of current level and Enqueue all 
        # nodes of next level 
        whilenodeCount > 0: 
            node =q.pop(0) 
            ifnode.left isnotNone: 
                q.append(node.left) 
            ifnode.right isnotNone: 
                q.append(node.right) 
            nodeCount -=1
        height +=1
  
    returnheight 
  
# Driver Code 
root =Node(1) 
root.left =Node(2) 
root.right =Node(3) 
root.left.left =Node(4) 
root.left.right =Node(5) 
  
print(""Height(Depth) of tree is"", height(root))
",O(N),O(N)
"fromtyping importList


classNode:
    def__init__(self, data):
        self.data =data
        self.left =None
        self.right =None

# Give a binary search tree and a number,
# inserts a new node with the given number
# in the correct place in the tree. Returns
# the new root pointer which the caller should then use
# (the standard trick to avoid using reference parameters).


definsert(node: Node, data: int) -> Node:

    # If the tree is empty, return a new, single node
    ifnotnode:
        returnNode(data)

    # Otherwise, recur down the tree
    ifdata <=node.data:
        node.left =insert(node.left, data)
    else:
        node.right =insert(node.right, data)

    # Return the (unchanged) node pointer
    returnnode

# Given a non-empty binary search tree, inorder traversal for
# the tree is stored in the list sorted_inorder. Inorder is LEFT,ROOT,RIGHT.


definorder(node: Node, sorted_inorder: List[int]) -> None:

    ifnotnode:
        return

    # First recur on left child
    inorder(node.left, sorted_inorder)

    # Then insert the data of node
    sorted_inorder.append(node.data)

    # Now recur on right child
    inorder(node.right, sorted_inorder)


if__name__ =='__main__':
    root =None
    root =insert(root, 4)
    insert(root, 2)
    insert(root, 1)
    insert(root, 3)
    insert(root, 6)
    insert(root, 4)
    insert(root, 5)

    sorted_inorder =[]
    inorder(root, sorted_inorder)  # calling the recursive function

    # Values of all nodes will appear in sorted order in the list sorted_inorder
    print(f""Minimum value in BST is {sorted_inorder[0]}"")
",O(n),O(n)
"# Python3 program to find the node with minimum value in bst

# A binary tree node


classNode:

    # Constructor to create a new node
    def__init__(self, key):
        self.data =key
        self.left =None
        self.right =None


"""""" Give a binary search tree and a number, 
inserts a new node with the given number in 
the correct place in the tree. Returns the new 
root pointer which the caller should then use 
(the standard trick to avoid using reference 
parameters). """"""


definsert(node, data):

    # 1. If the tree is empty, return a new,
    # single node
    ifnode isNone:
        return(Node(data))

    else:
        # 2. Otherwise, recur down the tree
        ifdata <=node.data:
            node.left =insert(node.left, data)
        else:
            node.right =insert(node.right, data)

        # Return the (unchanged) node pointer
        returnnode


"""""" Given a non-empty binary search tree,  
return the minimum data value found in that 
tree. Note that the entire tree does not need 
to be searched. """"""


defminValue(node):
    current =node

    # loop down to find the leftmost leaf
    while(current.left isnotNone):
        current =current.left

    returncurrent.data


# Driver code
if__name__ =='__main__':
  root =None
  root =insert(root, 4)
  insert(root, 2)
  insert(root, 1)
  insert(root, 3)
  insert(root, 6)
  insert(root, 5)

  # Function call
  print(""\nMinimum value in BST is %d""%(minValue(root)))

# This code is contributed by Nikhil Kumar Singh(nickzuck_007)
",O(n),O(1)
"# Node class for BST
classNode:
    def__init__(self, data):
        self.data =data
        self.left =None
        self.right =None

# Function to find the minimum element in a BST
deffind_minimum(root):
    ifroot isNone:
        return-1
    whileroot.left isnotNone:  # Traverse to the leftmost node
        ifroot.left.data < root.data:
            root =root.left
        else:
            root =root.right
    returnroot.data

# Driver code
# Create a BST
root =Node(4)
root.left =Node(2)
root.right =Node(6)
root.left.left =Node(1)
root.left.right =Node(3)
root.right.left =Node(5)
root.right.right =Node(7)

# Find the minimum element in the BST
min_val =find_minimum(root)

# Print the minimum element
print(""Minimum element in the BST is:"", min_val)
",O(log n),O(1)
"# Find Missing Element
deffindMissing(arr, N):
  
    # create a list of zeroes
    temp =[0] *(N+1)

    fori inrange(0, N):
        temp[arr[i] -1] =1

    fori inrange(0, N+1):
        if(temp[i] ==0):
            ans =i +1

    print(ans)

# Driver code
if__name__ =='__main__':
    arr =[1, 2, 3, 5]
    N =len(arr)

    # Function call
    findMissing(arr, N)

    # This code is contributed by nikhilm2302
",O(N),O(N)
"# Function to get the missing number
defgetMissingNo(a, n):
    i, total =0, 1

    fori inrange(2, n +2):
        total +=i
        total -=a[i -2]
    returntotal


# Driver Code
if__name__ =='__main__':
    arr =[1, 2, 3, 5]
    N =len(arr)

    # Function call
    print(getMissingNo(arr, N))

# This code is contributed by Mohit kumar
",O(N),O(1)
"# Function to get the missing number
defgetMissingNo(a, n):
    i, total =0, 1

    fori inrange(2, n +2):
        total +=i
        total -=a[i -2]
    returntotal


# Driver Code
if__name__ =='__main__':
    arr =[1, 2, 3, 5]
    N =len(arr)

    # Function call
    print(getMissingNo(arr, N))

# This code is contributed by Mohit kumar
",O(N),O(1)
"# Python3 program to find
# the missing Number
# getMissingNo takes list as argument


defgetMissingNo(a, n):
    x1 =a[0]
    x2 =1

    fori inrange(1, n):
        x1 =x1 ^ a[i]

    fori inrange(2, n +2):
        x2 =x2 ^ i

    returnx1 ^ x2


# Driver program to test above function
if__name__ =='__main__':

    arr =[1, 2, 3, 5]
    N =len(arr)

    # Driver code
    miss =getMissingNo(arr, N)
    print(miss)

# This code is contributed by Yatin Gupta
",O(N),O(1)
"# Python3 program to check missingNo

# Function to find the missing number
defgetMissingNo(arr, n) :
    i =0;
    
    while(i < n) :
        # as array is of 1 based indexing so the
        # correct position or index number of each
        # element is element-1 i.e. 1 will be at 0th
        # index similarly 2 correct index will 1 so
        # on...
        correctpos =arr[i] -1;
        if(arr[i] < n andarr[i] !=arr[correctpos]) :
            # if array element should be lesser than
            # size and array element should not be at
            # its correct position then only swap with
            # its correct position or index value
            arr[i],arr[correctpos] =arr[correctpos], arr[i]

        else:
            # if element is at its correct position
            # just increment i and check for remaining
            # array elements
            i +=1;
            
    # check for missing element by comparing elements with their index values 
    forindex inrange(n) : 
        if(arr[index] !=index +1) :
            returnindex +1;
            
    returnn;

# Driver code
if__name__ ==""__main__"":
    arr =[ 1, 2, 3, 5];
    N =len(arr);
    print(getMissingNo(arr, N));


    # This Code is Contributed by AnkThon
",O(N),O(1)
"# Function to get the missing number
deffindMissing(a, size):

    fori inrange(0, n):
        if(abs(arr[i]) -1==size):
            continue

        ind =abs(arr[i]) -1
        arr[ind] *=-1

    ans =size +1
    fori inrange(0, n):
        if(arr[i] > 0):
            ans =i +1

    print(ans)

# Driver Code
if__name__ =='__main__':
    arr =[1, 3, 7, 5, 6, 2]
    n =len(arr)

    # Function call
    findMissing(arr, n)

    # This code is contributed by aarohirai2616.
",O(N),O(1)
"# Python program to find the element occurring
# odd number of times
    
# function to find the element occurring odd
# number of times
defgetOddOccurrence(arr, arr_size):
    
    fori inrange(0,arr_size):
        count =0
        forj inrange(0, arr_size):
            ifarr[i] ==arr[j]:
                count+=1
            
        if(count %2!=0):
            returnarr[i]
        
    return-1
    
    
# driver code 
arr =[2, 3, 5, 4, 5, 2, 4, 3, 5, 2, 4, 4, 2]
n =len(arr)
print(getOddOccurrence(arr, n))

# This code has been contributed by 
# Smitha Dinesh Semwal
",O(n^2),O(1)
"# Python3 program to find the element  
# occurring odd number of times 
 
# function to find the element 
# occurring odd number of times 
defgetOddOccurrence(arr,size):
     
    # Defining HashMap in C++
    Hash=dict()
 
    # Putting all elements into the HashMap 
    fori inrange(size):
        Hash[arr[i]]=Hash.get(arr[i],0) +1;
    
    # Iterate through HashMap to check an element
    # occurring odd number of times and return it
    fori inHash:

        if(Hash[i]%2!=0):
            returni
    return-1

 
# Driver code
arr=[2, 3, 5, 4, 5, 2, 4,3, 5, 2, 4, 4, 2]
n =len(arr)
 
# Function calling 
print(getOddOccurrence(arr, n)) 

# This code is contributed by mohit kumar
",O(n),O(n)
"# Python program to find the element occurring odd number of times

defgetOddOccurrence(arr):

    # Initialize result
    res =0
    
    # Traverse the array
    forelement inarr:
        # XOR with the result
        res =res ^ element

    returnres

# Test array
arr =[ 2, 3, 5, 4, 5, 2, 4, 3, 5, 2, 4, 4, 2]

print(""%d""%getOddOccurrence(arr))
",O(n),O(1)
"# Python 3 program to find whether an array
# is subset of another array

# Return 1 if arr2[] is a subset of
# arr1[]


defisSubset(arr1, arr2, m, n):
    i =0
    j =0
    fori inrange(n):
        forj inrange(m):
            if(arr2[i] ==arr1[j]):
                break

        # If the above inner loop was
        # not broken at all then arr2[i]
        # is not present in arr1[]
        if(j ==m):
            return0

    # If we reach here then all
    # elements of arr2[] are present
    # in arr1[]
    return1


# Driver code
if__name__ ==""__main__"":

    arr1 =[11, 1, 13, 21, 3, 7]
    arr2 =[11, 3, 7, 1]

    m =len(arr1)
    n =len(arr2)

    if(isSubset(arr1, arr2, m, n)):
        print(""arr2[] is subset of arr1[] "")
    else:
        print(""arr2[] is not a subset of arr1[]"")

# This code is contributed by ita_c
",O(m*n),O(1)
"# Python3 program to find whether an array
# is subset of another array

# Return 1 if arr2[] is a subset of arr1[]


defisSubset(arr1, arr2, m, n):
    i =0

    quickSort(arr1, 0, m-1)
    fori inrange(n):
        if(binarySearch(arr1, 0, m -1, arr2[i]) ==-1):
            return0

    # If we reach here then all elements
    # of arr2[] are present in arr1[]
    return1

# FOLLOWING FUNCTIONS ARE ONLY FOR
# SEARCHING AND SORTING PURPOSE
# Standard Binary Search function


defbinarySearch(arr, low, high, x):
    if(high >=low):
        mid =(low +high)//2

        # Check if arr[mid] is the first
        # occurrence of x.
        # arr[mid] is first occurrence if x is
        # one of the following
        # is true:
        # (i) mid == 0 and arr[mid] == x
        # (ii) arr[mid-1] < x and arr[mid] == x
        if((mid ==0orx > arr[mid-1]) and(arr[mid] ==x)):
            returnmid
        elif(x > arr[mid]):
            returnbinarySearch(arr, (mid +1), high, x)
        else:
            returnbinarySearch(arr, low, (mid -1), x)

    return-1


defpartition(A, si, ei):
    x =A[ei]
    i =(si -1)

    forj inrange(si, ei):
        if(A[j] <=x):
            i +=1
            A[i], A[j] =A[j], A[i]
    A[i +1], A[ei] =A[ei], A[i +1]
    return(i +1)

# Implementation of Quick Sort
# A[] --> Array to be sorted
# si --> Starting index
# ei --> Ending index


defquickSort(A, si, ei):
    # Partitioning index
    if(si < ei):
        pi =partition(A, si, ei)
        quickSort(A, si, pi -1)
        quickSort(A, pi +1, ei)


# Driver code
arr1 =[11, 1, 13, 21, 3, 7]
arr2 =[11, 3, 7, 1]

m =len(arr1)
n =len(arr2)

if(isSubset(arr1, arr2, m, n)):
    print(""arr2[] is subset of arr1[] "")
else:
    print(""arr2[] is not a subset of arr1[] "")


# This code is contributed by chandan_jnu
",O(mLog(m) + nlog(m)),O(n)
"# Python3 program to find whether an array
# is subset of another array

# Return 1 if arr2[] is a subset of arr1[] */


defisSubset(arr1, arr2, m, n):
    i =0
    j =0
    ifm < n:
        return0

    arr1.sort()
    arr2.sort()

    whilei < n andj < m:
        ifarr1[j] < arr2[i]:
            j +=1
        elifarr1[j] ==arr2[i]:
            j +=1
            i +=1
        elifarr1[j] > arr2[i]:
            return0
    returnFalseifi < n elseTrue


# Driver code
arr1 =[11, 1, 13, 21, 3, 7]
arr2 =[11, 3, 7, 1]

m =len(arr1)
n =len(arr2)
ifisSubset(arr1, arr2, m, n) ==True:
    print(""arr2[] is subset of arr1[] "")
else:
    printf(""arr2[] is not a subset of arr1[] "")

# This code is contributed by Shrikant13
",O(mLog(m) + nLog(n)),O(1)
"# Python3 program to find whether an array
# is subset of another array

# Return true if arr2[] is a subset
# of arr1[]


defisSubset(arr1, m, arr2, n):

    # Using STL set for hashing
    hashset =set()

    # hset stores all the values of arr1
    fori inrange(0, m):
        hashset.add(arr1[i])

    # Loop to check if all elements
    # of arr2 also lies in arr1
    fori inrange(0, n):
        ifarr2[i] inhashset:
            continue
        else:
            returnFalse

    returnTrue


# Driver Code
if__name__ =='__main__':

    arr1 =[11, 1, 13, 21, 3, 7]
    arr2 =[11, 3, 7, 1]

    m =len(arr1)
    n =len(arr2)

    if(isSubset(arr1, m, arr2, n)):
        print(""arr2[] is subset of arr1[] "")
    else:
        print(""arr2[] is not a subset of arr1[] "")

# This code is contributed by akhilsaini
",O(m+n*logm),O(m)
"# Python3 code
arr1 =[11, 1, 13, 21, 3, 7]
arr2 =[11, 3, 7, 1]
m =len(arr1)
n =len(arr2)
s =set()
fori inrange(m):
    s.add(arr1[i])

p =len(s)
fori inrange(n):
    s.add(arr2[i])

if(len(s) ==p):
    print(""arr2[] is subset of arr1[] "")

else:
    print(""arr2[] is not subset of arr1[] "")

    # This code is contributed by divyeshrabadiya07.
",O(m+n),O(n+m)
"# Python3 program to find whether an array
# is subset of another array

# Return true if arr2[] is a subset of arr1[]


defisSubset(arr1, m, arr2, n):

    # Create a Frequency Table using STL
    frequency ={}

    # Increase the frequency of each element
    # in the frequency table.
    fori inrange(0, m):
        ifarr1[i] infrequency:
            frequency[arr1[i]] =frequency[arr1[i]] +1
        else:
            frequency[arr1[i]] =1

    # Decrease the frequency if the
    # element was found in the frequency
    # table with the frequency more than 0.
    # else return 0 and if loop is
    # completed return 1.
    fori inrange(0, n):
        if(frequency[arr2[i]] > 0):
            frequency[arr2[i]] -=1
        else:
            returnFalse

    returnTrue


# Driver Code
if__name__ =='__main__':

    arr1 =[11, 1, 13, 21, 3, 7]
    arr2 =[11, 3, 7, 1]

    m =len(arr1)
    n =len(arr2)

    if(isSubset(arr1, m, arr2, n)):
        print(""arr2[] is subset of arr1[] "")
    else:
        print(""arr2[] is not a subset of arr1[] "")

# This code is contributed by akhilsaini
",O(m log (m+n)),O(m)
"# Python3 program for the above approach

# Define the Node class to create new nodes


classNode:
    def__init__(self, data):
        self.data =data
        self.left =None
        self.right =None

# Define the function to create new nodes


defnewNode(data):
    returnNode(data)

# Define the function to store the inorder traversal of the tree in a vector


defstoreInVector(root, vec):
    ifroot isNone:
        return
    storeInVector(root.left, vec)
    vec.append(root.data)
    storeInVector(root.right, vec)

# Define the function to correct the BST


defcorrectBSTUtil(root, vec, index):
    ifroot isNone:
        returnindex
    index =correctBSTUtil(root.left, vec, index)
    root.data =vec[index]
    index +=1
    index =correctBSTUtil(root.right, vec, index)
    returnindex

# Define the main function to correct the BST


defcorrectBST(root):
    # create a vector to store the inorder traversal of the given tree
    vec =[]
    storeInVector(root, vec)
    # sort the vector to obtain the correct inorder traversal of the BST
    vec.sort()
    index =0
    correctBSTUtil(root, vec, index)

# Define the function to print the inorder traversal of the tree


defprintInorder(root):
    ifroot isNone:
        return
    printInorder(root.left)
    print(root.data, end=' ')
    printInorder(root.right)


# Define the main function to run the code
if__name__ =='__main__':
    # create the original tree
    root =newNode(6)
    root.left =newNode(10)
    root.right =newNode(2)
    root.left.left =newNode(1)
    root.left.right =newNode(3)
    root.right.right =newNode(12)
    root.right.left =newNode(7)

    # print the inorder traversal of the original tree
    print(""Inorder Traversal of the original tree"")
    printInorder(root)

    # correct the BST
    correctBST(root)

    # print the inorder traversal of the fixed tree
    print(""\nInorder Traversal of the fixed tree"")
    printInorder(root)
",O(N * logN),O(N)
"# Python3 program to correct the BST  
# if two nodes are swapped 
classNode: 
    
    # Constructor to create a new node 
    def__init__(self, data):
        
        self.key =data 
        self.left =None
        self.right =None

# Utility function to track the nodes
# that we have to swap
defcorrectBstUtil(root, first, middle,
                   last, prev):
                       
    if(root):
        
        # Recur for the left sub tree
        correctBstUtil(root.left, first,
                       middle, last, prev)
                       
        # If this is the first violation, mark these 
        # two nodes as 'first and 'middle'
        if(prev[0] androot.key < prev[0].key):
            if(notfirst[0]):
                first[0] =prev[0]
                middle[0] =root
            else:
                
                # If this is the second violation,
                # mark this node as last
                last[0] =root
                
        prev[0] =root
        
        # Recur for the right subtree
        correctBstUtil(root.right, first, 
                       middle, last, prev)
    
# A function to fix a given BST where 
# two nodes are swapped. This function
# uses correctBSTUtil() to find out two
# nodes and swaps the nodes to fix the BST 
defcorrectBst(root):
    
    # Followed four lines just for forming
    # an array with only index 0 filled 
    # with None and we will update it accordingly.
    # we made it null so that we can fill 
    # node data in them.
    first =[None]
    middle =[None]
    last =[None]
    prev =[None]
    
    # Setting arrays (having zero index only) 
    # for capturing the required node
    correctBstUtil(root, first, middle,
                   last, prev)

    # Fixing the two nodes
    if(first[0] andlast[0]):
        
        # Swapping for first and last key values
        first[0].key, last[0].key =(last[0].key, 
                                    first[0].key)

    elif(first[0] andmiddle[0]):
    
        # Swapping for first and middle key values
        first[0].key, middle[0].key =(middle[0].key,
                                        first[0].key)
    
    # else tree will be fine

# Function to print inorder
# traversal of tree
defPrintInorder(root):
    
    if(root):
        PrintInorder(root.left)
        print(root.key, end ="" "")
        PrintInorder(root.right)
        
    else:
        return

# Driver code

#      6
#     /   \
#   10    2
#  / \   / \
# 1   3 7   12

# Following 7 lines are for tree formation
root =Node(6) 
root.left =Node(10) 
root.right =Node(2) 
root.left.left =Node(1) 
root.left.right =Node(3) 
root.right.left =Node(7) 
root.right.right =Node(12) 

# Printing inorder traversal of normal tree
print(""inorder traversal of normal tree"")
PrintInorder(root)
print("""")

# Function call to do the task
correctBst(root)

# Printing inorder for corrected Bst tree
print("""")
print(""inorder for corrected BST"")

PrintInorder(root)

# This code is contributed by rajutkarshai
",O(N),O(N)
"# Python program to find Floor of a given value in BST

# A Binary tree node


classNode:

    # Constructor to create a new node
    def__init__(self, data):
        self.key =data
        self.left =None
        self.right =None

# Function to find Floor of a given input in BST. If input
# is more than the max key in BST, return -1


defFloor(root, inp):

    # Base Case
    ifroot ==None:
        return-1

    # We found equal key
    ifroot.key ==inp:
        returnroot.key

    # If root's key is larger, Floor must be in left subtree
    ifroot.key > inp:
        returnFloor(root.left, inp)

    # Else, either right subtree or root has the Floor value
    else:
        floor =Floor(root.right, inp)
        # exception for -1 because it is being returned in base case
        returnfloor iffloor <=inp andfloor !=-1elseroot.key


# Driver code
if__name__ =='__main__':
    root =Node(8)

    root.left =Node(4)
    root.right =Node(12)

    root.left.left =Node(2)
    root.left.right =Node(6)

    root.right.left =Node(10)
    root.right.right =Node(14)

    fori inrange(16):
        print(i, Floor(root, i))

# This code is contributed by Shubham Singh
",O(log N),O(log N)
"# Python program to find Floor of a given value in BST

# A Binary tree node


classNode:

    # Constructor to create a new node
    def__init__(self, data):
        self.key =data
        self.left =None
        self.right =None

# Function to find Floor of a given input in BST. If input
# is more than the max key in BST, return -1


defFloor(root, inp):

    # Base Case
    ifroot ==None:
        return-1

    # We found equal key
    ifroot.key ==inp:
        returnroot.key

    # If root's key is larger, Floor must be in left subtree
    ifroot.key > inp:
        returnFloor(root.left, inp)

    # Else, either right subtree or root has the Floor value
    else:
        floor =Floor(root.right, inp)
        # exception for -1 because it is being returned in base case
        returnfloor iffloor <=inp andfloor !=-1elseroot.key


# Driver code
if__name__ =='__main__':
    root =Node(8)

    root.left =Node(4)
    root.right =Node(12)

    root.left.left =Node(2)
    root.left.right =Node(6)

    root.right.left =Node(10)
    root.right.right =Node(14)

    fori inrange(16):
        print(i, Floor(root, i))

# This code is contributed by Shubham Singh
",O(log N),O(log N)
"# Python3 program to find floor and
# ceil of a given key in BST

# A binary tree node has key,
# . left child and right child


classNode:

    def__init__(self, x):

        self.data =x
        self.left =None
        self.right =None

# Helper function to find floor and
# ceil of a given key in BST


deffloorCeilBSTHelper(root, key):

    globalfloor, ceil

    while(root):
        if(root.data ==key):
            ceil =root.data
            floor =root.data
            return
        if(key > root.data):
            floor =root.data
            root =root.right
        else:
            ceil =root.data
            root =root.left

# Display the floor and ceil of a given
# key in BST. If key is less than the min
# key in BST, floor will be -1; If key is
# more than the max key in BST, ceil will be -1;


deffloorCeilBST(root, key):

    globalfloor, ceil

    # Variables 'floor' and 'ceil'
    # are passed by reference
    floor =-1
    ceil =-1

    floorCeilBSTHelper(root, key)

    print(key, floor, ceil)


# Driver code
if__name__ =='__main__':

    floor, ceil =-1, -1

    root =Node(8)
    root.left =Node(4)
    root.right =Node(12)
    root.left.left =Node(2)
    root.left.right =Node(6)
    root.right.left =Node(10)
    root.right.right =Node(14)

    fori inrange(16):
        floorCeilBST(root, i)

# This code is contributed by mohit kumar 29
",O(log N),O(1)
"# Program to print find next palindrome
# number greater than given number.

# function to check a number is
# palindrome or not
defisPalindrome(num):
  
  # Declaring variables
  
  # storing num in n so that we can compare it later
    n =num
    rev =0

    # while num is not 0 we find its reverse and store
    # in rev
    while(num > 0):
        k =num %10
        rev =(rev *10) +k
        num =num //10

    # check if num and its reverse are same
    if(n ==rev):
        returnTrue
    else:
        returnFalse


# input number
num =9687

# start check from next num;
num =num +1

# Loop checks all numbers from given no.
# (num + 1) to next palindrome no.
while(True):
    if(isPalindrome(num)):
        break
    num =num +1

# printing the next palindrome
print(""Next Palindrome :"")
print(num)

# This code is contributed by sidharthsingh7898.
",O(num * |num|),O(1)
"# Returns next palindrome of a given number num[]. 
# This function is for input type 2 and 3 
defgenerateNextPalindromeUtil (num, n) :

    # find the index of mid digit 
    mid =int(n/2)

    # A bool variable to check if copy of left
    # side to right is sufficient or not 
    leftsmaller =False

    # end of left side is always 'mid -1' 
    i =mid -1

    # Beginning of right side depends
    # if n is odd or even 
    j =mid +1if(n %2) elsemid 

    # Initially, ignore the middle same digits 
    while(i >=0andnum[i] ==num[j]) :
        i-=1
        j+=1

    # Find if the middle digit(s) need to be
    # incremented or not (or copying left 
    # side is not sufficient) 
    if( i < 0ornum[i] < num[j]): 
        leftsmaller =True

    # Copy the mirror of left to tight 
    while(i >=0) :
    
        num[j] =num[i] 
        j+=1
        i-=1
    

    # Handle the case where middle 
    # digit(s) must be incremented. 
    # This part of code is for CASE 1 and CASE 2.2 
    if(leftsmaller ==True) :
    
        carry =1
        i =mid -1

        # If there are odd digits, then increment 
        # the middle digit and store the carry 
        if(n%2==1) :
        
            num[mid] +=carry 
            carry =int(num[mid] /10)
            num[mid] %=10
            j =mid +1
        
        else:
            j =mid 

        # Add 1 to the rightmost digit of the 
        # left side, propagate the carry 
        # towards MSB digit and simultaneously 
        # copying mirror of the left side 
        # to the right side. 
        while(i >=0) :
        
            num[i] +=carry 
            carry =int(num[i] /10)
            num[i] %=10
            num[j] =num[i] # copy mirror to right
            j+=1
            i-=1
        
# The function that prints next 
# palindrome of a given number num[] 
# with n digits. 
defgenerateNextPalindrome(num, n ) :

    print(""\nNext palindrome is:"") 

    # Input type 1: All the digits are 9, simply o/p 1 
    # followed by n-1 0's followed by 1. 
    if( AreAll9s( num, n ) ==True) :
    
        print( ""1"") 
        fori inrange(1, n): 
            print( ""0"") 
        print( ""1"") 
    

    # Input type 2 and 3 
    else:
    
        generateNextPalindromeUtil ( num, n ) 

        # print the result 
        printArray (num, n) 
    
# A utility function to check if num has all 9s 
defAreAll9s(num, n ): 
    fori inrange(1, n):
        if( num[i] !=9) :
            return0
    return1


# Utility that prints out an array on a line 
defprintArray(arr, n): 

    fori inrange(0, n): 
        print(int(arr[i]),end="" "") 
    print() 


# Driver Program to test above function 
if__name__ ==""__main__"":
    num =[9, 4, 1, 8, 7, 9, 7, 8, 3, 2, 2]
    n =len(num)
    generateNextPalindrome( num, n ) 

# This code is contributed by Smitha Dinesh Semwal
",O(num),O(1)
"importstring

# An efficient program to print all anagrams together

NO_OF_CHARS =26

# Structure to represent list node for indexes of words in
# the given sequence. The list nodes are used to connect
# anagrams at leaf nodes of Trie
classIndexNode:
    def__init__(self, index):
        self.index =index
        self.next=None

# Structure to represent a Trie Node
classTrieNode:
    def__init__(self):
        self.isEnd =False
        self.child =[None]*NO_OF_CHARS
        self.head =None

# A utility function to create a new Trie node
defnewTrieNode():
    returnTrieNode()

# A utility function to insert a word to Trie
definsert(root, word, index):
    # Base case
    ifroot isNone:
        root =newTrieNode()

    iflen(word) > 0:
        root.child[string.ascii_lowercase.index(word[0])] =insert(root.child[string.ascii_lowercase.index(word[0])], word[1:], index)
    else:  # If end of the word reached
        # Insert index of this word to end of index linked list
        ifroot.isEnd:
            pCrawl =root.head
            whilepCrawl.next:
                pCrawl =pCrawl.next
            pCrawl.next=IndexNode(index)
        else:  # If Index list is empty
            root.isEnd =True
            root.head =IndexNode(index)
    returnroot

# This function traverses the built trie. When a leaf node is reached,
# all words connected at that leaf node are anagrams. So it traverses
# the list at leaf node and uses stored index to print original words
defprintAnagramsUtil(root, wordArr):
    ifroot isNone:
        return

    # If a lead node is reached, print all anagrams using the indexes
    # stored in index linked list
    ifroot.isEnd:
        # traverse the list
        pCrawl =root.head
        whilepCrawl isnotNone:
            print(wordArr[pCrawl.index])
            pCrawl =pCrawl.next

    fori inrange(NO_OF_CHARS):
        printAnagramsUtil(root.child[i], wordArr)

#The main function that prints all anagrams together. wordArr[] is input sequence of words.
defprintAnagramsTogether(wordArr, size):
    # Create an empty Trie
    root =newTrieNode()
    # Iterate through all input words
    fori inrange(size):
        # Create a buffer for this word and copy the word to buffer
        word =''.join(sorted(wordArr[i].lower()))
        insert(root, word, i)

    printAnagramsUtil(root, wordArr)

#Driver program to test above functions
if__name__ ==""__main__"":
    wordArr =[""cat"", ""tac"", ""act"", ""dog"", ""god"", ""gdo""]
    size =len(wordArr)
    printAnagramsTogether(wordArr, size)
",O(MN+N*MlogM),O(MN)
"# A simple Python 3 program to find sum 
# of all subsquares of size k x k

# Size of given matrix
n =5

# A simple function to find sum of all 
# sub-squares of size k x k in a given
# square matrix of size n x n
defprintSumSimple(mat, k):

    # k must be smaller than or equal to n
    if(k > n):
        return

    # row number of first cell in current
    # sub-square of size k x k
    fori inrange(n -k +1):
    
        # column of first cell in current 
        # sub-square of size k x k
        forj inrange(n -k +1):
            
            # Calculate and print sum of 
            # current sub-square
            sum=0
            forp inrange(i, k +i):
                forq inrange(j, k +j):
                    sum+=mat[p][q]
            print(sum, end ="" "")
    
        # Line separator for sub-squares 
        # starting with next row
        print()

# Driver Code
if__name__ ==""__main__"":

    mat =[[1, 1, 1, 1, 1],
           [2, 2, 2, 2, 2],
           [3, 3, 3, 3, 3],
           [4, 4, 4, 4, 4],
           [5, 5, 5, 5, 5]]
    k =3
    printSumSimple(mat, k)

# This code is contributed by ita_c
",O(k2n2),O(1)
"# An efficient Python3 program to find sum 
# of all subsquares of size k x k 

# A O(n^2) function to find sum of all  
# sub-squares of size k x k in a given 
# square matrix of size n x n 
defprintSumTricky(mat, k):
    globaln
    
    # k must be smaller than or 
    # equal to n 
    ifk > n:
        return

    # 1: PREPROCESSING 
    # To store sums of all strips of size k x 1 
    stripSum =[[None] *n fori inrange(n)]

    # Go column by column
    forj inrange(n):
        
        # Calculate sum of first k x 1 
        # rectangle in this column 
        Sum=0
        fori inrange(k):
            Sum+=mat[i][j] 
        stripSum[0][j] =Sum

        # Calculate sum of remaining rectangles
        fori inrange(1, n -k +1):
            Sum+=(mat[i +k -1][j] -
                    mat[i -1][j]) 
            stripSum[i][j] =Sum

    # 2: CALCULATE SUM of Sub-Squares
    # using stripSum[][]
    fori inrange(n -k +1):
        
        # Calculate and print sum of first 
        # subsquare in this row 
        Sum=0
        forj inrange(k):
            Sum+=stripSum[i][j] 
        print(Sum, end ="" "")

        # Calculate sum of remaining squares 
        # in current row by removing the leftmost  
        # strip of previous sub-square and adding
        # a new strip
        forj inrange(1, n -k +1):
            Sum+=(stripSum[i][j +k -1] -
                    stripSum[i][j -1]) 
            print(Sum, end ="" "")

        print()

# Driver Code
n =5
mat =[[1, 1, 1, 1, 1],
       [2, 2, 2, 2, 2], 
       [3, 3, 3, 3, 3],
       [4, 4, 4, 4, 4],
       [5, 5, 5, 5, 5]] 
k =3
printSumTricky(mat, k) 

# This code is contributed by PranchalK
",O(n2),O(n2)
"# Python program for solution of
# hamiltonian cycle problem

classGraph():
    def__init__(self, vertices):
        self.graph =[[0forcolumn inrange(vertices)]
                            forrow inrange(vertices)]
        self.V =vertices

    ''' Check if this vertex is an adjacent vertex
        of the previously added vertex and is not
        included in the path earlier '''
    defisSafe(self, v, pos, path):
        # Check if current vertex and last vertex
        # in path are adjacent
        ifself.graph[ path[pos-1] ][v] ==0:
            returnFalse

        # Check if current vertex not already in path
        forvertex inpath:
            ifvertex ==v:
                returnFalse

        returnTrue

    # A recursive utility function to solve
    # hamiltonian cycle problem
    defhamCycleUtil(self, path, pos):

        # base case: if all vertices are
        # included in the path
        ifpos ==self.V:
            # Last vertex must be adjacent to the
            # first vertex in path to make a cycle
            ifself.graph[ path[pos-1] ][ path[0] ] ==1:
                returnTrue
            else:
                returnFalse

        # Try different vertices as a next candidate
        # in Hamiltonian Cycle. We don't try for 0 as
        # we included 0 as starting point in hamCycle()
        forv inrange(1,self.V):

            ifself.isSafe(v, pos, path) ==True:

                path[pos] =v

                ifself.hamCycleUtil(path, pos+1) ==True:
                    returnTrue

                # Remove current vertex if it doesn't
                # lead to a solution
                path[pos] =-1

        returnFalse

    defhamCycle(self):
        path =[-1] *self.V

        ''' Let us put vertex 0 as the first vertex
            in the path. If there is a Hamiltonian Cycle,
            then the path can be started from any point
            of the cycle as the graph is undirected '''
        path[0] =0

        ifself.hamCycleUtil(path,1) ==False:
            print(""Solution does not exist\n"")
            returnFalse

        self.printSolution(path)
        returnTrue

    defprintSolution(self, path):
        print(""Solution Exists: Following"",
                 ""is one Hamiltonian Cycle"")
        forvertex inpath:
            print(vertex, end ="" "")
        print(path[0], ""\n"")

# Driver Code

''' Let us create the following graph
    (0)--(1)--(2)
    | / \ |
    | / \ |
    | /     \ |
    (3)-------(4) '''
g1 =Graph(5)
g1.graph =[ [0, 1, 0, 1, 0], [1, 0, 1, 1, 1],
            [0, 1, 0, 0, 1,],[1, 1, 0, 0, 1],
            [0, 1, 1, 1, 0], ]

# Print the solution
g1.hamCycle();

''' Let us create the following graph
    (0)--(1)--(2)
    | / \ |
    | / \ |
    | /     \ |
    (3)     (4) '''
g2 =Graph(5)
g2.graph =[ [0, 1, 0, 1, 0], [1, 0, 1, 1, 1],
        [0, 1, 0, 0, 1,], [1, 1, 0, 0, 0],
        [0, 1, 1, 0, 0], ]

# Print the solution
g2.hamCycle();

# This code is contributed by Divyanshu Mehta
",O(N!),O(1)
"# Python program for implementation of heap Sort

# To heapify subtree rooted at index i.
# n is size of heap


defheapify(arr, N, i):
    largest =i  # Initialize largest as root
    l =2*i +1# left = 2*i + 1
    r =2*i +2# right = 2*i + 2

    # See if left child of root exists and is
    # greater than root
    ifl < N andarr[largest] < arr[l]:
        largest =l

    # See if right child of root exists and is
    # greater than root
    ifr < N andarr[largest] < arr[r]:
        largest =r

    # Change root, if needed
    iflargest !=i:
        arr[i], arr[largest] =arr[largest], arr[i]  # swap

        # Heapify the root.
        heapify(arr, N, largest)

# The main function to sort an array of given size


defheapSort(arr):
    N =len(arr)

    # Build a maxheap.
    fori inrange(N//2-1, -1, -1):
        heapify(arr, N, i)

    # One by one extract elements
    fori inrange(N-1, 0, -1):
        arr[i], arr[0] =arr[0], arr[i]  # swap
        heapify(arr, i, 0)


# Driver's code
if__name__ =='__main__':
    arr =[12, 11, 13, 5, 6, 7]

    # Function call
    heapSort(arr)
    N =len(arr)

    print(""Sorted array is"")
    fori inrange(N):
        print(""%d""%arr[i], end="" "")
# This code is contributed by Mohit Kumra
",O(N log N),O(log n)
"classPoint:
    def__init__(self, x, y):
        self.x =x
        self.y =y

classline:
    def__init__(self, p1, p2):
        self.p1 =p1
        self.p2 =p2

defonLine(l1, p):
    # Check whether p is on the line or not
    if(
        p.x <=max(l1.p1.x, l1.p2.x)
        andp.x >=min(l1.p1.x, l1.p2.x)
        and(p.y <=max(l1.p1.y, l1.p2.y) andp.y >=min(l1.p1.y, l1.p2.y))
    ):
        returnTrue
    returnFalse

defdirection(a, b, c):
    val =(b.y -a.y) *(c.x -b.x) -(b.x -a.x) *(c.y -b.y)
    ifval ==0:
        # Collinear
        return0
    elifval < 0:
        # Anti-clockwise direction
        return2
    # Clockwise direction
    return1

defisIntersect(l1, l2):
    # Four direction for two lines and points of other line
    dir1 =direction(l1.p1, l1.p2, l2.p1)
    dir2 =direction(l1.p1, l1.p2, l2.p2)
    dir3 =direction(l2.p1, l2.p2, l1.p1)
    dir4 =direction(l2.p1, l2.p2, l1.p2)

    # When intersecting
    ifdir1 !=dir2 anddir3 !=dir4:
        returnTrue

    # When p2 of line2 are on the line1
    ifdir1 ==0andonLine(l1, l2.p1):
        returnTrue

    # When p1 of line2 are on the line1
    ifdir2 ==0andonLine(l1, l2.p2):
        returnTrue

    # When p2 of line1 are on the line2
    ifdir3 ==0andonLine(l2, l1.p1):
        returnTrue

    # When p1 of line1 are on the line2
    ifdir4 ==0andonLine(l2, l1.p2):
        returnTrue

    returnFalse

defcheckInside(poly, n, p):
    # When polygon has less than 3 edge, it is not polygon
    ifn < 3:
        returnFalse

    # Create a point at infinity, y is same as point p
    exline =line(p, Point(9999, p.y))
    count =0
    i =0
    whileTrue:
        # Forming a line from two consecutive points of poly
        side =line(poly[i], poly[(i +1) %n])
        ifisIntersect(side, exline):
            # If side is intersects ex
            if(direction(side.p1, p, side.p2) ==0):
                returnonLine(side, p);
            count +=1
        
        i =(i +1) %n;
        ifi ==0:
            break

    # When count is odd
    returncount & 1;


# Driver code
polygon =[  Point( 0, 0), Point( 10, 0), Point( 10, 10), Point( 0, 10) ];
p =Point( 5, 3);
n =4;

# Function call
if(checkInside(polygon, n, p)):
    print(""Point is inside."")
else:
    print(""Point is outside."")
",O(n),O(1)
"# A Huffman Tree Node 
importheapq 
 
 
classnode: 
    def__init__(self, freq, symbol, left=None, right=None): 
        # frequency of symbol 
        self.freq =freq 
 
        # symbol name (character) 
        self.symbol =symbol 
 
        # node left of current node 
        self.left =left 
 
        # node right of current node 
        self.right =right 
 
        # tree direction (0/1) 
        self.huff ='' 
 
    def__lt__(self, nxt): 
        returnself.freq < nxt.freq 
 
 
# utility function to print huffman 
# codes for all symbols in the newly 
# created Huffman tree 
defprintNodes(node, val=''): 
 
    # huffman code for current node 
    newVal =val +str(node.huff) 
 
    # if node is not an edge node 
    # then traverse inside it 
    if(node.left): 
        printNodes(node.left, newVal) 
    if(node.right): 
        printNodes(node.right, newVal) 
 
        # if node is edge node then 
        # display its huffman code 
    if(notnode.left andnotnode.right): 
        print(f""{node.symbol} -> {newVal}"") 
 
 
# characters for huffman tree 
chars =['a', 'b', 'c', 'd', 'e', 'f'] 
 
# frequency of characters 
freq =[5, 9, 12, 13, 16, 45] 
 
# list containing unused nodes 
nodes =[] 
 
# converting characters and frequencies 
# into huffman tree nodes 
forx inrange(len(chars)): 
    heapq.heappush(nodes, node(freq[x], chars[x])) 
 
whilelen(nodes) > 1: 
 
    # sort all the nodes in ascending order 
    # based on their frequency 
    left =heapq.heappop(nodes) 
    right =heapq.heappop(nodes) 
 
    # assign directional value to these nodes 
    left.huff =0
    right.huff =1
 
    # combine the 2 smallest nodes to create 
    # new node as their parent 
    newNode =node(left.freq+right.freq, left.symbol+right.symbol, left, right) 
 
    heapq.heappush(nodes, newNode) 
 
# Huffman Tree is ready! 
printNodes(nodes[0]) 
",O(nlogn),O(N)
"# Trie Node.
classTrieNode:
    def__init__(self):
        self.isLeaf =False
        self.URL =None
        self.child =[None]*11

# Function to create a new trie node.
defnewTrieNode():
    returnTrieNode()

# A utility function to find index of child for a given character 'c'
defgetIndex(c):
    ifc =='.':
        return10
    else:
        returnord(c) -ord('0')

# A utility function to find character for a given child index.
defgetCharFromIndex(i):
    ifi ==10:
        return'.'
    else:
        returnchr(i +ord('0'))

# This method inserts an ip address and the corresponding
# domain name in the trie. The last node in Trie contains the URL.
definsert(root, ipAdd, URL):
    # Length of the ip address
    len_ipAdd =len(ipAdd)
    pCrawl =root

    # Traversing over the length of the ip address.
    forlevel inrange(len_ipAdd):
        # Get index of child node from current character
        # in ipAdd[].  Index must be from 0 to 10 where
        # 0 to 9 is used for digits and 10 for dot
        index =getIndex(ipAdd[level])

        # Create a new child if not exist already
        ifnotpCrawl.child[index]:
            pCrawl.child[index] =newTrieNode()

        # Move to the child
        pCrawl =pCrawl.child[index]

    #Below needs to be carried out for the last node.
    #Save the corresponding URL of the ip address in the
    #last node of trie.
    pCrawl.isLeaf =True
    pCrawl.URL =URL

# This function returns URL if given IP address is present in DNS cache.
# Else returns None
defsearchDNSCache(root, ipAdd):
    # Root node of trie.
    pCrawl =root
    len_ipAdd =len(ipAdd)

    # Traversal over the length of ip address.
    forlevel inrange(len_ipAdd):
        index =getIndex(ipAdd[level])
        ifnotpCrawl.child[index]:
            returnNone
        pCrawl =pCrawl.child[index]

    # If we find the last node for a given ip address, print the URL.
    ifpCrawl andpCrawl.isLeaf:
        returnpCrawl.URL

    returnNone

#Driver function.
if__name__ ==""__main__"":
    # Change third ipAddress for validation
    ipAdd =[""107.108.11.123"", ""107.109.123.255"", ""74.125.200.106""]
    URL =[""www.samsung.com"", ""www.samsung.net"", ""www.google.in""]
    n =len(ipAdd)
    root =newTrieNode()

    # Inserts all the ip address and their corresponding
    # domain name after ip address validation.
    fori inrange(n):
        insert(root, ipAdd[i], URL[i])


    # If reverse DNS look up succeeds print the domain
    # name along with the IP address.
    ip =""107.108.11.123""
    name =searchDNSCache(root, ip)
    ifname !=None:
        print(""Reverse DNS look up resolved in cache:\n""+ip +"" --> ""+name)
    else:
        print(""Reverse DNS look up failed for ""+ip)
",O(k),O(nm)
"classTrieNode:
    def__init__(self):
        self.child ={}
        self.url =""""

    def__str__(self):
        returnstr(self.child) +"" : ""+self.url


classReverseDNSLookup:
    definsert(self, node, ipAdd, urls):
        fori inrange(len(ipAdd)):
            self.insertUtil(node, ipAdd[i], urls[i], 0)

    definsertUtil(self, node, ipAddr, url, pos):
        temp =None
        ifipAddr[pos] innode.child:
            temp =node.child[ipAddr[pos]]
        else:
            temp =TrieNode()
            node.child[ipAddr[pos]] =temp
        ifpos ==len(ipAddr) -1:
            temp.url =url
            return
        self.insertUtil(temp, ipAddr, url, pos +1)

    defsearch(self, node, ipAddr, pos):
        temp =None
        ifpos ==len(ipAddr) -1:
            temp =node.child.get(ipAddr[pos])
            iftemp:
                returntemp.url
        ifipAddr[pos] innode.child:
            temp =node.child[ipAddr[pos]]
            returnself.search(temp, ipAddr, pos +1)
        return""No url associated/Invalid IP address""


defmain():
    r =ReverseDNSLookup()
    ipAdd =[""107.108.11.123"", ""107.109.123.255"", ""74.125.200.106""]
    urls =[""www.samsung.com"", ""www.samsung.net"", ""www.google.in""]

    root =TrieNode()
    r.insert(root, ipAdd, urls)
    print(""74.125.200.106 : ""+r.search(root, ""74.125.200.106"", 0))
    print(""107.109.123.245 : ""+r.search(root, ""107.109.123.245"", 0))

if__name__ ==""__main__"":
    main()
",O(1),O(nm)
"# Trie Node
classTrieNode:
    def__init__(self):
        self.child =[None] *11
        self.url =None
        self.is_end =False

classTrie:
    def__init__(self):
        self.root =TrieNode()
    
    defgetIndex(self, c):
        # For the . (dot) in IP address, we'll use the 10th index in child list
        return10ifc =='.'elseint(c)
    
    definsert(self, ip, domain):
        cur =self.root
        n =len(ip)
        
        forlevel inrange(n):
            # We'll use the digits of IP address to form the trie structure
            idx =self.getIndex(ip[level])
            
            ifcur.child[idx] isNone:
                # Create a new trie node if not available for a particular digit
                # and assign to the respective index
                cur.child[idx] =TrieNode()
                
            cur =cur.child[idx]
        
        # At the end, we'll map the domain name and mark the end node
        cur.url =domain
        cur.is_end =True
    
    defsearch_domain(self, ip):
        cur =self.root
        n =len(ip)
        
        # Traverse through the trie structure with all digits in ip address
        forlevel inrange(n):
            idx =self.getIndex(ip[level])
            ifcur.child[idx] isNone:
                return""Domain name not found""
            
            cur =cur.child[idx]
        
        # Returns the url when all the digits in ip found
        ifcur andcur.url:
            returncur.url
        
        return""Domain name not found""

# Driver Code
ip =[""107.108.11.123"", ""107.109.123.255"", ""74.125.200.106""]
domain =[""www.samsung.com"", ""www.samsung.net"", ""www.google.co.in""]

trie =Trie()
foridx inrange(len(ip)):
    trie.insert(ip[idx], domain[idx])

print(trie.search_domain(""107.109.123.255""))
print(trie.search_domain(""107.109.123.245""))

# This code is contributed by Abhilash Pujari
",O(nm),O(k * n)
"# Program to implement a stack using
# two queue
from_collections importdeque


classStack:

    def__init__(self):

        # Two inbuilt queues
        self.q1 =deque()
        self.q2 =deque()

    defpush(self, x):

        # Push x first in empty q2
        self.q2.append(x)

        # Push all the remaining
        # elements in q1 to q2.
        while(self.q1):
            self.q2.append(self.q1.popleft())

        # swap the names of two queues
        self.q1, self.q2 =self.q2, self.q1

    defpop(self):

        # if no elements are there in q1
        ifself.q1:
            self.q1.popleft()

    deftop(self):
        if(self.q1):
            returnself.q1[0]
        returnNone

    defsize(self):
        returnlen(self.q1)


# Driver Code
if__name__ =='__main__':
    s =Stack()
    s.push(1)
    s.push(2)
    s.push(3)

    print(""current size: "", s.size())
    print(s.top())
    s.pop()
    print(s.top())
    s.pop()
    print(s.top())

    print(""current size: "", s.size())

# This code is contributed by PranchalK
",O(1),O(N)
"# Program to implement a stack using
# two queue
from_collections importdeque


classStack:

    def__init__(self):

        # Two inbuilt queues
        self.q1 =deque()
        self.q2 =deque()

    defpush(self, x):
        self.q1.append(x)

    defpop(self):
        # if no elements are there in q1
        if(notself.q1):
            return
        # Leave one element in q1 and push others in q2
        while(len(self.q1) !=1):
            self.q2.append(self.q1.popleft())

        # swap the names of two queues
        self.q1, self.q2 =self.q2, self.q1

    deftop(self):
        # if no elements are there in q1
        if(notself.q1):
            return
        # Leave one element in q1 and push others in q2
        while(len(self.q1) !=1):
            self.q2.append(self.q1.popleft())

        # Pop the only left element from q1 to q2
        top =self.q1[0]
        self.q2.append(self.q1.popleft())

        # swap the names of two queues
        self.q1, self.q2 =self.q2, self.q1

        returntop

    defsize(self):
        returnlen(self.q1)


# Driver Code
if__name__ =='__main__':
    s =Stack()
    s.push(1)
    s.push(2)
    s.push(3)

    print(""current size: "", s.size())
    print(s.top())
    s.pop()
    print(s.top())
    s.pop()
    print(s.top())

    print(""current size: "", s.size())

# This code is contributed by jainlovely450
",O(n),O(N)
"from_collections importdeque

# Stack Class that acts as a queue


classStack:
    def__init__(self):
        self.q =deque()

    # Push operation
    defpush(self, data):
        # Get previous size of queue
        s =len(self.q)

        # Push the current element
        self.q.append(data)

        # Pop all the previous elements and put them after
        # current element
        fori inrange(s):
            self.q.append(self.q.popleft())

    # Removes the top element
    defpop(self):
        if(notself.q):
            print(""No elements"")
        else:
            self.q.popleft()

    # Returns top of stack
    deftop(self):
        if(notself.q):
            return
        returnself.q[0]

    defsize(self):
        returnlen(self.q)


if__name__ =='__main__':
    st =Stack()
    st.push(1)
    st.push(2)
    st.push(3)
    print(""current size: "", st.size())
    print(st.top())
    st.pop()
    print(st.top())
    st.pop()
    print(st.top())
    print(""current size: "", st.size())
",O(N),O(N)
"from_collections importdeque

# Stack Class that acts as a queue


classStack:
    def__init__(self):
        self.q =deque()

    # Push operation
    defpush(self, data, c):

        # Push the current element
        self.q.append(data)

        # Return if size becomes 0
        ifc <=0:
            return

        # Store and then pop the current front
        x =self.q.popleft()

        # Decrement size by 1 in every recursion
        c =c-1
        self.push(x, c)

    # Removes the top element
    defpop(self):
        if(notself.q):
            print(""No elements"")
        else:
            self.q.popleft()

    # Returns top of stack
    deftop(self):
        if(notself.q):
            return
        returnself.q[0]

    defsize(self):
        returnlen(self.q)


if__name__ =='__main__':
    st =Stack()
    st.push(1, st.size())
    st.push(2, st.size())
    st.push(3, st.size())
    print(""current size: "", st.size())
    print(st.top())
    st.pop()
    print(st.top())
    st.pop()
    print(st.top())
    print(""current size: "", st.size())

# This code is contributed by Susobhan Akhuli
",O(1),O(N)
"# Python Script to Implement two stacks in a list 
importmath 
 
 
classtwoStacks: 
 
    def__init__(self, n):     # constructor 
        self.size =n 
        self.arr =[None] *n 
        self.top1 =math.floor(n/2) +1
        self.top2 =math.floor(n/2) 
 
    # Method to push an element x to stack1 
 
    defpush1(self, x): 
 
        # There is at least one empty space for new element 
        ifself.top1 > 0: 
            self.top1 =self.top1 -1
            self.arr[self.top1] =x 
        else: 
            print(""Stack Overflow by element : "", x) 
 
    # Method to push an element x to stack2 
 
    defpush2(self, x): 
 
        # There is at least one empty space for new element 
        ifself.top2 < self.size -1: 
            self.top2 =self.top2 +1
            self.arr[self.top2] =x 
        else: 
            print(""Stack Overflow by element : "", x) 
 
    # Method to pop an element from first stack 
 
    defpop1(self): 
        ifself.top1 <=self.size/2: 
            x =self.arr[self.top1] 
            self.top1 =self.top1 +1
            returnx 
        else: 
            print(""Stack Underflow"") 
            exit(1) 
 
    # Method to pop an element from second stack 
 
    defpop2(self): 
        ifself.top2 >=math.floor(self.size/2) +1: 
            x =self.arr[self.top2] 
            self.top2 =self.top2 -1
            returnx 
        else: 
            print(""Stack Underflow"") 
            exit(1) 
 
 
# Driver program to test twoStacks class 
if__name__ =='__main__': 
    ts =twoStacks(5) 
    ts.push1(5) 
    ts.push2(10) 
    ts.push2(15) 
    ts.push1(11) 
    ts.push2(7) 
     
    print(""Popped element from stack1 is : ""+str(ts.pop1())) 
    ts.push2(40) 
    print(""Popped element from stack2 is : ""+str(ts.pop2())) 
 
# This code is contributed by Gautam goel 
",O(1),O(N)
"# Python implementation of De-queue using circular
# array

# A structure to represent a Deque
MAX=100


classDeque:
    def__init__(self, size):
        self.arr =[0] *MAX
        self.front =-1
        self.rear =0
        self.size =size

    ''' Operations on Deque:
    void  insertfront(int key);
    void  insertrear(int key);
    void  deletefront();
    void  deleterear();
    bool  isFull();
    bool  isEmpty();
    int  getFront();
    int  getRear(); '''

    # Checks whether Deque is full or not.
    defisFull(self):
        return((self.front ==0andself.rear ==self.size-1) orself.front ==self.rear +1)

    # Checks whether Deque is empty or not.

    defisEmpty(self):
        return(self.front ==-1)

    # Inserts an element at front
    definsertfront(self, key):

        # check whether Deque if  full or not
        if(self.isFull()):
            print(""Overflow"")
            return

        # If queue is initially empty
        if(self.front ==-1):
            self.front =0
            self.rear =0

        # front is at first position of queue
        elif(self.front ==0):
            self.front =self.size -1

        else:  # decrement front end by '1'
            self.front =self.front-1

        # insert current element into Deque
        self.arr[self.front] =key

    # function to inset element at rear end
    # of Deque.

    definsertrear(self, key):
        if(self.isFull()):
            print("" Overflow"")
            return

        # If queue is initially empty
        if(self.front ==-1):
            self.front =0
            self.rear =0

        # rear is at last position of queue
        elif(self.rear ==self.size-1):
            self.rear =0

        # increment rear end by '1'
        else:
            self.rear =self.rear+1

        # insert current element into Deque
        self.arr[self.rear] =key

    # Deletes element at front end of Deque

    defdeletefront(self):
        # check whether Deque is empty or not
        if(self.isEmpty()):
            print(""Queue Underflow"")
            return

        # Deque has only one element
        if(self.front ==self.rear):
            self.front =-1
            self.rear =-1

        else:
            # back to initial position
            if(self.front ==self.size -1):
                self.front =0

            else:  # increment front by '1' to remove current
                # front value from Deque
                self.front =self.front+1

    # Delete element at rear end of Deque

    defdeleterear(self):
        if(self.isEmpty()):
            print("" Underflow"")
            return

        # Deque has only one element
        if(self.front ==self.rear):
            self.front =-1
            self.rear =-1

        elif(self.rear ==0):
            self.rear =self.size-1
        else:
            self.rear =self.rear-1

    # Returns front element of Deque

    defgetFront(self):
        # check whether Deque is empty or not
        if(self.isEmpty()):
            print("" Underflow"")
            return-1

        returnself.arr[self.front]

    # function return rear element of Deque

    defgetRear(self):
        # check whether Deque is empty or not
        if(self.isEmpty() orself.rear < 0):
            print("" Underflow"")
            return-1

        returnself.arr[self.rear]


# Driver code
if__name__ ==""__main__"":
  dq =Deque(5)

  # Function calls
  print(""Insert element at rear end  : 5 "")
  dq.insertrear(5)

  print(""insert element at rear end : 10 "")
  dq.insertrear(10)

  print(f""get rear element : {dq.getRear()}"")

  dq.deleterear()
  print(f""After delete rear element new rear become : {dq.getRear()}"")

  print(""inserting element at front end"")
  dq.insertfront(15)

  print(f""get front element: {dq.getFront()}"")

  dq.deletefront()

  print(f""After delete front element new front become : {dq.getFront()}"")

# This code is contributed by _saurabh_jaiswal
",O(N),O(N)
"# Python program for In-place conversion of Sorted DLL to Balanced BST
classNode:
    def__init__(self, data):
        self.data =data
        self.next=None
        self.prev =None


classLinkedList:
    def__init__(self):
        self.head =None

    # This function counts the number of nodes in Linked List
    # and then calls sortedListToBSTRecur() to construct BST 
    defsortedListToBST(self):
        # Count the number of nodes in Linked List 
        n =self.countNodes(self.head)
        
        # Construct BST 
        returnself.sortedListToBSTRecur(n)

    # The main function that constructs balanced BST and returns 
    # root of it. n  --> No. of nodes in the Doubly Linked List
    defsortedListToBSTRecur(self, n):
        # base case
        ifn <=0:  
            returnNone

        # Recursively construct the left subtree
        left =self.sortedListToBSTRecur(n //2)

        # head_ref now refers to middle node, make middle node as root of BST
        root =self.head 

        # Set pointer to left subtree
        root.prev =left 

        # Change head pointer of Linked List for parent recursive calls
        self.head =self.head.next

        # Recursively construct the right subtree and link it
        #   with root. The number of nodes in right subtree  is
        #   total nodes - nodes in left subtree - 1 (for root)
        root.next=self.sortedListToBSTRecur(n -n //2-1)

        returnroot  

    # UTILITY FUNCTIONS
    # A utility function that returns count of nodes in a
    #   given Linked List 
    defcountNodes(self, head):
        count =0
        temp =head

        whiletemp !=None:
            temp =temp.next
            count +=1
        returncount

    # Function to insert a node at the beginning of
    #   the Doubly Linked List 
    defpush(self, new_data):
        # allocate node
        new_node =Node(new_data) 
        
        # since we are adding at the beginning,
        #   prev is always NULL
        new_node.prev =None
        
        # link the old list of the new node
        new_node.next=self.head

        # change prev of head node to new node
        ifself.head !=None:
            self.head.prev =new_node;   

        # move the head to point to the new node 
        self.head =new_node;     
        
    # Function to print nodes in a given linked list
    defprintList(self):     
        node =self.head;     
        whilenode !=None:         
            print(node.data, end="" "")         
            node =node.next

    # A utility function to print preorder traversal of BST
    defpreOrder(self, node):
        ifnode ==None:
            return
        
        print(node.data, end="" "")
        self.preOrder(node.prev)
        self.preOrder(node.next)

# Driver program to test above functions 
if__name__ =='__main__':
    llist =LinkedList()
    
    # Let us create a sorted linked list to test the functions
    # Created linked list will be 7->6->5->4->3->2->1
    llist.push(7);
    llist.push(6)
    llist.push(5)
    llist.push(4)
    llist.push(3)
    llist.push(2)
    llist.push(1)
    
    print(""Given Linked List "")
    llist.printList()
    
    # Convert List to BST
    root =llist.sortedListToBST()
    print("""")
    print(""Pre-Order Traversal of constructed BST "")
    llist.preOrder(root);
    
# This code is contributed by Tapesh(tapeshdua420)
",O(n),O(1)
"classNode:
  
    def__init__(self, key):
      
        self.key =key
        self.left =None
        self.right =None

# This code is contributed by harshitkap00r
",O(h),O(1)
""""""" Python3 code for inorder successor 
and predecessor of tree """"""

# A Binary Tree Node 
# Utility function to create a new tree node 
classgetnode: 

    # Constructor to create a new node 
    def__init__(self, data): 
        self.data =data 
        self.left =None
        self.right =None

"""""" 
since inorder traversal results in 
ascendingorder visit to node , we 
can store the values of the largest 
o which is smaller than a (predecessor) 
and smallest no which is large than 
a (successor) using inorder traversal 
""""""
deffind_p_s(root, a, p, q): 

    # If root is None return 
    if(notroot):
        return
        
    # traverse the left subtree     
    find_p_s(root.left, a, p, q) 
    
    # root data is greater than a 
    if(root androot.data > a):
        
        # q stores the node whose data is greater 
        # than a and is smaller than the previously 
        # stored data in *q which is successor 
        if((notq[0]) orq[0] and
                q[0].data > root.data):
            q[0] =root
            
    # if the root data is smaller than 
    # store it in p which is predecessor 
    elif(root androot.data < a):
        p[0]=root 
    
    # traverse the right subtree 
    find_p_s(root.right, a, p, q)

# Driver Code
if__name__ =='__main__': 

    root1 =getnode(50) 
    root1.left =getnode(20) 
    root1.right =getnode(60) 
    root1.left.left =getnode(10) 
    root1.left.right =getnode(30) 
    root1.right.left =getnode(55) 
    root1.right.right =getnode(70) 
    p =[None]
    q =[None] 
    
    find_p_s(root1, 55, p, q) 
    
    if(p[0]) :
        print(p[0].data, end ="""")
    if(q[0]) :
        print("""", q[0].data)

# This code is contributed by 
# SHUBHAMSINGH10
",O(h),O(1)
""""""" Python3 code for inorder successor 
and predecessor of tree """"""

# A Binary Tree Node 
# Utility function to create a new tree node 
classgetnode: 

    # Constructor to create a new node 
    def__init__(self, data): 
        self.data =data 
        self.left =None
        self.right =None

"""""" 
since inorder traversal results in 
ascendingorder visit to node , we 
can store the values of the largest 
o which is smaller than a (predecessor) 
and smallest no which is large than 
a (successor) using inorder traversal 
""""""
deffind_p_s(root, a, p, q): 

    # If root is None return 
    if(notroot):
        return
        
    # traverse the left subtree     
    find_p_s(root.left, a, p, q) 
    
    # root data is greater than a 
    if(root androot.data > a):
        
        # q stores the node whose data is greater 
        # than a and is smaller than the previously 
        # stored data in *q which is successor 
        if((notq[0]) orq[0] and
                q[0].data > root.data):
            q[0] =root
            
    # if the root data is smaller than 
    # store it in p which is predecessor 
    elif(root androot.data < a):
        p[0]=root 
    
    # traverse the right subtree 
    find_p_s(root.right, a, p, q)

# Driver Code
if__name__ =='__main__': 

    root1 =getnode(50) 
    root1.left =getnode(20) 
    root1.right =getnode(60) 
    root1.left.left =getnode(10) 
    root1.left.right =getnode(30) 
    root1.right.left =getnode(55) 
    root1.right.right =getnode(70) 
    p =[None]
    q =[None] 
    
    find_p_s(root1, 55, p, q) 
    
    if(p[0]) :
        print(p[0].data, end ="""")
    if(q[0]) :
        print("""", q[0].data)

# This code is contributed by 
# SHUBHAMSINGH10
",O(n),O(n)
"# Python program to find predecessor and successor in a BST

# BST Node
classNode:
    def__init__(self, key):
        self.key =key
        self.left =None
        self.right =None

# This function finds predecessor and successor of key in
# BST. It sets pre and suc as predecessor and successor
# respectively
deffindPreSuc(root, key):
    # Base Case
    ifroot isNone:
        return

    # If key is present at root
    ifroot.key ==key:
        
        # the maximum value in left subtree is predecessor
        ifroot.left isnotNone:
            tmp =root.left
            while(tmp.right):
                tmp =tmp.right
            findPreSuc.pre =tmp

        # the minimum value in right subtree is successor
        ifroot.right isnotNone:
            tmp =root.right
            while(tmp.left):
                tmp =tmp.left
            findPreSuc.suc =tmp
        
        return

    # If key is smaller than root's key
    # value then it could be in left subtree
    ifroot.key > key:
        findPreSuc.suc =root
        findPreSuc(root.left, key)
    else: # else it can only be in right subtree
        findPreSuc.pre =root
        findPreSuc(root.right, key)

# A utility function to create a new BST node
defnewNode(item):
    returnNode(item)

# A utility function to insert a new node with given key in BST
definsert(node, key):
    ifnode isNone:
        returnnewNode(key)
    ifkey < node.key:
        node.left =insert(node.left, key)
    else:
        node.right =insert(node.right, key)
    returnnode

# Driver program to test above function
defmain():
    key =65# Key to be searched in BST

    """""" Let us create following BST
              50
           /    \
          30    70
         / \   / \
       20 40 60 80
    """"""
    root =None
    root =insert(root, 50)
    insert(root, 30)
    insert(root, 20)
    insert(root, 40)
    insert(root, 70)
    insert(root, 60)
    insert(root, 80)

    findPreSuc.pre =None
    findPreSuc.suc =None
    findPreSuc(root, key)

    iffindPreSuc.pre isnotNone:
        print(""Predecessor is"", findPreSuc.pre.key)
    else:
        print(""No Predecessor"")

    iffindPreSuc.suc isnotNone:
        print(""Successor is"", findPreSuc.suc.key)
    else:
        print(""No Successor"")

main()

# This code is contributed by vikramshirsath177.
",O(n),O(1)
"# Python program to find the inorder successor in a BST

# A binary tree node 
classNode:

    # Constructor to create a new node
    def__init__(self, key):
        self.data =key 
        self.left =None
        self.right =None

definOrderSuccessor(n):
    
    # Step 1 of the above algorithm
    ifn.right isnotNone:
        returnminValue(n.right)

    # Step 2 of the above algorithm
    p =n.parent
    while( p isnotNone):
        ifn !=p.right :
            break
        n =p 
        p =p.parent
    returnp

# Given a non-empty binary search tree, return the 
# minimum data value found in that tree. Note that the
# entire tree doesn't need to be searched
defminValue(node):
    current =node

    # loop down to find the leftmost leaf
    while(current isnotNone):
        ifcurrent.left isNone:
            break
        current =current.left

    returncurrent


# Given a binary search tree and a number, inserts a
# new node with the given number in the correct place
# in the tree. Returns the new root pointer which the
# caller should then use( the standard trick to avoid 
# using reference parameters)
definsert( node, data):

    # 1) If tree is empty then return a new singly node
    ifnode isNone:
        returnNode(data)
    else:
       
        # 2) Otherwise, recur down the tree
        ifdata <=node.data:
            temp =insert(node.left, data)
            node.left =temp 
            temp.parent =node
        else:
            temp =insert(node.right, data)
            node.right =temp 
            temp.parent =node
        
        # return  the unchanged node pointer
        returnnode


# Driver program to test above function

root =None

# Creating the tree given in the above diagram 
root =insert(root, 20)
root =insert(root, 8);
root =insert(root, 22);
root =insert(root, 4);
root =insert(root, 12);
root =insert(root, 10);  
root =insert(root, 14);    
temp =root.left.right.right 

succ =inOrderSuccessor(temp)
ifsucc isnotNone:
    print(""\nInorder Successor of % d is % d ""%(temp.data, succ.data))
else:
    print(""\nInorder Successor doesn't exist"")

# This code is contributed by Nikhil Kumar Singh(nickzuck_007)
",O(1),O(1)
"# Python program to find 
# the inorder successor in a BST

# A binary tree node 
classNode:

    # Constructor to create a new node
    def__init__(self, key):
        self.data =key 
        self.left =None
        self.right =None

definOrderSuccessor(root, n):
    
    # Step 1 of the above algorithm
    ifn.right isnotNone:
        returnminValue(n.right)

    # Step 2 of the above algorithm
    succ=Node(None)
    
    
    while( root):
        if(root.data<n.data):
            root=root.right
        elif(root.data>n.data):
            succ=root
            root=root.left
        else:
            break
    returnsucc

# Given a non-empty binary search tree, 
# return the minimum data value
# found in that tree. Note that the
# entire tree doesn't need to be searched
defminValue(node):
    current =node

    # loop down to find the leftmost leaf
    while(current isnotNone):
        ifcurrent.left isNone:
            break
        current =current.left

    returncurrent


# Given a binary search tree 
# and a number, inserts a
# new node with the given 
# number in the correct place
# in the tree. Returns the 
# new root pointer which the
# caller should then use
# (the standard trick to avoid 
# using reference parameters)
definsert( node, data):

    # 1) If tree is empty 
    # then return a new singly node
    ifnode isNone:
        returnNode(data)
    else:
       
        # 2) Otherwise, recur down the tree
        ifdata <=node.data:
            temp =insert(node.left, data)
            node.left =temp 
            temp.parent =node
        else:
            temp =insert(node.right, data)
            node.right =temp 
            temp.parent =node
        
        # return  the unchanged node pointer
        returnnode


# Driver program to test above function
if__name__ ==""__main__"":
  root =None

  # Creating the tree given in the above diagram 
  root =insert(root, 20)
  root =insert(root, 8);
  root =insert(root, 22);
  root =insert(root, 4);
  root =insert(root, 12);
  root =insert(root, 10);  
  root =insert(root, 14);    
  temp =root.left.right 

  succ =inOrderSuccessor( root, temp)
  ifsucc isnotNone:
      print(""Inorder Successor of"",
               temp.data ,""is"",succ.data)
  else:
      print(""InInorder Successor doesn't exist"")
",O(h),O(1)
"# Python program for above approach

''' A binary tree node has data, 
   the pointer to left child
   and a pointer to right child '''
classNode :
    def__init__(self,data):
        self.data =data
        self.left =None
        self.right =None
        self.parent =None
    
definOrderTraversal(root, n, succ):
    if(root ==None): return
    inOrderTraversal(root.left, n, succ) 
    if(root.data > n.data andnotsucc.left): 
        succ.left =root
        return
    inOrderTraversal(root.right, n, succ)      

definOrderSuccessor(root, n):
    succ =Node(0) 
    inOrderTraversal(root, n, succ) 
    returnsucc.left 

# Give a binary search tree and a 
# number, inserts a new node with
# the given number in the correct 
# place in the tree. Returns the new
# root pointer which the caller should
# then use (the standard trick to 
# avoid using reference parameters). 
definsert(node, data):
    #  1. If the tree is empty, return a new,
    #    single node 
    if(node ==None):
        returnNode(data)
    else:
    #  2. Otherwise, recur down the tree 
        if(data <=node.data):
            temp =insert(node.left, data) 
            node.left =temp 
            temp.parent =node 
        else:
            temp =insert(node.right, data)
            node.right =temp 
            temp.parent =node 

        # Return the (unchanged) node pointer 
        returnnode 

# Driver code
root =None

# Creating the tree given in the above diagram
root =insert(root, 20) 
root =insert(root, 8) 
root =insert(root, 22) 
root =insert(root, 4) 
root =insert(root, 12) 
root =insert(root, 10) 
root =insert(root, 14) 
temp =root.left.right.right 

# Function Call
succ =inOrderSuccessor(root, temp) 
if(succ !=None): print(""Inorder Successor of"",temp.data,""is"",succ.data)
else: print(""Inorder Successor doesn't exist"")
",O(h),O(1)
"# Python program for above approach

# A binary tree node has data, the pointer to left
# child and a pointer to right child

classNode:
    def__init__(self, data):
        self.data =data
        self.left =None
        self.right =None
        self.parent =None

definOrderTraversal(root):
    ifnotroot:
        return
    inOrderTraversal(root.left)
    print(root.data, end=' ')
    inOrderTraversal(root.right)

definOrderSuccessor(root, key):
    _stack =[]
    whileroot or_stack:
        whileroot:
            _stack.append(root)
            root =root.left
        root =_stack.pop()
        ifroot.data > key:
            returnroot
        root =root.right
    returnNone

    # Helper function that allocates a new
    # node with the given data and null left
    # and right pointers.
defnewNode(data):
    returnNode(data)
  
    # Give a binary search tree and a
    # number, inserts a new node with
    # the given number in the correct
    # place in the tree. Returns the new
    # root pointer which the caller should
    # then use (the standard trick to
    # astatic void using reference parameters).

  
definsert(node, data):
    ifnotnode:
        returnnewNode(data)
    else:
        ifdata <=node.data:
            temp =insert(node.left, data)
            node.left =temp
            temp.parent =node
        else:
            temp =insert(node.right, data)
            node.right =temp
            temp.parent =node
        returnnode

if__name__ ==""__main__"":
    root =None
    root =insert(root, 20)
    root =insert(root, 8)
    root =insert(root, 22)
    root =insert(root, 4)
    root =insert(root, 12)
    root =insert(root, 10)
    root =insert(root, 14)
    temp =root.left.right.right
    succ =inOrderSuccessor(root, temp.data)
    ifsucc:
        print(""\n Inorder Successor of"",temp.data,""is"",succ.data)
    else:
        print(""\n Inorder Successor doesn't exist"")
",O(h),O(1)
"classTreeNode:
    def__init__(self, data):
        self.data =data
        self.left =None
        self.right =None

defmorris_traversal(root):
    current =root

    whilecurrent:
        ifcurrent.left isNone:
            print(current.data, end="" "")
            current =current.right
        else:
            # Find the inorder predecessor of current
            pre =current.left
            whilepre.right andpre.right !=current:
                pre =pre.right

            # Make current as the right child of its inorder predecessor
            ifpre.right isNone:
                pre.right =current
                current =current.left
            # Revert the changes made to restore the original tree and print current node
            else:
                pre.right =None
                print(current.data, end="" "")
                current =current.right

# Driver program to test above functions
if__name__ =='__main__':
    """"""
    Constructed binary tree is
            1
          /   \
         2     3
       /   \
      4     5
    """"""
    root =TreeNode(1)
    root.left =TreeNode(2)
    root.right =TreeNode(3)
    root.left.left =TreeNode(4)
    root.left.right =TreeNode(5)

    morris_traversal(root)
",O(n),O(1)
"# Python program to do inorder traversal without recursion


# A binary tree node
classNode:
    
    # Constructor to create a new node
    def__init__(self, data):
        self.data =data 
        self.left =None
        self.right =None


# Iterative function for inorder tree traversal
definOrder(root):
    
    # Set current to root of binary tree
    current =root
    
    # Initialize stack
    stack =[]
    
    whileTrue:
        
        # Reach the left most Node of the current Node
        ifcurrent isnotNone:
            
            # Place pointer to a tree node on the stack 
            # before traversing the node's left subtree
            stack.append(current)
        
            current =current.left
        
        # BackTrack from the empty subtree and visit the Node
        # at the top of the stack; however, if the stack is 
        # empty you are done
        elif(stack):
            current =stack.pop()
            print(current.data, end="" "")
        
            # We have visited the node and its left 
            # subtree. Now, it's right subtree's turn
            current =current.right 

        else:
            break
    
    print()


# Driver program to test above function
if__name__ =='__main__':
    
    """""" Constructed binary tree is
            1
          /   \
         2     3
       /  \
      4    5   """"""
    
    root =Node(1)
    root.left =Node(2)
    root.right =Node(3)
    root.left.left =Node(4)
    root.left.right =Node(5)
    
    inOrder(root)

# This code is contributed by Nikhil Kumar Singh(nickzuck_007)
",O(N),O(N)
"classTreeNode:
    def__init__(self, data):
        self.data =data
        self.left =None
        self.right =None


defmorris_traversal(root):
    current =root

    whilecurrent:
        ifcurrent.left isNone:
            print(current.data, end="" "")
            current =current.right
        else:
            # Find the inorder predecessor of current
            pre =current.left
            whilepre.right andpre.right !=current:
                pre =pre.right

            # Make current as the right child of its inorder predecessor
            ifpre.right isNone:
                pre.right =current
                current =current.left
            # Revert the changes made to restore the original tree and print current node
            else:
                pre.right =None
                print(current.data, end="" "")
                current =current.right


# Driver program to test above functions
if__name__ =='__main__':
    """"""
    Constructed binary tree is
            1
          /   \
         2     3
       /   \
      4     5
    """"""
    root =TreeNode(1)
    root.left =TreeNode(2)
    root.right =TreeNode(3)
    root.left.left =TreeNode(4)
    root.left.right =TreeNode(5)

    morris_traversal(root)
",O(N),O(1)
"classNode:
    def__init__(self, data):
        self.data =data
        self.left =None
        self.right =None

definOrderTrav(curr):
    inOrder =[]
    s =[]
    whileTrue:
        ifcurr:
            s.append(curr)
            curr =curr.left
        else:
            ifnots:
                break
            curr =s[-1]
            inOrder.append(curr.data)
            s.pop()
            curr =curr.right
    returninOrder

if__name__ ==""__main__"":
    root =Node(1)
    root.left =Node(2)
    root.right =Node(3)
    root.left.left =Node(4)
    root.left.right =Node(5)
    root.left.right.left =Node(8)
    root.right.left =Node(6)
    root.right.right =Node(7)
    root.right.right.left =Node(9)
    root.right.right.right =Node(10)

    inOrder =inOrderTrav(root)

    print(""The inOrder Traversal is : "")
    fordata ininOrder:
        print(data, end="" "")
",O(N),O(N)
"#  Python3 program for in-place matrix transpose 
HASH_SIZE =128
 
#  A utility function to pr a 2D array  
#  of size nr x nc and base address A 
defPr2DArray( A,  nr,  nc): 
     
    forr inrange(nr):  
        forc inrange(nc): 
 
            print('{0: >4}'.format(str(A[r *nc +c])), end ="""") 
        print() 
    print() 
 
#  Non-square matrix transpose of 
#  matrix of size r x c and base address A 
defMatrixInplaceTranspose( A,  r,  c): 
    size =r *c -1; 
     
    b =1; #  hash to mark moved elements 
     
    b |=(1<< size); 
 
    i =1; #  Note that A[0] and A[size-1] won't move 
    while(i < size): 
     
        cycleBegin =i; 
        t =A[i]; 
        whileTrue: 
         
            #  Input matrix [r x c] 
            #  Output matrix  
            #  i_new = (i*r)%(N-1) 
            next1 =(i*r)%size; 
            temp =A[next1] 
            A[next1] =t 
            t =temp 
            b |=(1<< i)  
            i =next1; 
            ifi ==cycleBegin: 
                break
         
        #  Get next1 Move (what about querying random location?) 
        i =1
        whilei < size and( (b & (1<< i)) !=0): 
            i +=1
         
        print() 
    returnA 
 
#  Driver program to test above function 
r =5
c =6; 
size =r*c; 
A =[i +1fori inrange(size)] 
 
Pr2DArray(A, r, c); 
A =MatrixInplaceTranspose(A, r, c); 
Pr2DArray(A, c, r); 
 
#  This code is contributed by phasing17.
",O(R*C),O(size of the bitset)
"HASH_SIZE =128
 
 
defPrint2DArray(A, nr, nc): 
    size =nr*nc 
    fori inrange(size): 
        print(str(A[i]).rjust(4), end="""") 
 
 
defMatrixTransposeInplaceArrangement(A, r, c): 
    size =r*c -1
    b =1# hash to mark moved elements 
 
    b |=(1<< size) 
    i =1# Note that A[0] and A[size-1] won't move 
    while(i < size): 
        cycleBegin =i 
        t =A[i] 
        whileTrue: 
            # Input matrix [r x c] 
            # Output matrix  
            # i_new = (i*r)%size 
            next1 =(i*r) %size 
            t, A[next1] =A[next1], t 
            b |=(1<< i) 
            i =next1 
            if(i ==cycleBegin): 
                break
 
        # Get next1 Move (what about querying random location?) 
        i =1
        while(i < size and(b & (1<< i)) !=0): 
            i +=1
 
    print() 
 
 
defFill(buf, size): 
    # Fill abcd ... 
    letters =['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 
               'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'] 
    fori inrange(size): 
        buf[i] =letters[i] 
 
    # Fill 0123 .. 
    fori inrange(size, 2*size): 
        buf[i] =str(i -size) 
 
 
defTestCase_01(): 
    r =2
    c =10
    size =r*c 
    A =[0] *size 
 
    Fill(A, c) 
 
    Print2DArray(A, r, c) 
    MatrixTransposeInplaceArrangement(A, r, c) 
    Print2DArray(A, c, r) 
    print() 
 
 
TestCase_01() 
",O(MN),O(MN)
"# Python code to insert a node in AVL tree 
 
# Generic tree node class 
classTreeNode(object): 
    def__init__(self, val): 
        self.val =val 
        self.left =None
        self.right =None
        self.height =1
 
# AVL tree class which supports the  
# Insert operation 
classAVL_Tree(object): 
 
    # Recursive function to insert key in  
    # subtree rooted with node and returns 
    # new root of subtree. 
    definsert(self, root, key): 
     
        # Step 1 - Perform normal BST 
        ifnotroot: 
            returnTreeNode(key) 
        elifkey < root.val: 
            root.left =self.insert(root.left, key) 
        else: 
            root.right =self.insert(root.right, key) 
 
        # Step 2 - Update the height of the  
        # ancestor node 
        root.height =1+max(self.getHeight(root.left), 
                           self.getHeight(root.right)) 
 
        # Step 3 - Get the balance factor 
        balance =self.getBalance(root) 
 
        # Step 4 - If the node is unbalanced,  
        # then try out the 4 cases 
        # Case 1 - Left Left 
        ifbalance > 1andkey < root.left.val: 
            returnself.rightRotate(root) 
 
        # Case 2 - Right Right 
        ifbalance < -1andkey > root.right.val: 
            returnself.leftRotate(root) 
 
        # Case 3 - Left Right 
        ifbalance > 1andkey > root.left.val: 
            root.left =self.leftRotate(root.left) 
            returnself.rightRotate(root) 
 
        # Case 4 - Right Left 
        ifbalance < -1andkey < root.right.val: 
            root.right =self.rightRotate(root.right) 
            returnself.leftRotate(root) 
 
        returnroot 
 
    defleftRotate(self, z): 
 
        y =z.right 
        T2 =y.left 
 
        # Perform rotation 
        y.left =z 
        z.right =T2 
 
        # Update heights 
        z.height =1+max(self.getHeight(z.left), 
                         self.getHeight(z.right)) 
        y.height =1+max(self.getHeight(y.left), 
                         self.getHeight(y.right)) 
 
        # Return the new root 
        returny 
 
    defrightRotate(self, z): 
 
        y =z.left 
        T3 =y.right 
 
        # Perform rotation 
        y.right =z 
        z.left =T3 
 
        # Update heights 
        z.height =1+max(self.getHeight(z.left), 
                        self.getHeight(z.right)) 
        y.height =1+max(self.getHeight(y.left), 
                        self.getHeight(y.right)) 
 
        # Return the new root 
        returny 
 
    defgetHeight(self, root): 
        ifnotroot: 
            return0
 
        returnroot.height 
 
    defgetBalance(self, root): 
        ifnotroot: 
            return0
 
        returnself.getHeight(root.left) -self.getHeight(root.right) 
 
    defpreOrder(self, root): 
 
        ifnotroot: 
            return
 
        print(""{0} "".format(root.val), end="""") 
        self.preOrder(root.left) 
        self.preOrder(root.right) 
 
 
# Driver program to test above function 
myTree =AVL_Tree() 
root =None
 
root =myTree.insert(root, 10) 
root =myTree.insert(root, 20) 
root =myTree.insert(root, 30) 
root =myTree.insert(root, 40) 
root =myTree.insert(root, 50) 
root =myTree.insert(root, 25) 
 
""""""The constructed AVL Tree would be 
            30 
           /  \ 
         20   40 
        /  \     \ 
       10  25    50""""""
 
# Preorder Traversal 
print(""Preorder traversal of the"", 
      ""constructed AVL tree is"") 
myTree.preOrder(root) 
print() 
 
# This code is contributed by Ajitesh Pathak 
",O(log(n)),O(1)
"# Function to generate binary numbers from 1 to n
defgeneratePrintBinary(n):
    fori inrange(1, n +1):
        str=""""
        temp =i
        # Convert decimal number to binary number
        whiletemp:
            iftemp & 1:
                str=""1""+str
            else:
                str=""0""+str
            temp >>=1# Right shift the bits of temp by 1 position
        print(str)


n =10

# Function call
generatePrintBinary(n)
",O(N*logN),O(1)
"# Python3 program to generate binary numbers from
# 1 to n

# This function uses queue data structure to print binary numbers


defgeneratePrintBinary(n):

    # Create an empty queue
    fromqueue importQueue
    q =Queue()

    # Enqueue the first binary number
    q.put(""1"")

    # This loop is like BFS of a tree with 1 as root
    # 0 as left child and 1 as right child and so on
    while(n > 0):
        n -=1
        # Print the front of queue
        s1 =q.get()
        print(s1)

        s2 =s1  # Store s1 before changing it

        # Append ""0"" to s1 and enqueue it
        q.put(s1+""0"")

        # Append ""1"" to s2 and enqueue it. Note that s2
        # contains the previous front
        q.put(s2+""1"")


# Driver code
if__name__ ==""__main__"":
    n =10

    # Function call
    generatePrintBinary(n)

# This code is contributed by Nikhil Kumar Singh(nickzuck_007)
",O(N),O(N)
"# Python3 program for array implementation of queue

# Class Queue to represent a queue
classQueue:

    # __init__ function
    def__init__(self, capacity):
        self.front =self.size =0
        self.rear =capacity -1
        self.Q =[None]*capacity
        self.capacity =capacity
    
    # Queue is full when size becomes
    # equal to the capacity 
    defisFull(self):
        returnself.size ==self.capacity
    
    # Queue is empty when size is 0
    defisEmpty(self):
        returnself.size ==0

    # Function to add an item to the queue. 
    # It changes rear and size
    defEnQueue(self, item):
        ifself.isFull():
            print(""Full"")
            return
        self.rear =(self.rear +1) %(self.capacity)
        self.Q[self.rear] =item
        self.size =self.size +1
        print(""% s enqueued to queue""%str(item))

    # Function to remove an item from queue. 
    # It changes front and size
    defDeQueue(self):
        ifself.isEmpty():
            print(""Empty"")
            return
        
        print(""% s dequeued from queue""%str(self.Q[self.front]))
        self.front =(self.front +1) %(self.capacity)
        self.size =self.size -1
        
    # Function to get front of queue
    defque_front(self):
        ifself.isEmpty():
            print(""Queue is empty"")

        print(""Front item is"", self.Q[self.front])
        
    # Function to get rear of queue
    defque_rear(self):
        ifself.isEmpty():
            print(""Queue is empty"")
        print(""Rear item is"",  self.Q[self.rear])


# Driver Code
if__name__ =='__main__':

    queue =Queue(30)
    queue.EnQueue(10)
    queue.EnQueue(20)
    queue.EnQueue(30)
    queue.EnQueue(40)
    queue.DeQueue()
    queue.que_front()
    queue.que_rear()
",O(1),O(N)
"# Adding a node at the front of the list
defpush(self, new_data):

    # 1 & 2: Allocate the Node & Put in the data
    new_node =Node(data=new_data)

    # 3. Make next of new node as head and previous as NULL
    new_node.next=self.head
    new_node.prev =None

    # 4. change prev of head node to new node
    ifself.head isnotNone:
        self.head.prev =new_node

    # 5. move the head to point to the new node
    self.head =new_node

# This code is contributed by jatinreaper
",O(1),O(1)
"# Given a node as prev_node, insert
# a new node after the given node


definsertAfter(self, prev_node, new_data):

    # Check if the given prev_node is NULL
    ifprev_node isNone:
        print(""This node doesn't exist in DLL"")
        return

    # 1. allocate node  & 
    # 2. put in the data
    new_node =Node(data=new_data)

    # 3. Make next of new node as next of prev_node
    new_node.next=prev_node.next

    # 4. Make the next of prev_node as new_node
    prev_node.next=new_node

    # 5. Make prev_node as previous of new_node
    new_node.prev =prev_node

    # 6. Change previous of new_node's next node
    ifnew_node.nextisnotNone:
        new_node.next.prev =new_node

#  This code is contributed by jatinreaper
",O(1),O(1)
"# Given a node as prev_node, insert
# a new node after the given node


definsertAfter(self, next_node, new_data):

    # Check if the given next_node is NULL
    ifnext_node isNone:
        print(""This node doesn't exist in DLL"")
        return

    # 1. Allocate node  & 
    # 2. Put in the data
    new_node =Node(data=new_data)

    # 3. Make previous of new node as previous of prev_node
    new_node.prev =next_node.prev

    # 4. Make the previous of next_node as new_node
    next_node.prev =new_node

    # 5. Make next_node as next of new_node
    new_node.next=next_node

    # 6. Change next of new_node's previous node
    ifnew_node.prev isnotNone:
        new_node.prev.next=new_node
    else:
        head =new_node

#  This code is contributed by jatinreaper
",O(1),O(1)
"# Add a node at the end of the DLL
defappend(self, new_data):

    # 1. allocate node 
    # 2. put in the data
    new_node =Node(data=new_data)
    last =self.head

    # 3. This new node is going to be the
    # last node, so make next of it as NULL
    new_node.next=None

    # 4. If the Linked List is empty, then
    #  make the new node as head
    ifself.head isNone:
        new_node.prev =None
        self.head =new_node
        return

    # 5. Else traverse till the last node
    while(last.nextisnotNone):
        last =last.next

    # 6. Change the next of last node
    last.next=new_node
    # 7. Make last node as previous of new node */
    new_node.prev =last

#  This code is contributed by jatinreaper
",O(n),O(1)
"# Finds the representative of the set
# that i is an element of

deffind(i):

    # If i is the parent of itself
    if(parent[i] ==i):

        # Then i is the representative of
        # this set
        returni
    else:

        # Else if i is not the parent of
        # itself, then i is not the
        # representative of his set. So we
        # recursively call Find on its parent
        returnfind(parent[i])

 # The code is contributed by Nidhi goel
",O(n),O(n)
"# Unites the set that includes i
# and the set that includes j

defunion(parent, rank, i, j):
    # Find the representatives
    # (or the root nodes) for the set
    # that includes i
    irep =find(parent, i)
    
    # And do the same for the set
    # that includes j
    jrep =find(parent, j)
    
    # Make the parent of is representative
    # be js  representative effectively
    # moving all of is set into js set)
    
    parent[irep] =jrep
",O(n),O(n)
"#  Finds the representative of the set that i
# is an element of.


deffind(i):

    # If i is the parent of itself
    ifParent[i] ==i:

        # Then i is the representative 
        returni
    else:

        # Recursively find the representative.
        result =find(Parent[i])

        # We cache the result by moving is node 
        # directly under the representative of this
        # set
        Parent[i] =result
      
        # And then we return the result
        returnresult

# The code is contributed by Arushi  Jindal. 
",O(log n),O(n)
"# Python3 program to implement Disjoint Set Data
# Structure.

classDisjSet:
    def__init__(self, n):
        # Constructor to create and
        # initialize sets of n items
        self.rank =[1] *n
        self.parent =[i fori inrange(n)]


    # Finds set of given item x
    deffind(self, x):
        
        # Finds the representative of the set
        # that x is an element of
        if(self.parent[x] !=x):
            
            # if x is not the parent of itself
            # Then x is not the representative of
            # its set,
            self.parent[x] =self.find(self.parent[x])
            
            # so we recursively call Find on its parent
            # and move i's node directly under the
            # representative of this set

        returnself.parent[x]


    # Do union of two sets represented
    # by x and y.
    defUnion(self, x, y):
        
        # Find current sets of x and y
        xset =self.find(x)
        yset =self.find(y)

        # If they are already in same set
        ifxset ==yset:
            return

        # Put smaller ranked item under
        # bigger ranked item if ranks are
        # different
        ifself.rank[xset] < self.rank[yset]:
            self.parent[xset] =yset

        elifself.rank[xset] > self.rank[yset]:
            self.parent[yset] =xset

        # If ranks are same, then move y under
        # x (doesn't matter which one goes where)
        # and increment rank of x's tree
        else:
            self.parent[yset] =xset
            self.rank[xset] =self.rank[xset] +1

# Driver code
obj =DisjSet(5)
obj.Union(0, 2)
obj.Union(4, 2)
obj.Union(3, 1)
ifobj.find(4) ==obj.find(0):
    print('Yes')
else:
    print('No')
ifobj.find(1) ==obj.find(0):
    print('Yes')
else:
    print('No')

# This code is contributed by ng24_7.
",O(log n),O(n)
"# Python3 program to implement Disjoint Set Data
# Structure.

classDisjSet:
    def__init__(self, n):
        # Constructor to create and
        # initialize sets of n items
        self.rank =[1] *n
        self.parent =[i fori inrange(n)]


    # Finds set of given item x
    deffind(self, x):
        
        # Finds the representative of the set
        # that x is an element of
        if(self.parent[x] !=x):
            
            # if x is not the parent of itself
            # Then x is not the representative of
            # its set,
            self.parent[x] =self.find(self.parent[x])
            
            # so we recursively call Find on its parent
            # and move i's node directly under the
            # representative of this set

        returnself.parent[x]


    # Do union of two sets represented
    # by x and y.
    defUnion(self, x, y):
        
        # Find current sets of x and y
        xset =self.find(x)
        yset =self.find(y)

        # If they are already in same set
        ifxset ==yset:
            return

        # Put smaller ranked item under
        # bigger ranked item if ranks are
        # different
        ifself.rank[xset] < self.rank[yset]:
            self.parent[xset] =yset

        elifself.rank[xset] > self.rank[yset]:
            self.parent[yset] =xset

        # If ranks are same, then move y under
        # x (doesn't matter which one goes where)
        # and increment rank of x's tree
        else:
            self.parent[yset] =xset
            self.rank[xset] =self.rank[xset] +1

# Driver code
obj =DisjSet(5)
obj.Union(0, 2)
obj.Union(4, 2)
obj.Union(3, 1)
ifobj.find(4) ==obj.find(0):
    print('Yes')
else:
    print('No')
ifobj.find(1) ==obj.find(0):
    print('Yes')
else:
    print('No')

# This code is contributed by ng24_7.
",O(n),O(n)
"# Python3 program to count
# inversions in an array


defgetInvCount(arr, n):

    inv_count =0
    fori inrange(n):
        forj inrange(i +1, n):
            if(arr[i] > arr[j]):
                inv_count +=1

    returninv_count


# Driver Code
arr =[1, 20, 6, 4, 5]
n =len(arr)
print(""Number of inversions are"",
      getInvCount(arr, n))

# This code is contributed by Smitha Dinesh Semwal
",O(N2),O(1)
"# Python 3 program to count inversions in an array

# Function to Use Inversion Count


defmergeSort(arr, n):
    # A temp_arr is created to store
    # sorted array in merge function
    temp_arr =[0]*n
    return_mergeSort(arr, temp_arr, 0, n-1)

# This Function will use MergeSort to count inversions


def_mergeSort(arr, temp_arr, left, right):

    # A variable inv_count is used to store
    # inversion counts in each recursive call

    inv_count =0

    # We will make a recursive call if and only if
    # we have more than one elements

    ifleft < right:

        # mid is calculated to divide the array into two subarrays
        # Floor division is must in case of python

        mid =(left +right)//2

        # It will calculate inversion
        # counts in the left subarray

        inv_count +=_mergeSort(arr, temp_arr,
                                left, mid)

        # It will calculate inversion
        # counts in right subarray

        inv_count +=_mergeSort(arr, temp_arr,
                                mid +1, right)

        # It will merge two subarrays in
        # a sorted subarray

        inv_count +=merge(arr, temp_arr, left, mid, right)
    returninv_count

# This function will merge two subarrays
# in a single sorted subarray


defmerge(arr, temp_arr, left, mid, right):
    i =left     # Starting index of left subarray
    j =mid +1# Starting index of right subarray
    k =left     # Starting index of to be sorted subarray
    inv_count =0

    # Conditions are checked to make sure that
    # i and j don't exceed their
    # subarray limits.

    whilei <=mid andj <=right:

        # There will be no inversion if arr[i] <= arr[j]

        ifarr[i] <=arr[j]:
            temp_arr[k] =arr[i]
            k +=1
            i +=1
        else:
            # Inversion will occur.
            temp_arr[k] =arr[j]
            inv_count +=(mid-i +1)
            k +=1
            j +=1

    # Copy the remaining elements of left
    # subarray into temporary array
    whilei <=mid:
        temp_arr[k] =arr[i]
        k +=1
        i +=1

    # Copy the remaining elements of right
    # subarray into temporary array
    whilej <=right:
        temp_arr[k] =arr[j]
        k +=1
        j +=1

    # Copy the sorted subarray into Original array
    forloop_var inrange(left, right +1):
        arr[loop_var] =temp_arr[loop_var]

    returninv_count


# Driver Code
# Given array is
arr =[1, 20, 6, 4, 5]
n =len(arr)
result =mergeSort(arr, n)
print(""Number of inversions are"", result)

# This code is contributed by ankush_953
",O(N * log N),O(N)
"fromheapq importheappush, heappop
frombisect importbisect, insort


defgetNumOfInversions(A):
    N =len(A)
    ifN <=1:
        return0

    sortList =[]
    result =0

    # Heapsort, O(N*log(N))
    fori, v inenumerate(A):
        heappush(sortList, (v, i))

    # Create a sorted list of indexes
    x =[]
    whilesortList:
      
        # O(log(N))
        v, i =heappop(sortList)
        
        # Find the current minimum's index
        # the index y can represent how many minimums on the left
        y =bisect(x, i)
        
        # i can represent how many elements on the left
        # i - y can find how many bigger nums on the left
        result +=i -y

        insort(x, i)

    returnresult

# Driver Code
if__name__ =='__main__':
    A =[1, 20, 6, 4, 5]
    result =getNumOfInversions(A)
    print(f'Number of inversions are {result}')
",O(N * log N),O(N)
"# Python3 code for the above approach

# function to schedule the jobs take 2
# arguments array and no of jobs to schedule


defprintJobScheduling(arr, t):

    # length of array
    n =len(arr)

    # Sort all jobs according to
    # decreasing order of profit
    fori inrange(n):
        forj inrange(n -1-i):
            ifarr[j][2] < arr[j +1][2]:
                arr[j], arr[j +1] =arr[j +1], arr[j]

    # To keep track of free time slots
    result =[False] *t

    # To store result (Sequence of jobs)
    job =['-1'] *t

    # Iterate through all given jobs
    fori inrange(len(arr)):

        # Find a free slot for this job
        # (Note that we start from the
        # last possible slot)
        forj inrange(min(t -1, arr[i][1] -1), -1, -1):

            # Free slot found
            ifresult[j] isFalse:
                result[j] =True
                job[j] =arr[i][0]
                break

    # print the sequence
    print(job)


# Driver's Code
if__name__ =='__main__':
    arr =[['a', 2, 100],  # Job Array
              ['b', 1, 19],
              ['c', 2, 27],
              ['d', 1, 25],
              ['e', 3, 15]]


    print(""Following is maximum profit sequence of jobs"")

    # Function Call
    printJobScheduling(arr, 3)

# This code is contributed
# by Anubhav Raj Singh
",O(N2),O(N)
"# Python3 program for the above approach 
importheapq


defprintJobScheduling(arr):
    n =len(arr)

    # arr[i][0] = job_id, arr[i][1] = deadline, arr[i][2] = profit

    # sorting the array on the
    # basis of their deadlines
    arr.sort(key=lambdax: x[1])

    # initialise the result array and maxHeap
    result =[]
    maxHeap =[]

    # starting the iteration from the end
    fori inrange(n -1, -1, -1):

        # calculate slots between two deadlines
        ifi ==0:
            slots_available =arr[i][1]
        else:
            slots_available =arr[i][1] -arr[i -1][1]

        # include the profit of job(as priority), deadline
        # and job_id in maxHeap
        # note we push negative value in maxHeap to convert
        # min heap to max heap in python
        heapq.heappush(maxHeap, (-arr[i][2], arr[i][1], arr[i][0]))

        whileslots_available andmaxHeap:

            # get the job with max_profit
            profit, deadline, job_id =heapq.heappop(maxHeap)

            # reduce the slots
            slots_available -=1

            # include the job in the result array
            result.append([job_id, deadline])

    # jobs included might be shuffled
    # sort the result array by their deadlines
    result.sort(key=lambdax: x[1])

    forjob inresult:
        print(job[0], end="" "")
    print()


# Driver's Code
if__name__ =='__main__':
    arr =[['a', 2, 100],  # Job Array
           ['b', 1, 19],
           ['c', 2, 27],
           ['d', 1, 25],
           ['e', 3, 15]]

    print(""Following is maximum profit sequence of jobs"")

    # Function Call
    printJobScheduling(arr)

# This code is contributed
# by Shivam Bhagat
",O(N log N),O(N)
"defpartition(arr, l, r):
    x =arr[r]  # Choose the last element as the pivot
    i =l

    # Iterate through the array and move elements smaller than the pivot to the left
    forj inrange(l, r):
        ifarr[j] <=x:
            arr[i], arr[j] =arr[j], arr[i]
            i +=1

    # Swap the pivot element with the element at index 'i'
    arr[i], arr[r] =arr[r], arr[i]
    returni

defkthLargest(arr, l, r, k, N):
    # Partition the array around the pivot
    pos =partition(arr, l, r)

    # If the position is the same as 'k', we have found the kth largest element
    ifpos -l ==k -1:
        return

    # If the position is less than 'k', recurse for the right subarray
    elifpos -l < k -1:
        kthLargest(arr, pos +1, r, k -pos +l -1, N)

    # Otherwise, recurse for the left subarray
    else:
        kthLargest(arr, l, pos -1, k, N)

if__name__ ==""__main__"":
    arr =[11, 3, 2, 1, 15, 5, 4, 45, 88, 96, 50, 45]
    N =len(arr)
    k =3

    # Find the kth largest elements
    kthLargest(arr, 0, N -1, k, N)

    # Print K Largest numbers
    print(f""{k} largest elements are:"", end="" "")
    fori inrange(N -1, N -k -1, -1):
        print(arr[i], end="" "")

    print()
",O(N * log(N)),O(1)
"defpartition(arr, l, r):
    x =arr[r]  # Choose the last element as the pivot
    i =l

    # Iterate through the array and move elements smaller than the pivot to the left
    forj inrange(l, r):
        ifarr[j] <=x:
            arr[i], arr[j] =arr[j], arr[i]
            i +=1

    # Swap the pivot element with the element at index 'i'
    arr[i], arr[r] =arr[r], arr[i]
    returni

defkthLargest(arr, l, r, k, N):
    # Partition the array around the pivot
    pos =partition(arr, l, r)

    # If the position is the same as 'k', we have found the kth largest element
    ifpos -l ==k -1:
        return

    # If the position is less than 'k', recurse for the right subarray
    elifpos -l < k -1:
        kthLargest(arr, pos +1, r, k -pos +l -1, N)

    # Otherwise, recurse for the left subarray
    else:
        kthLargest(arr, l, pos -1, k, N)

if__name__ ==""__main__"":
    arr =[11, 3, 2, 1, 15, 5, 4, 45, 88, 96, 50, 45]
    N =len(arr)
    k =3

    # Find the kth largest elements
    kthLargest(arr, 0, N -1, k, N)

    # Print K Largest numbers
    print(f""{k} largest elements are:"", end="" "")
    fori inrange(N -1, N -k -1, -1):
        print(arr[i], end="" "")

    print()
",O(n * log (mx-mn)),O(1)
"defpartition(arr, l, r):
    x =arr[r]  # Choose the last element as the pivot
    i =l

    # Iterate through the array and move elements smaller than the pivot to the left
    forj inrange(l, r):
        ifarr[j] <=x:
            arr[i], arr[j] =arr[j], arr[i]
            i +=1

    # Swap the pivot element with the element at index 'i'
    arr[i], arr[r] =arr[r], arr[i]
    returni

defkthLargest(arr, l, r, k, N):
    # Partition the array around the pivot
    pos =partition(arr, l, r)

    # If the position is the same as 'k', we have found the kth largest element
    ifpos -l ==k -1:
        return

    # If the position is less than 'k', recurse for the right subarray
    elifpos -l < k -1:
        kthLargest(arr, pos +1, r, k -pos +l -1, N)

    # Otherwise, recurse for the left subarray
    else:
        kthLargest(arr, l, pos -1, k, N)

if__name__ ==""__main__"":
    arr =[11, 3, 2, 1, 15, 5, 4, 45, 88, 96, 50, 45]
    N =len(arr)
    k =3

    # Find the kth largest elements
    kthLargest(arr, 0, N -1, k, N)

    # Print K Largest numbers
    print(f""{k} largest elements are:"", end="" "")
    fori inrange(N -1, N -k -1, -1):
        print(arr[i], end="" "")

    print()
",O(N2),O(N)
"# Python code for k largest elements in an array
importheapq

# Function to find k largest array element


defkLargest(v, N, K):

    # Implementation using
    # a Priority Queue
    pq =[]
    heapq.heapify(pq)

    fori inrange(N):

        # Insert elements into
        # the priority queue
        heapq.heappush(pq, v[i])

        # If size of the priority
        # queue exceeds k
        if(len(pq) > K):
            heapq.heappop(pq)

    # Print the k largest element
    while(len(pq) !=0):
        print(heapq.heappop(pq), end=' ')
    print()





# driver program

# Given array
arr =[11, 3, 2, 1, 15, 5, 4, 45, 88, 96, 50, 45]
# Size of array
n =len(arr)
k =3
print(k, "" largest elements are : "", end='')
kLargest(arr, n, k)
",O(N * log(K)),O(K)
"# Python3 program for KMP Algorithm


defKMPSearch(pat, txt):
    M =len(pat)
    N =len(txt)

    # create lps[] that will hold the longest prefix suffix
    # values for pattern
    lps =[0]*M
    j =0# index for pat[]

    # Preprocess the pattern (calculate lps[] array)
    computeLPSArray(pat, M, lps)

    i =0# index for txt[]
    while(N -i) >=(M -j):
        ifpat[j] ==txt[i]:
            i +=1
            j +=1

        ifj ==M:
            print(""Found pattern at index ""+str(i-j))
            j =lps[j-1]

        # mismatch after j matches
        elifi < N andpat[j] !=txt[i]:
            # Do not match lps[0..lps[j-1]] characters,
            # they will match anyway
            ifj !=0:
                j =lps[j-1]
            else:
                i +=1


# Function to compute LPS array
defcomputeLPSArray(pat, M, lps):
    len=0# length of the previous longest prefix suffix

    lps[0] =0# lps[0] is always 0
    i =1

    # the loop calculates lps[i] for i = 1 to M-1
    whilei < M:
        ifpat[i] ==pat[len]:
            len+=1
            lps[i] =len
            i +=1
        else:
            # This is tricky. Consider the example.
            # AAACAAAA and i = 7. The idea is similar
            # to search step.
            iflen!=0:
                len=lps[len-1]

                # Also, note that we do not increment i here
            else:
                lps[i] =0
                i +=1


# Driver code
if__name__ =='__main__':
    txt =""ABABDABACDABABCABAB""
    pat =""ABABCABAB""
    KMPSearch(pat, txt)

# This code is contributed by Bhavya Jain
",O(N+M),O(M)
"# Python program to print largest contiguous array sum

fromsys importmaxsize

# Function to find the maximum contiguous subarray
# and print its starting and end index


defmaxSubArraySum(a, size):

    max_so_far =-maxsize -1
    max_ending_here =0
    start =0
    end =0
    s =0

    fori inrange(0, size):

        max_ending_here +=a[i]

        ifmax_so_far < max_ending_here:
            max_so_far =max_ending_here
            start =s
            end =i

        ifmax_ending_here < 0:
            max_ending_here =0
            s =i+1

    print(""Maximum contiguous sum is %d""%(max_so_far))
    print(""Starting Index %d""%(start))
    print(""Ending Index %d""%(end))


# Driver program to test maxSubArraySum
a =[-2, -3, 4, -1, -2, 1, 5, -3]
maxSubArraySum(a, len(a))
",O(N),O(1)
"# Python program to print largest contiguous array sum

fromsys importmaxsize

# Function to find the maximum contiguous subarray
# and print its starting and end index


defmaxSubArraySum(a, size):

    max_so_far =-maxsize -1
    max_ending_here =0
    start =0
    end =0
    s =0

    fori inrange(0, size):

        max_ending_here +=a[i]

        ifmax_so_far < max_ending_here:
            max_so_far =max_ending_here
            start =s
            end =i

        ifmax_ending_here < 0:
            max_ending_here =0
            s =i+1

    print(""Maximum contiguous sum is %d""%(max_so_far))
    print(""Starting Index %d""%(start))
    print(""Ending Index %d""%(end))


# Driver program to test maxSubArraySum
a =[-2, -3, 4, -1, -2, 1, 5, -3]
maxSubArraySum(a, len(a))
",O(n),O(1)
"# /* A recursive function to update the nodes which have the given
#    index in their range. The following are parameters
#     tree[] --> segment tree
#     si     -->  index of current node in segment tree.
#                 Initial value is passed as 0.
#     ss and se --> Starting and ending indexes of array elements 
#                   covered under this node of segment tree.
#                   Initial values passed as 0 and n-1.
#     i    --> index of the element to be updated. This index 
#             is in input array.
#    diff --> Value to be added to all nodes which have array
#             index i in range */
defupdateValueUtil(tree, ss, se, i, diff, si):
    
    # Base Case: If the input index lies outside the range
    # of this segment
    ifi < ss ori > se:
        return
 
    # If the input index is in range of this node, then
    # update the value of the node and its children
    st[si] =st[si] +diff
    ifse !=ss:
        mid =getMid(ss, se)
        updateValueUtil(st, ss, mid, i, diff, 2*si +1)
        updateValueUtil(st, mid+1, se, i, diff, 2*si +2)

# The code is contributed by Arushi jindal. 
",O(n),O(MAX)
"# Python


defupdateRangeUtil(si, ss, se, us, ue, diff):
    # out of range
    if(ss > se orss > ue orse < us):
        return

    # Current node is a leaf node
    if(ss ==se):
        # Add the difference to current node
        tree[si] +=diff
        return

    # If not a leaf node, recur for children.
    mid =(ss +se) //2
    updateRangeUtil(si *2+1, ss, mid, us, ue, diff)
    updateRangeUtil(si *2+2, mid +1, se, us, ue, diff)

    # Use the result of children calls to update this
    # node
    tree[si] =tree[si *2+1] +tree[si *2+2]
",O(n),O(MAX)
"# Python3 implementation of the approach 
MAX=1000

# Ideally, we should not use global variables 
# and large constant-sized arrays, we have 
# done it here for simplicity. 
tree =[0] *MAX; # To store segment tree 
lazy =[0] *MAX; # To store pending updates 

"""""" si -> index of current node in segment tree 
    ss and se -> Starting and ending indexes of elements 
                for which current nodes stores sum. 
    us and ue -> starting and ending indexes of update query 
    diff -> which we need to add in the range us to ue """"""
defupdateRangeUtil(si, ss, se, us, ue, diff) : 

    # If lazy value is non-zero for current node
    # of segment tree, then there are some 
    # pending updates. So we need to make sure 
    # that the pending updates are done before 
    # making new updates. Because this value may be 
    # used by parent after recursive calls 
    # (See last line of this function) 
    if(lazy[si] !=0) :
        
        # Make pending updates using value 
        # stored in lazy nodes 
        tree[si] +=(se -ss +1) *lazy[si]; 

        # checking if it is not leaf node because if 
        # it is leaf node then we cannot go further 
        if(ss !=se) :
        
            # We can postpone updating children we don't 
            # need their new values now. 
            # Since we are not yet updating children of si, 
            # we need to set lazy flags for the children 
            lazy[si *2+1] +=lazy[si]; 
            lazy[si *2+2] +=lazy[si]; 
        
        # Set the lazy value for current node 
        # as 0 as it has been updated 
        lazy[si] =0; 
    
    # out of range 
    if(ss > se orss > ue orse < us) :
        return; 

    # Current segment is fully in range 
    if(ss >=us andse <=ue) :
        
        # Add the difference to current node 
        tree[si] +=(se -ss +1) *diff; 

        # same logic for checking leaf node or not 
        if(ss !=se) :
        
            # This is where we store values in lazy nodes, 
            # rather than updating the segment tree itself 
            # Since we don't need these updated values now 
            # we postpone updates by storing values in lazy[] 
            lazy[si *2+1] +=diff; 
            lazy[si *2+2] +=diff; 
        
        return; 

    # If not completely in rang, but overlaps, 
    # recur for children, 
    mid =(ss +se) //2; 
    updateRangeUtil(si *2+1, ss,
                    mid, us, ue, diff); 
    updateRangeUtil(si *2+2, mid +1, 
                    se, us, ue, diff); 

    # And use the result of children calls 
    # to update this node 
    tree[si] =tree[si *2+1] +\
            tree[si *2+2]; 

# Function to update a range of values 
# in segment tree 

''' us and eu -> starting and ending indexes 
                of update query 
    ue -> ending index of update query 
    diff -> which we need to add in the range us to ue '''
defupdateRange(n, us, ue, diff) :
    updateRangeUtil(0, 0, n -1, us, ue, diff); 

''' A recursive function to get the sum of values 
    in given range of the array. The following are 
    parameters for this function. 
    si --> Index of current node in the segment tree. 
        Initially 0 is passed as root is always at' 
        index 0 
    ss & se --> Starting and ending indexes of the 
                segment represented by current node, 
                i.e., tree[si] 
    qs & qe --> Starting and ending indexes of query 
                range '''
defgetSumUtil(ss, se, qs, qe, si) : 

    # If lazy flag is set for current node 
    # of segment tree, then there are 
    # some pending updates. So we need to 
    # make sure that the pending updates are 
    # done before processing the sub sum query 
    if(lazy[si] !=0) :
    
        # Make pending updates to this node. 
        # Note that this node represents sum of 
        # elements in arr[ss..se] and all these 
        # elements must be increased by lazy[si] 
        tree[si] +=(se -ss +1) *lazy[si]; 

        # checking if it is not leaf node because if 
        # it is leaf node then we cannot go further 
        if(ss !=se) :
        
            # Since we are not yet updating children os si, 
            # we need to set lazy values for the children 
            lazy[si *2+1] +=lazy[si]; 
            lazy[si *2+2] +=lazy[si]; 

        # unset the lazy value for current node 
        # as it has been updated 
        lazy[si] =0; 

    # Out of range 
    if(ss > se orss > qe orse < qs) :
        return0; 

    # At this point we are sure that 
    # pending lazy updates are done for 
    # current node. So we can return value
    # (same as it was for query in our previous post) 

    # If this segment lies in range 
    if(ss >=qs andse <=qe) :
        returntree[si]; 

    # If a part of this segment overlaps 
    # with the given range 
    mid =(ss +se) //2; 
    return(getSumUtil(ss, mid, qs, qe, 2*si +1) +
            getSumUtil(mid +1, se, qs, qe, 2*si +2)); 

# Return sum of elements in range from 
# index qs (query start) to qe (query end). 
# It mainly uses getSumUtil() 
defgetSum(n, qs, qe) :
    
    # Check for erroneous input values 
    if(qs < 0orqe > n -1orqs > qe) :
        print(""Invalid Input""); 
        return-1; 

    returngetSumUtil(0, n -1, qs, qe, 0); 

# A recursive function that constructs 
# Segment Tree for array[ss..se]. 
# si is index of current node in segment 
# tree st. 
defconstructSTUtil(arr, ss, se, si) : 

    # out of range as ss can never be
    # greater than se 
    if(ss > se) :
        return; 

    # If there is one element in array, 
    # store it in current node of 
    # segment tree and return 
    if(ss ==se) :
    
        tree[si] =arr[ss]; 
        return; 
    
    # If there are more than one elements, 
    # then recur for left and right subtrees 
    # and store the sum of values in this node 
    mid =(ss +se) //2; 
    constructSTUtil(arr, ss, mid, si *2+1); 
    constructSTUtil(arr, mid +1, se, si *2+2); 

    tree[si] =tree[si *2+1] +tree[si *2+2]; 

''' Function to construct segment tree 
from given array. This function allocates memory 
for segment tree and calls constructSTUtil() 
to fill the allocated memory '''
defconstructST(arr, n) : 
    
    # Fill the allocated memory st 
    constructSTUtil(arr, 0, n -1, 0); 
    
# Driver Code
if__name__ ==""__main__"": 

    arr =[1, 3, 5, 7, 9, 11]; 
    n =len(arr); 

    # Build segment tree from given array 
    constructST(arr, n); 

    # Print sum of values in array from index 1 to 3 
    print(""Sum of values in given range ="",
                        getSum(n, 1, 3)); 

    # Add 10 to all nodes at indexes from 1 to 5. 
    updateRange(n, 1, 5, 10); 

    # Find sum after the value is updated 
    print(""Updated sum of values in given range ="",
                                getSum( n, 1, 3)); 

# This code is contributed by AnkitRai01
",O(n),O(MAX)
"# Python Function to print leaders in array 

defprintLeaders(arr,size): 
    
    fori inrange(0, size): 
        forj inrange(i+1, size): 
            ifarr[i]<=arr[j]: 
                break
        ifj ==size-1: # If loop didn't break 
            print(arr[i],end=' ') 

# Driver function 
arr=[16, 17, 4, 3, 5, 2] 
printLeaders(arr, len(arr)) 

# This code is contributed by _Devesh Agrawal__ 
",O(N * N),O(1)
"# Python function to print leaders in array
defprintLeaders(arr, size):
   
    max_from_right =arr[size-1]   
    print(max_from_right,end=' ')    
    fori inrange( size-2, -1, -1):        
        ifmax_from_right < arr[i]:        
            print(arr[i],end=' ')
            max_from_right =arr[i]
        
# Driver function
arr =[16, 17, 4, 3, 5, 2]
printLeaders(arr, len(arr))

# This code contributed by _Devesh Agrawal__
",O(n),O(1)
"# Python Function to print leaders in an array
defprintLaders(arr, size):
    # create stack to store leaders
    sk =[]
    sk.append(arr[size -1])
    fori inrange(size -2, -1, -1):
        if(arr[i] >=sk[len(sk) -1]):
            sk.append(arr[i])

    # print stack elements
    # run loop till stack is not empty
    while(len(sk) !=0):
        print(sk[len(sk)-1],end =' ')
        sk.pop()

# Driver program to test above function
if__name__ ==""__main__"":
    arr =[16,17,4,3,5,2]
    n =len(arr)
    printLaders(arr,n)
    
    # This code is contributed by ajaymakvana
",O(n),O(n)
"# Recursive Python program for level
# order traversal of Binary Tree


# A node structure
classNode:

    # A utility function to create a new node
    def__init__(self, key):
        self.data =key
        self.left =None
        self.right =None


# Function to  print level order traversal of tree
defprintLevelOrder(root):
    h =height(root)
    fori inrange(1, h+1):
        printCurrentLevel(root, i)


# Print nodes at a current level
defprintCurrentLevel(root, level):
    ifroot isNone:
        return
    iflevel ==1:
        print(root.data, end="" "")
    eliflevel > 1:
        printCurrentLevel(root.left, level-1)
        printCurrentLevel(root.right, level-1)


# Compute the height of a tree--the number of nodes
# along the longest path from the root node down to
# the farthest leaf node
defheight(node):
    ifnode isNone:
        return0
    else:

        # Compute the height of each subtree
        lheight =height(node.left)
        rheight =height(node.right)

        # Use the larger one
        iflheight > rheight:
            returnlheight+1
        else:
            returnrheight+1


# Driver program to test above function
if__name__ =='__main__':
    root =Node(1)
    root.left =Node(2)
    root.right =Node(3)
    root.left.left =Node(4)
    root.left.right =Node(5)

    print(""Level order traversal of binary tree is -"")
    printLevelOrder(root)

# This code is contributed by Nikhil Kumar Singh(nickzuck_007)
",O(N2),O(1)
"# Python program to print level
# order traversal using Queue


# A node structure
classNode:

    # A utility function to create a new node
    def__init__(self, key):
        self.data =key
        self.left =None
        self.right =None


# Iterative Method to print the
# height of a binary tree
defprintLevelOrder(root):

    # Base Case
    ifroot isNone:
        return

    # Create an empty queue
    # for level order traversal
    queue =[]

    # Enqueue Root and initialize height
    queue.append(root)

    while(len(queue) > 0):

        # Print front of queue and
        # remove it from queue
        print(queue[0].data, end="" "")
        node =queue.pop(0)

        # Enqueue left child
        ifnode.left isnotNone:
            queue.append(node.left)

        # Enqueue right child
        ifnode.right isnotNone:
            queue.append(node.right)


# Driver Program to test above function
if__name__ =='__main__':
    root =Node(1)
    root.left =Node(2)
    root.right =Node(3)
    root.left.left =Node(4)
    root.left.right =Node(5)

    print(""Level Order Traversal of binary tree is -"")
    printLevelOrder(root)


# This code is contributed by Nikhil Kumar Singh(nickzuck_007)
",O(N),O(N)
"importctypes

# function to show bytes in memory, from location start to start+n


defshow_mem_rep(start, n):
    # create a ctypes array of unsigned bytes from the buffer
    arr =(ctypes.c_ubyte *n).from_address(ctypes.addressof(start))
    fori inrange(n):
        # use hex() to convert integer to hexadecimal string and slice to remove the ""0x"" prefix
        # use rjust() to right-justify the string with 2 spaces
        print(hex(arr[i])[2:].rjust(2, ""0""), end="" "")
    print()


# Main function to call above function for 0x01234567
if__name__ ==""__main__"":
    # create a 4-byte integer with value 0x01234567
    i =0x01234567
    # convert integer i to a byte array in little-endian byte order
    i_bytes_le =i.to_bytes(ctypes.sizeof(ctypes.c_int), byteorder=""little"")
    # convert integer i to a byte array in big-endian byte order
    i_bytes_be =i.to_bytes(ctypes.sizeof(ctypes.c_int), byteorder=""big"")
    # create a writable buffer using ctypes.create_string_buffer() and copy the bytes into it
    buf_le =ctypes.create_string_buffer(i_bytes_le)
    buf_be =ctypes.create_string_buffer(i_bytes_be)
    # pass the buffer to show_mem_rep
    print(""Little Endian: "", end="""")
    show_mem_rep(buf_le, ctypes.sizeof(ctypes.c_int))
    print(""Big Endian: "", end="""")
    show_mem_rep(buf_be, ctypes.sizeof(ctypes.c_int))
",O(1),O(1)
"# A Naive recursive Python implementation of LCS problem


deflcs(X, Y, m, n):
    ifm ==0orn ==0:
        return0
    elifX[m-1] ==Y[n-1]:
        return1+lcs(X, Y, m-1, n-1)
    else:
        returnmax(lcs(X, Y, m, n-1), lcs(X, Y, m-1, n))


# Driver code
if__name__ =='__main__':
    S1 =""AGGTAB""
    S2 =""GXTXAYB""
    print(""Length of LCS is"", lcs(S1, S2, len(S1), len(S2)))
",O(2m*n),O(1)
"# A Top-Down DP implementation of LCS problem

# Returns length of LCS for X[0..m-1], Y[0..n-1]


deflcs(X, Y, m, n, dp):

    if(m ==0orn ==0):
        return0

    if(dp[m][n] !=-1):
        returndp[m][n]

    ifX[m -1] ==Y[n -1]:
        dp[m][n] =1+lcs(X, Y, m -1, n -1, dp)
        returndp[m][n]

    dp[m][n] =max(lcs(X, Y, m, n -1, dp), lcs(X, Y, m -1, n, dp))
    returndp[m][n]

# Driver code


X =""AGGTAB""
Y =""GXTXAYB""

m =len(X)
n =len(Y)
dp =[[-1fori inrange(n +1)]forj inrange(m +1)]

print(f""Length of LCS is {lcs(X, Y, m, n, dp)}"")

# This code is contributed by shinjanpatra
",O(m * n),O(m * n)
"# Dynamic Programming implementation of LCS problem


deflcs(X, Y, m, n):

    # Declaring the array for storing the dp values
    L =[[None]*(n+1) fori inrange(m+1)]

    # Following steps build L[m+1][n+1] in bottom up fashion
    # Note: L[i][j] contains length of LCS of X[0..i-1]
    # and Y[0..j-1]
    fori inrange(m+1):
        forj inrange(n+1):
            ifi ==0orj ==0:
                L[i][j] =0
            elifX[i-1] ==Y[j-1]:
                L[i][j] =L[i-1][j-1]+1
            else:
                L[i][j] =max(L[i-1][j], L[i][j-1])

    # L[m][n] contains the length of LCS of X[0..n-1] & Y[0..m-1]
    returnL[m][n]


# Driver code
if__name__ =='__main__':
    S1 =""AGGTAB""
    S2 =""GXTXAYB""
    m =len(S1)
    n =len(S2)
    print(""Length of LCS is"", lcs(S1, S2, m, n))

# This code is contributed by Nikhil Kumar Singh(nickzuck_007)
",O(m * n),O(m * n)
"deflongestCommonSubsequence(text1, text2):
    n =len(text1)
    m =len(text2)

    # Initializing two lists of size m
    prev =[0] *(m +1)
    cur =[0] *(m +1)

    foridx1 inrange(1, n +1):
        foridx2 inrange(1, m +1):
            # If characters are matching
            iftext1[idx1 -1] ==text2[idx2 -1]:
                cur[idx2] =1+prev[idx2 -1]
            else:
                # If characters are not matching
                cur[idx2] =max(cur[idx2 -1], prev[idx2])

        prev =cur.copy()

    returncur[m]

if__name__ =='__main__':
    S1 =""AGGTAB""
    S2 =""GXTXAYB""

    # Function call
    print(""Length of LCS is"", longestCommonSubsequence(S1, S2))
# This code is contributed by Rishabh Mathur
",O(m*n),O(m)
"# A naive Python implementation of LIS problem


# Global variable to store the maximum
globalmaximum


# To make use of recursive calls, this function must return
# two things:
# 1) Length of LIS ending with element arr[n-1]. We use
# max_ending_here for this purpose
# 2) Overall maximum as the LIS may end with an element
# before arr[n-1] max_ref is used this purpose.
# The value of LIS of full array of size n is stored in
# *max_ref which is our final result
def_lis(arr, n):

    # To allow the access of global variable
    globalmaximum

    # Base Case
    ifn ==1:
        return1

    # maxEndingHere is the length of LIS ending with arr[n-1]
    maxEndingHere =1

    # Recursively get all LIS ending with
    # arr[0], arr[1]..arr[n-2]
    # If arr[i-1] is smaller than arr[n-1], and
    # max ending with arr[n-1] needs to be updated,
    # then update it
    fori inrange(1, n):
        res =_lis(arr, i)
        ifarr[i-1] < arr[n-1] andres+1> maxEndingHere:
            maxEndingHere =res +1

    # Compare maxEndingHere with overall maximum. And
    # update the overall maximum if needed
    maximum =max(maximum, maxEndingHere)

    returnmaxEndingHere


deflis(arr):

    # To allow the access of global variable
    globalmaximum

    # Length of arr
    n =len(arr)

    # Maximum variable holds the result
    maximum =1

    # The function _lis() stores its result in maximum
    _lis(arr, n)
    returnmaximum


# Driver program to test the above function
if__name__ =='__main__':
    arr =[10, 22, 9, 33, 21, 50, 41, 60]
    n =len(arr)

    # Function call
    print(""Length of lis is"", lis(arr))

# This code is contributed by NIKHIL KUMAR SINGH
",O(2n),O(1)
"# A Naive Python recursive implementation
# of LIS problem


importsys

# To make use of recursive calls, this
# function must return two things:
# 1) Length of LIS ending with element arr[n-1].
#     We use max_ending_here for this purpose
# 2) Overall maximum as the LIS may end with
#     an element before arr[n-1] max_ref is
#     used this purpose.
# The value of LIS of full array of size n
# is stored in *max_ref which is our final result


deff(idx, prev_idx, n, a, dp):

    if(idx ==n):
        return0

    if(dp[idx][prev_idx +1] !=-1):
        returndp[idx][prev_idx +1]

    notTake =0+f(idx +1, prev_idx, n, a, dp)
    take =-sys.maxsize -1
    if(prev_idx ==-1ora[idx] > a[prev_idx]):
        take =1+f(idx +1, idx, n, a, dp)

    dp[idx][prev_idx +1] =max(take, notTake)
    returndp[idx][prev_idx +1]

# Function to find length of longest increasing
# subsequence.


deflongestSubsequence(n, a):

    dp =[[-1fori inrange(n +1)]forj inrange(n +1)]
    returnf(0, -1, n, a, dp)


# Driver program to test above function
if__name__ =='__main__':
    a =[3, 10, 2, 1, 20]
    n =len(a)

    # Function call
    print(""Length of lis is"", longestSubsequence(n, a))

# This code is contributed by shinjanpatra
",O(N2),O(N2)
"# Dynamic programming Python implementation
# of LIS problem


# lis returns length of the longest
# increasing subsequence in arr of size n
deflis(arr):
    n =len(arr)

    # Declare the list (array) for LIS and
    # initialize LIS values for all indexes
    lis =[1]*n

    # Compute optimized LIS values in bottom up manner
    fori inrange(1, n):
        forj inrange(0, i):
            ifarr[i] > arr[j] andlis[i] < lis[j] +1:
                lis[i] =lis[j]+1

    # Initialize maximum to 0 to get
    # the maximum of all LIS
    maximum =0

    # Pick maximum of all LIS values
    fori inrange(n):
        maximum =max(maximum, lis[i])

    returnmaximum


# Driver program to test above function
if__name__ =='__main__':
    arr =[10, 22, 9, 33, 21, 50, 41, 60]
    print(""Length of lis is"", lis(arr))


# This code is contributed by Nikhil Kumar Singh
",O(N2),O(N)
"# Python 3 program of above approach

# A utility function to get max
# of two integers


defmax(x, y):
    if(x > y):
        returnx
    returny

# Returns the length of the longest
# palindromic subsequence in seq


deflps(seq, i, j):

    # Base Case 1: If there is
    # only 1 character
    if(i ==j):
        return1

    # Base Case 2: If there are only 2
    # characters and both are same
    if(seq[i] ==seq[j] andi +1==j):
        return2

    # If the first and last characters match
    if(seq[i] ==seq[j]):
        returnlps(seq, i +1, j -1) +2

    # If the first and last characters
    # do not match
    returnmax(lps(seq, i, j -1),
               lps(seq, i +1, j))


# Driver Code
if__name__ =='__main__':
    seq =""GEEKSFORGEEKS""
    n =len(seq)
    print(""The length of the LPS is"",
          lps(seq, 0, n -1))

# This code contributed by Rajput-Ji
",O(2n),O(n2)
"# A Dynamic Programming based Python program for LPS problem
# Returns the length of the longest palindromic subsequence
# in seq

dp =[[-1fori inrange(1001)]forj inrange(1001)]

# Returns the length of the longest palindromic subsequence
# in seq


deflps(s1, s2, n1, n2):

    if(n1 ==0orn2 ==0):
        return0

    if(dp[n1][n2] !=-1):
        returndp[n1][n2]

    if(s1[n1 -1] ==s2[n2 -1]):
        dp[n1][n2] =1+lps(s1, s2, n1 -1, n2 -1)
        returndp[n1][n2]
    else:
        dp[n1][n2] =max(lps(s1, s2, n1 -1, n2), lps(s1, s2, n1, n2 -1))
        returndp[n1][n2]

# Driver program to test above functions


seq =""GEEKSFORGEEKS""
n =len(seq)

s2 =seq
s2 =s2[::-1]
print(f""The length of the LPS is {lps(s2, seq, n, n)}"")

# This code is contributed by shinjanpatra
",O(n2),O(n2)
"deflongestPalinSubseq(S):
    R =S[::-1]

    # dp[i][j] will store the length of the longest
    # palindromic subsequence for the substring
    # starting at index i and ending at index j
    dp =[[0] *(len(R) +1) for_ inrange(len(S) +1)]

    # Filling up DP table based on conditions discussed
    # in the above approach
    fori inrange(1, len(S) +1):
        forj inrange(1, len(R) +1):
            ifS[i -1] ==R[j -1]:
                dp[i][j] =1+dp[i -1][j -1]
            else:
                dp[i][j] =max(dp[i][j -1], dp[i -1][j])

    # At the end, DP table will contain the LPS
    # So just return the length of LPS
    returndp[len(S)][len(R)]


# Driver code
s =""GEEKSFORGEEKS""
print(""The length of the LPS is"", longestPalinSubseq(s))

# This code is contributed by shivamgupta310570
",O(n2),O(n2)
"defmerge_sort(arr):
    iflen(arr) > 1:
        # Divide the array into two halves
        mid =len(arr) //2
        left =arr[:mid]
        right =arr[mid:]

        # Recursively sort the two halves
        merge_sort(left)
        merge_sort(right)

        # Merge the sorted halves
        i =j =k =0
        whilei < len(left) andj < len(right):
            ifleft[i] < right[j]:
                arr[k] =left[i]
                i +=1
            else:
                arr[k] =right[j]
                j +=1
            k +=1

        # Copy any remaining elements
        whilei < len(left):
            arr[k] =left[i]
            i +=1
            k +=1
        whilej < len(right):
            arr[k] =right[j]
            j +=1
            k +=1

arr =[5, 2, 4, 6, 1, 3]
merge_sort(arr)
print(arr)
",O(n*log2n),O(n)
"# A recursive python program to find LCA of two nodes
# n1 and n2

# A Binary tree node


classNode:

    # Constructor to create a new node
    def__init__(self, data):
        self.data =data
        self.left =None
        self.right =None

# Function to find LCA of n1 and n2. The function assumes
# that both n1 and n2 are present in BST


deflca(root, n1, n2):

    # Base Case
    ifroot isNone:
        returnNone

    # If both n1 and n2 are smaller than root, then LCA
    # lies in left
    if(root.data > n1 androot.data > n2):
        returnlca(root.left, n1, n2)

    # If both n1 and n2 are greater than root, then LCA
    # lies in right
    if(root.data < n1 androot.data < n2):
        returnlca(root.right, n1, n2)

    returnroot

# Driver program to test above function


# Driver code
root =Node(20)
root.left =Node(8)
root.right =Node(22)
root.left.left =Node(4)
root.left.right =Node(12)
root.left.right.left =Node(10)
root.left.right.right =Node(14)


# Function calls
n1 =10
n2 =14
t =lca(root, n1, n2)
print(""LCA of %d and %d is %d""%(n1, n2, t.data))

n1 =14
n2 =8
t =lca(root, n1, n2)
print(""LCA of %d and %d is %d""%(n1, n2, t.data))

n1 =10
n2 =22
t =lca(root, n1, n2)
print(""LCA of %d and %d is %d""%(n1, n2, t.data))

# This code is contributed by Nikhil Kumar Singh(nickzuck_007)
",O(H),O(H)
"# A recursive python program to find LCA of two nodes
# n1 and n2

# A Binary tree node


classNode:

    # Constructor to create a new node
    def__init__(self, data):
        self.data =data
        self.left =None
        self.right =None

# Function to find LCA of n1 and n2.
# The function assumes that both
#   n1 and n2 are present in BST


deflca(root, n1, n2):
    whileroot:
        # If both n1 and n2 are smaller than root,
        # then LCA lies in left
        ifroot.data > n1 androot.data > n2:
            root =root.left

        # If both n1 and n2 are greater than root,
        # then LCA lies in right
        elifroot.data < n1 androot.data < n2:
            root =root.right

        else:
            break

    returnroot


# Driver code
if__name__ =='__main__':
  root =Node(20)
  root.left =Node(8)
  root.right =Node(22)
  root.left.left =Node(4)
  root.left.right =Node(12)
  root.left.right.left =Node(10)
  root.left.right.right =Node(14)

  # Function calls
  n1 =10
  n2 =14
  t =lca(root, n1, n2)
  print(""LCA of %d and %d is %d""%(n1, n2, t.data))

  n1 =14
  n2 =8
  t =lca(root, n1, n2)
  print(""LCA of %d and %d is %d""%(n1, n2, t.data))

  n1 =10
  n2 =22
  t =lca(root, n1, n2)
  print(""LCA of %d and %d is %d""%(n1, n2, t.data))
# This Code is Contributed by Sumit Bhardwaj (Timus)
",O(H),O(1)
"classTreeNode:
    def__init__(self, x):
        self.val =x
        self.left =None
        self.right =None

# Function to find the lowest common ancestor (LCA)
# of two nodes in a binary tree.
deflowestCommonAncestor(root, p, q):
    curr =root
    whilecurr:
        # If there is no left child, 
        # traverse to the right child.
        ifcurr.left isNone:
            # Check if the current node is one of the target nodes.
            ifcurr ==p orcurr ==q:
                returncurr
            curr =curr.right
        else:
            # If there is a left child, find the in-order predecessor.
            pre =curr.left
            whilepre.right andpre.right !=curr:
                pre =pre.right
            ifpre.right isNone:
                # Set the right child of the 
                # in-order predecessor to the current node.
                pre.right =curr
                curr =curr.left
            else:
                # Remove the link from the in-order
                # predecessor to the current node.
                pre.right =None
                # Check if the current node
                # is one of the target nodes.
                ifcurr ==p orcurr ==q:
                    returncurr
                curr =curr.right
    returnNone

# Driver Code
if__name__ ==""__main__"":
    """"""
    Input Tree:
              5
           /    \
         4       6
          \       \
           3       7
                    \
                     8
    """"""
    root =TreeNode(5)
    root.left =TreeNode(4)
    root.left.right =TreeNode(3)
    root.right =TreeNode(6)
    root.right.right =TreeNode(7)
    root.right.right.right =TreeNode(8)

    p =root.left
    q =root.left.right

    lca1 =lowestCommonAncestor(root, p, q)
    print(f""LCA of {p.val} and {q.val} is {lca1.val}"")

    x =root.right.right
    y =root.right.right.right

    lca2 =lowestCommonAncestor(root, x, y)
    print(f""LCA of {x.val} and {y.val} is {lca2.val}"")
",O(N),O(1)
"# We can use stl container list as a double
# ended queue to store the cache keys, with
# the descending time of reference from front
# to back and a set container to check presence
# of a key. But to fetch the address of the key
# in the list using find(), it takes O(N) time.
# This can be optimized by storing a reference
# (iterator) to each key in a hash map.
classLRUCache:
    # store keys of cache
    def__init__(self, n):
        self.csize =n
        self.dq =[]
        self.ma ={}


    # Refers key x with in the LRU cache
    defrefer(self, x):
        
        #  not present in cache
        ifx notinself.ma.keys():
            # cache is full
            iflen(self.dq) ==self.csize:
                # delete least recently used element
                last =self.dq[-1]

                # Pops the last element
                ele =self.dq.pop();

                # Erase the last
                delself.ma[last]

        # present in cache
        else:
            delself.dq[self.ma[x]]

        # update reference
        self.dq.insert(0, x)
        self.ma[x] =0;

    # Function to display contents of cache
    defdisplay(self):

        # Iterate in the deque and print
        # all the elements in it
        print(self.dq)

# Driver Code
ca =LRUCache(4)

ca.refer(1)
ca.refer(2)
ca.refer(3)
ca.refer(1)
ca.refer(4)
ca.refer(5)
ca.display()
# This code is contributed by Satish Srinivas
",O(1),O(N)
"# Python3 program for solution of M Coloring
# problem using backtracking


classGraph():

    def__init__(self, vertices):
        self.V =vertices
        self.graph =[[0forcolumn inrange(vertices)]
                      forrow inrange(vertices)]

    # A utility function to check
    # if the current color assignment
    # is safe for vertex v
    defisSafe(self, v, colour, c):
        fori inrange(self.V):
            ifself.graph[v][i] ==1andcolour[i] ==c:
                returnFalse
        returnTrue

    # A recursive utility function to solve m
    # coloring  problem
    defgraphColourUtil(self, m, colour, v):
        ifv ==self.V:
            returnTrue

        forc inrange(1, m +1):
            ifself.isSafe(v, colour, c) ==True:
                colour[v] =c
                ifself.graphColourUtil(m, colour, v +1) ==True:
                    returnTrue
                colour[v] =0

    defgraphColouring(self, m):
        colour =[0] *self.V
        ifself.graphColourUtil(m, colour, 0) ==None:
            returnFalse

        # Print the solution
        print(""Solution exist and Following are the assigned colours:"")
        forc incolour:
            print(c, end=' ')
        returnTrue


# Driver Code
if__name__ =='__main__':
    g =Graph(4)
    g.graph =[[0, 1, 1, 1], [1, 0, 1, 0], [1, 1, 0, 1], [1, 0, 1, 0]]
    m =3

    # Function call
    g.graphColouring(m)

# This code is contributed by Divyanshu Mehta
",O(mV),O(V)
"# Python3 program to find Majority
# element in an array

# Function to find Majority
# element in an array


deffindMajority(arr, n):

    maxCount =0
    index =-1# sentinels
    fori inrange(n):

        count =1
        # here we compare the element in 
        # ith position with i+1th position
        forj inrange(i+1, n):

            if(arr[i] ==arr[j]):
                count +=1

        # update maxCount if count of
        # current element is greater
        if(count > maxCount):

            maxCount =count
            index =i

    # if maxCount is greater than n/2
    # return the corresponding element
    if(maxCount > n//2):
        print(arr[index])

    else:
        print(""No Majority Element"")


# Driver code
if__name__ ==""__main__"":
    arr =[1, 1, 2, 1, 3, 5, 1]
    n =len(arr)

    # Function calling
    findMajority(arr, n)

# This code is contributed
# by ChitraNayal
",O(n*n),O(1)
"# Python3 program to demonstrate insert operation in binary
# search tree.
# class for creating node
classNode():
    def__init__(self, data):
        self.data =data
        self.left =None
        self.right =None
        self.count =1# count of number of times data is inserted in tree

# class for binary search tree
# it initialises tree with None root
# insert function inserts node as per BST rule
# and also checks for majority element
# if no majority element is found yet, it returns None


classBST():
    def__init__(self):
        self.root =None

    definsert(self, data, n):
        out =None
        if(self.root ==None):
            self.root =Node(data)
        else:
            out =self.insertNode(self.root, data, n)
        returnout

    definsertNode(self, currentNode, data, n):
        if(currentNode.data ==data):
            currentNode.count +=1
            if(currentNode.count > n//2):
                returncurrentNode.data
            else:
                returnNone
        elif(currentNode.data < data):
            if(currentNode.right):
                self.insertNode(currentNode.right, data, n)
            else:
                currentNode.right =Node(data)
        elif(currentNode.data > data):
            if(currentNode.left):
                self.insertNode(currentNode.left, data, n)
            else:
                currentNode.left =Node(data)


# Driver code
# declaring an array
arr =[3, 2, 3]
n =len(arr)

# declaring None tree
tree =BST()
flag =0
fori inrange(n):
    out =tree.insert(arr[i], n)
    if(out !=None):
        print(arr[i])
        flag =1
        break
if(flag ==0):
    print(""No Majority Element"")
","O(n2), O(nlogn)",O(n)
"# Program for finding out majority element in an array

# Function to find the candidate for Majority


deffindCandidate(A):
    maj_index =0
    count =1
    fori inrange(len(A)):
        ifA[maj_index] ==A[i]:
            count +=1
        else:
            count -=1
        ifcount ==0:
            maj_index =i
            count =1
    returnA[maj_index]

# Function to check if the candidate occurs more than n/2 times


defisMajority(A, cand):
    count =0
    fori inrange(len(A)):
        ifA[i] ==cand:
            count +=1
    ifcount > len(A)/2:
        returnTrue
    else:
        returnFalse

# Function to print Majority Element


defprintMajority(A):
    # Find the candidate for Majority
    cand =findCandidate(A)

    # Print the candidate if it is Majority
    ifisMajority(A, cand) ==True:
        print(cand)
    else:
        print(""No Majority Element"")


# Driver code
A =[1, 3, 3, 1, 2]

# Function call
printMajority(A)
",O(n),O(1)
"# Python3 program for finding out majority 
# element in an array 

deffindMajority(arr, size):
    m ={}
    fori inrange(size):
        ifarr[i] inm:
            m[arr[i]] +=1
        else:
            m[arr[i]] =1
    is_majority_present =False
    forkey inm:
        ifm[key] > size /2:
            is_majority_present =True
            print(""Majority found :-"",key)
            break
    ifnotis_majority_present:
        print(""No Majority element"")

# Driver code 
arr =[2, 2, 2, 2, 5, 5, 2, 3, 3] 
n =len(arr)

# Function calling 
findMajority(arr, n)

# This code is contributed by ankush_953
",O(n),O(n)
"# Python3 program to find Majority 
# element in an array

# Function to find Majority element
# in an array
# it returns -1 if there is no majority element
defmajorityElement(arr, n) :
    
    # sort the array in O(nlogn)
    arr.sort()   
    count, max_ele, temp, f =1, -1, arr[0], 0
    fori inrange(1, n) :
        
        # increases the count if the same element occurs
        # otherwise starts counting new element
        if(temp ==arr[i]) :
            count +=1
        else:
            count =1
            temp =arr[i]
            
        # sets maximum count
        # and stores maximum occurred element so far
        # if maximum count becomes greater than n/2
        # it breaks out setting the flag
        if(max_ele < count) :
            max_ele =count
            ele =arr[i]
            
            if(max_ele > (n//2)) :
                f =1
                break
            
    # returns maximum occurred element
    # if there is no such element, returns -1
    iff ==1:
        returnele
    else:
        return-1

# Driver code
arr =[1, 1, 2, 1, 3, 5, 1]
n =len(arr)

# Function calling 
print(majorityElement(arr, n))

# This code is contributed by divyeshrabadiya07
",O(nlogn),O(1)
"# Function to count the occurrences
defcount_occurrences(arr, num):
    count =0
    fori inarr:
        ifi ==num:
            count +=1
    returncount

# Function to find the majority element using recursion
deffind_majority_util(arr, low, high):
    # Base case: single element array
    iflow ==high:
        returnarr[low]

    # Divide the array into left and right halves
    mid =(low +high) //2
    left_majority =find_majority_util(arr, low, mid)
    right_majority =find_majority_util(arr, mid+1, high)

    # If left and right halves have the same majority element
    ifleft_majority ==right_majority:
        returnleft_majority

    # Count the occurrences of the majority element in the entire array
    left_count =count_occurrences(arr[low:high+1], left_majority)
    right_count =count_occurrences(arr[low:high+1], right_majority)

    # Return the element that occurs more than n/2 times
    ifleft_count > (high-low+1) //2:
        returnleft_majority
    ifright_count > (high-low+1) //2:
        returnright_majority

    # No majority element
    return-1

# Function to find the majority element
deffind_majority(arr):
    n =len(arr)
    majority =find_majority_util(arr, 0, n-1)
    ifmajority !=-1:
        print(majority)
    else:
        print(""No Majority Element"")

# Driver Code
if__name__ ==""__main__"":
    arr =[1, 3, 3, 3, 2]
    n =len(arr)

    find_majority(arr)
    
# This code is contributed by rambabuguphka
",O(N*log N),O(log N)
"# Python code to implement the
# matrix chain multiplication using recursion

importsys

# Matrix A[i] has dimension p[i-1] x p[i]
# for i = 1..n
defMatrixChainOrder(p, i, j):
    ifi ==j:
        return0

    _min =sys.maxsize

    # Place parenthesis at different places
    # between first and last matrix, 
    # recursively calculate count of multiplications 
    # for each parenthesis placement 
    # and return the minimum count
    fork inrange(i, j):

        count =(MatrixChainOrder(p, i, k)
                 +MatrixChainOrder(p, k +1, j)
                 +p[i-1] *p[k] *p[j])

        ifcount < _min:
            _min =count

    # Return minimum count
    return_min


# Driver code
if__name__ =='__main__':
    arr =[1, 2, 3, 4, 3]
    N =len(arr)
    
    # Function call
    print(""Minimum number of multiplications is "",
      MatrixChainOrder(arr, 1, N-1))

# This code is contributed by Aryan Garg
",exponential,O(1)
"# Python program using memoization 
importsys
dp =[[-1fori inrange(100)] forj inrange(100)]

# Function for matrix chain multiplication 
defmatrixChainMemoised(p, i, j):
    if(i ==j):
        return0
    
    if(dp[i][j] !=-1):
        returndp[i][j]
    
    dp[i][j] =sys.maxsize
    
    fork inrange(i,j):
        dp[i][j] =min(dp[i][j], matrixChainMemoised(p, i, k) +matrixChainMemoised(p, k +1, j)+p[i -1] *p[k] *p[j])
    
    returndp[i][j]

defMatrixChainOrder(p,n):
    i =1
    j =n -1
    returnmatrixChainMemoised(p, i, j)

# Driver Code
arr =[1, 2, 3, 4]
n =len(arr)
print(""Minimum number of multiplications is"",MatrixChainOrder(arr, n))

# This code is contributed by rag2127
",O(N3),O(N2)
"# Dynamic Programming Python implementation of Matrix
# Chain Multiplication. See the Cormen book for details
# of the following algorithm
importsys
maxint=int(1e9+7)
# Matrix Ai has dimension p[i-1] x p[i] for i = 1..n


defMatrixChainOrder(p, n):
    # For simplicity of the program, 
    # one extra row and one
    # extra column are allocated in m[][].  
    # 0th row and 0th
    # column of m[][] are not used
    m =[[0forx inrange(n)] forx inrange(n)]

    # m[i, j] = Minimum number of scalar 
    # multiplications needed
    # to compute the matrix A[i]A[i + 1]...A[j] = 
    # A[i..j] where
    # dimension of A[i] is p[i-1] x p[i]

    # cost is zero when multiplying one matrix.
    fori inrange(1, n):
        m[i][i] =0

    # L is chain length.
    forL inrange(2, n):
        fori inrange(1, n-L +1):
            j =i +L-1
            m[i][j] =maxint
            fork inrange(i, j):

                # q = cost / scalar multiplications
                q =m[i][k] +m[k +1][j] +p[i-1]*p[k]*p[j]
                ifq < m[i][j]:
                    m[i][j] =q

    returnm[1][n-1]


# Driver code
arr =[1, 2, 3, 4]
size =len(arr)

print(""Minimum number of multiplications is ""+
      str(MatrixChainOrder(arr, size)))
# This Code is contributed by Bhavya Jain
",O(N3),O(N2)
"# Python3 code for Maximum size
# square sub-matrix with all 1s

defprintMaxSubSquare(M):
    R =len(M)  # no. of rows in M[][]
    C =len(M[0])  # no. of columns in M[][]

    S =[]
    fori inrange(R):
        temp =[]
        forj inrange(C):
            ifi ==0orj ==0:
                temp +=M[i][j],
            else:
                temp +=0,
        S +=temp,
    # here we have set the first row and first column of S same as input matrix, other entries are set to 0

    # Update other entries
    fori inrange(1, R):
        forj inrange(1, C):
            if(M[i][j] ==1):
                S[i][j] =min(S[i][j-1], S[i-1][j],
                              S[i-1][j-1]) +1
            else:
                S[i][j] =0

    # Find the maximum entry and
    # indices of maximum entry in S[][]
    max_of_s =S[0][0]
    max_i =0
    max_j =0
    fori inrange(R):
        forj inrange(C):
            if(max_of_s < S[i][j]):
                max_of_s =S[i][j]
                max_i =i
                max_j =j

    print(""Maximum size sub-matrix is: "")
    fori inrange(max_i, max_i -max_of_s, -1):
        forj inrange(max_j, max_j -max_of_s, -1):
            print(M[i][j], end="" "")
        print("""")


# Driver Program
M =[[0, 1, 1, 0, 1],
     [1, 1, 0, 1, 0],
     [0, 1, 1, 1, 0],
     [1, 1, 1, 1, 0],
     [1, 1, 1, 1, 1],
     [0, 0, 0, 0, 0]]

printMaxSubSquare(M)

# This code is contributed by Soumen Ghosh
",O(m*n),O(m*n)
"# Python code for Maximum size square
# sub-matrix with all 1s
# (space optimized solution)

R =6
C =5


defprintMaxSubSquare(M):

    globalR, C
    Max=0

    # set all elements of S to 0 first
    S =[[0forcol inrange(C)]forrow inrange(2)]

    # Construct the entries
    fori inrange(R):
        forj inrange(C):

            # Compute the entrie at the current position
            Entrie =M[i][j]
            if(Entrie):
                if(j):
                    Entrie =1+min(S[1][j -1], min(S[0][j -1], S[1][j]))

            # Save the last entrie and add the new one
            S[0][j] =S[1][j]
            S[1][j] =Entrie

            # Keep track of the max square length
            Max=max(Max, Entrie)

    # Print the square
    print(""Maximum size sub-matrix is: "")
    fori inrange(Max):
        forj inrange(Max):
            print(""1"", end="" "")
        print()


# Driver code
M =[[0, 1, 1, 0, 1],
     [1, 1, 0, 1, 0],
     [0, 1, 1, 1, 0],
     [1, 1, 1, 1, 0],
     [1, 1, 1, 1, 1],
     [0, 0, 0, 0, 0]]

printMaxSubSquare(M)

# This code is contributed by shinjanpatra
",O(m*n),O(n)
"defmax_matrix_sum(matrix):
    n =len(matrix)  # number of rows in the matrix
    m =len(matrix[0])  # number of columns in the matrix
    max_sum =float('-inf')
    top =0
    bottom =0
    left =0
    right =0

    # Loop for top row position in the rectangle
    fori inrange(n):
        # Loop for left column position of the rectangle
        forj inrange(m):
            # Loop for bottom row in the rectangle
            fork inrange(n):
                # Loop for right column in the rectangle
                forl inrange(m):
                    curr =0
                    # Loop to find the sum of elements in the rectangle
                    forx inrange(i, k+1):
                        # Loop for all possible points of the rectangle
                        fory inrange(j, l+1):
                            curr +=matrix[x][y]
                    # Update the result variables if curr > max_sum
                    ifcurr > max_sum:
                        max_sum =curr
                        top =i
                        left =j
                        right =l
                        bottom =k
    
    print(""(Top, Left): ({}, {})"".format(top, left))
    print(""(Bottom, Right): ({}, {})"".format(bottom, right))
    print(""The sum of this rectangle is:"", max_sum)

matrix =[[1, 2, -1, -4, -20],
          [-8, -3, 4, 2, 1],
          [3, 8, 10, 1, 3],
          [-4, -1, 1, 7, -6]]

max_matrix_sum(matrix)
",O(n^3 * m^3),O(r)
"# Python3 program to find maximum sum
# subarray in a given 2D array

# Implementation of Kadane's algorithm
# for 1D array. The function returns the
# maximum sum and stores starting and
# ending indexes of the maximum sum subarray
# at addresses pointed by start and finish
# pointers respectively.


defkadane(arr, start, finish, n):

    # initialize sum, maxSum and
    Sum=0
    maxSum =-999999999999
    i =None

    # Just some initial value to check
    # for all negative values case
    finish[0] =-1

    # local variable
    local_start =0

    fori inrange(n):
        Sum+=arr[i]
        ifSum< 0:
            Sum=0
            local_start =i +1
        elifSum> maxSum:
            maxSum =Sum
            start[0] =local_start
            finish[0] =i

    # There is at-least one
    # non-negative number
    iffinish[0] !=-1:
        returnmaxSum

    # Special Case: When all numbers
    # in arr[] are negative
    maxSum =arr[0]
    start[0] =finish[0] =0

    # Find the maximum element in array
    fori inrange(1, n):
        ifarr[i] > maxSum:
            maxSum =arr[i]
            start[0] =finish[0] =i
    returnmaxSum

# The main function that finds maximum
# sum rectangle in M[][]


deffindMaxSum(M):
    globalROW, COL

    # Variables to store the final output
    maxSum, finalLeft =-999999999999, None
    finalRight, finalTop, finalBottom =None, None, None
    left, right, i =None, None, None

    temp =[None] *ROW
    Sum=0
    start =[0]
    finish =[0]

    # Set the left column
    forleft inrange(COL):

        # Initialize all elements of temp as 0
        temp =[0] *ROW

        # Set the right column for the left
        # column set by outer loop
        forright inrange(left, COL):

            # Calculate sum between current left
            # and right for every row 'i'
            fori inrange(ROW):
                temp[i] +=M[i][right]

            # Find the maximum sum subarray in
            # temp[]. The kadane() function also
            # sets values of start and finish.
            # So 'sum' is sum of rectangle between
            # (start, left) and (finish, right) which
            # is the maximum sum with boundary columns
            # strictly as left and right.
            Sum=kadane(temp, start, finish, ROW)

            # Compare sum with maximum sum so far.
            # If sum is more, then update maxSum
            # and other output values
            ifSum> maxSum:
                maxSum =Sum
                finalLeft =left
                finalRight =right
                finalTop =start[0]
                finalBottom =finish[0]

    # Prfinal values
    print(""(Top, Left)"", ""("", finalTop,
          finalLeft, "")"")
    print(""(Bottom, Right)"", ""("", finalBottom,
          finalRight, "")"")
    print(""Max sum is:"", maxSum)


# Driver Code
ROW =4
COL =5
M =[[1, 2, -1, -4, -20],
     [-8, -3, 4, 2, 1],
     [3, 8, 10, 1, 3],
     [-4, -1, 1, 7, -6]]

# Function call
findMaxSum(M)

# This code is contributed by PranchalK
",O(c*c*r),O(r)
"# Function to find the maximum sum
defrec(nums, idx):
    ifidx >=len(nums):
        return0
    returnmax(nums[idx] +rec(nums, idx +2), rec(nums, idx +1))

deffindMaxSum(arr, N):
    returnrec(arr, 0)

# Driver Code
if__name__ ==""__main__"":
    # Creating the array
    arr =[5, 5, 10, 100, 10, 5]
    N =len(arr)

    # Function call
    print(findMaxSum(arr, N))
",O(2N),O(2N)
"deffindMaxSum(nums, N):
    dp =[-1] *(N +1)

    defrec(idx, dp):
        ifidx >=len(nums):
            return0
        ifdp[idx] !=-1:
            returndp[idx]
        dp[idx] =max(rec(idx +1, dp), nums[idx] +rec(idx +2, dp))
        returndp[idx]

    returnrec(0, dp)


# Driver Code
arr =[5, 5, 10, 100, 10, 5]
N =len(arr)

print(findMaxSum(arr, N))
",O(N),O(N)+O(N)
"# Python code to implement the approach

# Function to find the maximum sum
deffindMaxSum(arr, N):

    # Declare dp array
    dp =[[0fori inrange(2)] forj inrange(N)]
    
    if(N ==1): 
        returnarr[0]
  
    # Initialize the values in dp array
    dp[0][0] =0
    dp[0][1] =arr[0]
  
    # Loop to find the maximum possible sum
    fori inrange(1,N):
        dp[i][1] =dp[i -1][0] +arr[i]
        dp[i][0] =max(dp[i -1][1], dp[i -1][0])
  
    # Return the maximum sum
    returnmax(dp[N -1][0], dp[N -1][1])

# Driver Code

# Creating the array
arr =[ 5, 5, 10, 100, 10, 5]
N =len(arr)

# Function call
print(findMaxSum(arr, N))

# This code is contributed by shinjanpatra
",O(N),O(N)
"# Python code to implement the approach

# Function to return max sum such that 
# no two elements are adjacent
deffindMaxSum(arr, n):
    incl =0
    excl =0
    fori inarr:
        
        # Current max excluding i
        new_excl =max(excl, incl)
        
        # Current max including i
        incl =excl +i
        excl =new_excl
    
    # Return max of incl and excl
    returnmax(excl, incl)

# Driver code
if__name__ ==""__main__"":
    arr =[5, 5, 10, 100, 10, 5]
    N =6
    
    # Function call
    print(findMaxSum(arr, N))

# This code is contributed by Kalai Selvan
",O(N),O(1)
"# Python program to find the maximum width of
# binary tree using Level Order Traversal.

# A binary tree node


classNode:

    # Constructor to create a new node
    def__init__(self, data):
        self.data =data
        self.left =None
        self.right =None

# Function to get the maximum width of a binary tree


defgetMaxWidth(root):
    maxWidth =0
    h =height(root)
    # Get width of each level and compare the
    # width with maximum width so far
    fori inrange(1, h+1):
        width =getWidth(root, i)
        if(width > maxWidth):
            maxWidth =width
    returnmaxWidth

# Get width of a given level


defgetWidth(root, level):
    ifroot isNone:
        return0
    iflevel ==1:
        return1
    eliflevel > 1:
        return(getWidth(root.left, level-1) +
                getWidth(root.right, level-1))

# UTILITY FUNCTIONS
# Compute the ""height"" of a tree -- the number of
# nodes along the longest path from the root node
# down to the farthest leaf node.


defheight(node):
    ifnode isNone:
        return0
    else:

        # compute the height of each subtree
        lHeight =height(node.left)
        rHeight =height(node.right)

        # use the larger one
        return(lHeight+1) if(lHeight > rHeight) else(rHeight+1)


# Driver code
root =Node(1)
root.left =Node(2)
root.right =Node(3)
root.left.left =Node(4)
root.left.right =Node(5)
root.right.right =Node(8)
root.right.right.left =Node(6)
root.right.right.right =Node(7)

""""""
Constructed binary tree is:
    1
    / \
    2 3
    / \     \
4 5 8 
        / \
        6 7
""""""
# Function call
print(""Maximum width is %d""%(getMaxWidth(root)))

# This code is contributed by Naveen Aili
",O(N2),O(1)
"# Python program to find the maximum width of binary
# tree using Level Order Traversal with queue.

from_collections importdeque

# A binary tree node
classNode:

    # Constructor to create a new node
    def__init__(self, data):
        self.data =data
        self.left =None
        self.right =None

# Function to get the maximum width of a binary tree


defgetMaxWidth(root):
    # base case
    ifroot isNone:
        return0
    q =deque()
    maxWidth =0

    q.append(root)

    whileq:
        # Get the size of queue when the level order
        # traversal for one level finishes
        count =len(q)

        # Update the maximum node count value
        maxWidth =max(count, maxWidth)

        while(count isnot0):
            count =count-1
            temp =q.popleft()
            iftemp.left isnotNone:
                q.append(temp.left)

            iftemp.right isnotNone:
                q.append(temp.right)

    returnmaxWidth


# Driver program to test above function
root =Node(1)
root.left =Node(2)
root.right =Node(3)
root.left.left =Node(4)
root.left.right =Node(5)
root.right.right =Node(8)
root.right.right.left =Node(6)
root.right.right.right =Node(7)

""""""
Constructed binary tree is:
       1
      / \
     2   3
    / \    \
   4   5   8 
          / \
         6   7
""""""
# Function call
print(""Maximum width is %d""%(getMaxWidth(root)))

# This code is contributed by Naveen Aili
",O(N),O(w)
"# Python program to find the maximum width of 
# binary tree using Preorder Traversal.

# A binary tree node


classNode:

    # Constructor to create a new node
    def__init__(self, data):
        self.data =data
        self.left =None
        self.right =None

# Function to get the maximum width of a binary tree


defgetMaxWidth(root):
    h =height(root)
    # Create an array that will store count of nodes at each level
    count =[0] *h

    level =0
    # Fill the count array using preorder traversal
    getMaxWidthRecur(root, count, level)

    # Return the maximum value from count array
    returngetMax(count, h)

# A function that fills count array with count of nodes at every
# level of given binary tree


defgetMaxWidthRecur(root, count, level):
    ifroot isnotNone:
        count[level] +=1
        getMaxWidthRecur(root.left, count, level+1)
        getMaxWidthRecur(root.right, count, level+1)

# UTILITY FUNCTIONS
# Compute the ""height"" of a tree -- the number of
# nodes along the longest path from the root node
# down to the farthest leaf node.


defheight(node):
    ifnode isNone:
        return0
    else:
        # compute the height of each subtree
        lHeight =height(node.left)
        rHeight =height(node.right)
        # use the larger one
        return(lHeight+1) if(lHeight > rHeight) else(rHeight+1)

# Return the maximum value from count array


defgetMax(count, n):
    max=count[0]
    fori inrange(1, n):
        if(count[i] > max):
            max=count[i]
    returnmax


# Driver program to test above function
root =Node(1)
root.left =Node(2)
root.right =Node(3)
root.left.left =Node(4)
root.left.right =Node(5)
root.right.right =Node(8)
root.right.right.left =Node(6)
root.right.right.right =Node(7)

""""""
Constructed binary tree is:
       1
      / \
     2   3
    / \   \
   4   5   8 
          / \
         6   7
""""""

print(""Maximum width is %d""%(getMaxWidth(root)))

# This code is contributed by Naveen Aili
",O(N),O(h)
"# Python program to find the maximum width of 
# binary tree using Preorder Traversal.
 
fromcollections importdeque

# A binary tree node
classNode:
    def__init__(self, data):
        self.data =data
        self.left =None
        self.right =None

# function to find the width of binary tree
defwidthOfBinaryTree(root):
    ifnotroot:
        return0
    ans =0
    q =deque([(root, 0)])
    whileq:
        size =len(q)
        cur_min =q[0][1]
        left_most, right_most =None, None
        fori inrange(size):
            cur_id =q[0][1] -cur_min  # subtracted to prevent integer overflow
            temp, _ =q.popleft()
            ifi ==0:
                left_most =cur_id
            ifi ==size -1:
                right_most =cur_id
            iftemp.left:
                q.append((temp.left, cur_id *2+1))
            iftemp.right:
                q.append((temp.right, cur_id *2+2))
        ans =max(ans, right_most -left_most +1)
    returnans
  
# Utility function to create a new node
defnewNode(data):
    node =Node(data)
    returnnode

# Driver code to test above functions
defmain():
    root =newNode(1)
    root.left =newNode(3)
    root.left.left =newNode(5)
    root.left.left.left =newNode(7)
    root.right =newNode(2)
    root.right.right =newNode(4)
    root.right.right.right =newNode(6)

    maxWidth =widthOfBinaryTree(root)
    print(""The maximum width of the Binary Tree is"", maxWidth)

if__name__ ==""__main__"":
    main()
",O(N),O(N)
"# A Simple Merge based O(n) Python 3 solution 
# to find median of two sorted lists

# This function returns median of ar1[] and ar2[].
# Assumptions in this function:
# Both ar1[] and ar2[] are sorted arrays
# Both have n elements
defgetMedian( ar1, ar2 , n):
    i =0# Current index of i/p list ar1[]
    
    j =0# Current index of i/p list ar2[]
    
    m1 =-1
    m2 =-1
    
    # Since there are 2n elements, median
    # will be average of elements at index
    # n-1 and n in the array obtained after
    # merging ar1 and ar2
    count =0
    whilecount < n +1:
        count +=1
        
        # Below is to handle case where all
        # elements of ar1[] are smaller than
        # smallest(or first) element of ar2[]
        ifi ==n:
            m1 =m2
            m2 =ar2[0]
            break
        
        # Below is to handle case where all 
        # elements of ar2[] are smaller than
        # smallest(or first) element of ar1[]
        elifj ==n:
            m1 =m2
            m2 =ar1[0]
            break
        # equals sign because if two 
        # arrays have some common elements 
        ifar1[i] <=ar2[j]:
            m1 =m2 # Store the prev median
            m2 =ar1[i]
            i +=1
        else:
            m1 =m2 # Store the prev median
            m2 =ar2[j]
            j +=1
    return(m1 +m2)/2

# Driver code to test above function
ar1 =[1, 12, 15, 26, 38]
ar2 =[2, 13, 17, 30, 45]
n1 =len(ar1)
n2 =len(ar2)
ifn1 ==n2:
    print(""Median is "", getMedian(ar1, ar2, n1))
else:
    print(""Doesn't work for arrays of unequal size"")

# This code is contributed by ""Sharad_Bhardwaj"".
",O(n),O(1)
"# Python program for above approach

# function to return median of the arrays
# both are sorted & of same size
defgetMedian(ar1, ar2, n):
    i, j =n -1, 0

    # while loop to swap all smaller numbers to arr1
    while(ar1[i] > ar2[j] andi > -1andj < n):
        ar1[i], ar2[j] =ar2[j], ar1[i]
        i -=1
        j +=1

    ar1.sort()
    ar2.sort()

    return(ar1[-1] +ar2[0]) >> 1


# Driver program
if__name__ =='__main__':
    ar1 =[1, 12, 15, 26, 38]
    ar2 =[2, 13, 17, 30, 45]

    n1, n2 =len(ar1), len(ar2)

    if(n1 ==n2):
        print('Median is', getMedian(ar1, ar2, n1))
    else:
        print(""Doesn't work for arrays of unequal size"")

# This code is contributed by saitejagampala
",O(nlogn),O(1)
"classNode:
    def__init__(self, data):
        self.data =data
        self.next=None

classCircularLinkedList:
    def__init__(self):
        self.head =None

    definsert(self, data):
        new_node =Node(data)

        ifself.head isNone:
            self.head =new_node
            self.head.next=self.head
        else:
            temp =self.head
            whiletemp.next!=self.head:
                temp =temp.next
            temp.next=new_node
            new_node.next=self.head

    defprint(self):
        ifself.head isNone:
            print(""List is empty"")
        else:
            temp =self.head
            whileTrue:
                print(temp.data, end="" "")
                temp =temp.next
                iftemp ==self.head:
                    break
            print()

# Create a CircularLinkedList object
cll =CircularLinkedList()

# Insert elements into the circular linked list
cll.insert(1)
cll.insert(2)
cll.insert(3)

# Print the circular linked list
cll.print()
",O(n),O(n)
"# Python program to Merge an array of  
# size n into another array of size m + n 
 
NA =-1
 
# Function to move m elements 
# at the end of array mPlusN[] 
 
 
defmoveToEnd(mPlusN, size): 
 
    i =0
    j =size -1
    fori inrange(size-1, -1, -1): 
        if(mPlusN[i] !=NA): 
 
            mPlusN[j] =mPlusN[i] 
            j -=1
 
# Merges array N[] 
# of size n into array mPlusN[] 
# of size m+n 
 
 
defmerge(mPlusN, N, m, n): 
 
    i =n  # Current index of i/p part of mPlusN[] 
    j =0# Current index of N[] 
    k =0# Current index of output mPlusN[] 
    while(k < (m+n)): 
 
        # Take an element from mPlusN[] if 
        # a) value of the picked 
        # element is smaller and we have 
        # not reached end of it 
        # b) We have reached end of N[] */ 
        if((j ==n) or(i < (m+n) andmPlusN[i] <=N[j])): 
 
            mPlusN[k] =mPlusN[i] 
            k +=1
            i +=1
 
        else:  # Otherwise take element from N[] 
 
            mPlusN[k] =N[j] 
            k +=1
            j +=1
 
# Utility that prints 
# out an array on a line 
 
 
defprintArray(arr, size): 
 
    fori inrange(size): 
        print(arr[i], "" "", end="""") 
 
    print() 
 
 
# Driver function to 
# test above functions 
 
# Initialize arrays 
mPlusN =[2, 8, NA, NA, NA, 13, NA, 15, 20] 
N =[5, 7, 9, 25] 
n =len(N) 
 
m =len(mPlusN) -n 
 
# Move the m elements 
# at the end of mPlusN 
moveToEnd(mPlusN, m+n) 
 
# Merge N[] into mPlusN[] 
merge(mPlusN, N, m, n) 
 
# Print the resultant mPlusN 
printArray(mPlusN, m+n) 
 
# This code is contributed 
# by Anant Agarwal. 
",O(m+n),O(1)
"# Python program for implementation of MergeSort


defmergeSort(arr):
    iflen(arr) > 1:

         # Finding the mid of the array
        mid =len(arr)//2

        # Dividing the array elements
        L =arr[:mid]

        # Into 2 halves
        R =arr[mid:]

        # Sorting the first half
        mergeSort(L)

        # Sorting the second half
        mergeSort(R)

        i =j =k =0

        # Copy data to temp arrays L[] and R[]
        whilei < len(L) andj < len(R):
            ifL[i] <=R[j]:
                arr[k] =L[i]
                i +=1
            else:
                arr[k] =R[j]
                j +=1
            k +=1

        # Checking if any element was left
        whilei < len(L):
            arr[k] =L[i]
            i +=1
            k +=1

        whilej < len(R):
            arr[k] =R[j]
            j +=1
            k +=1


# Code to print the list
defprintList(arr):
    fori inrange(len(arr)):
        print(arr[i], end="" "")
    print()


# Driver Code
if__name__ =='__main__':
    arr =[12, 11, 13, 5, 6, 7]
    print(""Given array is"")
    printList(arr)
    mergeSort(arr)
    print(""\nSorted array is "")
    printList(arr)

# This code is contributed by Mayank Khanna
",O(N log(N)),O(N)
"# A binary tree node has data, pointer to left child  
# and a pointer to right child
classNode:
    def__init__(self, val):
        self.val =val
        self.left =None
        self.right =None

# A utility function to merge two sorted arrays into one
# Time Complexity of below function: O(m + n)
# Space Complexity of below function: O(m + n)
defmerge_sorted_arr(arr1, arr2):
    arr =[]
    i =j =0
    whilei < len(arr1) andj < len(arr2):
        ifarr1[i] <=arr2[j]:
            arr.append(arr1[i])
            i +=1
        else:
            arr.append(arr2[j])
            j +=1
    whilei < len(arr1):
        arr.append(arr1[i])
        i +=1
    whilei < len(arr2):
        arr.append(arr2[j])
        j +=1
    returnarr

# A helper function that stores inorder
# traversal of a tree in arr
definorder(root, arr =[]):
    ifroot:
        inorder(root.left, arr)
        arr.append(root.val)
        inorder(root.right, arr)

# A utility function to insert the values
# in the individual Tree
definsert(root, val):
    ifnotroot:
        returnNode(val)
    ifroot.val ==val:
        returnroot
    elifroot.val > val:
        root.left =insert(root.left, val)
    else:
        root.right =insert(root.right, val)
    returnroot

# Converts the merged array to a balanced BST
# Explanation of the below code:
# https://www.geeksforgeeks.org/sorted-array-to-balanced-bst/
defarr_to_bst(arr):
    ifnotarr:
        returnNone
    mid =len(arr) //2
    root =Node(arr[mid])
    root.left =arr_to_bst(arr[:mid])
    root.right =arr_to_bst(arr[mid +1:])
    returnroot

if__name__=='__main__':
    root1 =root2 =None
    
    # Inserting values in first tree
    root1 =insert(root1, 100)
    root1 =insert(root1, 50)
    root1 =insert(root1, 300)
    root1 =insert(root1, 20)
    root1 =insert(root1, 70)
    
    # Inserting values in second tree
    root2 =insert(root2, 80)
    root2 =insert(root2, 40)
    root2 =insert(root2, 120)
    arr1 =[]
    inorder(root1, arr1)
    arr2 =[]
    inorder(root2, arr2)
    arr =merge_sorted_arr(arr1, arr2)
    root =arr_to_bst(arr)
    res =[]
    inorder(root, res)
    print('Following is Inorder traversal of the merged tree')
    fori inres:
      print(i, end =' ')
      
# This code is contributed by Flarow4
",O(m+n),O(m+n)
"# Python program to Merge two BSTs with limited extra space

# Structure of a BST Node


classNode:
    def__init__(self, val):
        self.val =val
        self.left =None
        self.right =None


defmergeTwoBST(root1, root2):
    res =[]
    s1, s2 =[], []

    whileroot1 orroot2 ors1 ors2:
        whileroot1:
            s1.append(root1)
            root1 =root1.left

        whileroot2:
            s2.append(root2)
            root2 =root2.left

        # Step 3 Case 1:-
        ifnots2 or(s1 ands1[-1].val <=s2[-1].val):
            root1 =s1[-1]
            dels1[-1]
            res.append(root1.val)
            root1 =root1.right

        #  Step 3 case 2 :-
        else:
            root2 =s2[-1]
            dels2[-1]
            res.append(root2.val)
            root2 =root2.right

    returnres


# Driver program to test above functions
if__name__ =='__main__':
    root1 =None
    root2 =None

    ''' 
    Let us create the following tree as first tree
             3
            / \
           1   5
    '''

    root1 =Node(3)
    root1.left =Node(1)
    root1.right =Node(5)

    ''' 
    Let us create the following tree as second tree
             4
            / \
           2   6
    '''

    root2 =Node(4)
    root2.left =Node(2)
    root2.right =Node(6)

    ans =mergeTwoBST(root1, root2)
    forx inans:
        print(x, end="" "")

# This code is contributed by Tapesh(tapeshdua420)
",O(M+N),O(H1 + H2)
"# Python program to Merge two BSTs with limited extra space

# Structure of a BST Node


classNode:
    def__init__(self, val):
        self.val =val
        self.left =None
        self.right =None


defmergeTwoBST(root1, root2):
    res =[]
    s1, s2 =[], []

    whileroot1 orroot2 ors1 ors2:
        whileroot1:
            s1.append(root1)
            root1 =root1.left

        whileroot2:
            s2.append(root2)
            root2 =root2.left

        # Step 3 Case 1:-
        ifnots2 or(s1 ands1[-1].val <=s2[-1].val):
            root1 =s1[-1]
            dels1[-1]
            res.append(root1.val)
            root1 =root1.right

        #  Step 3 case 2 :-
        else:
            root2 =s2[-1]
            dels2[-1]
            res.append(root2.val)
            root2 =root2.right

    returnres


# Driver program to test above functions
if__name__ =='__main__':
    root1 =None
    root2 =None

    ''' 
    Let us create the following tree as first tree
             3
            / \
           1   5
    '''

    root1 =Node(3)
    root1.left =Node(1)
    root1.right =Node(5)

    ''' 
    Let us create the following tree as second tree
             4
            / \
           2   6
    '''

    root2 =Node(4)
    root2.left =Node(2)
    root2.right =Node(6)

    ans =mergeTwoBST(root1, root2)
    forx inans:
        print(x, end="" "")

# This code is contributed by Tapesh(tapeshdua420)
",O(M+N),O(H1 + H2)
"classNode:
    def__init__(self, data):
      # Utility function to create a new Binary Tree Node
        self.data =data
        self.left =None
        self.right =None


classBinaryTree:
    def__init__(self):
        self.root =None

    definsert(self, data):
        self.root =self.insertRec(self.root, data)

    definsertRec(self, root, data):
        ifroot isNone:
            root =Node(data)
            returnroot

        ifdata < root.data:
            root.left =self.insertRec(root.left, data)
        elifdata > root.data:
            root.right =self.insertRec(root.right, data)

        returnroot

    # convert sorted Double linked list
    defconvertIntoSortedDLL(self, root, head):
      # base case
        ifroot isNone:
            return

        self.convertIntoSortedDLL(root.right, head)
        root.right =head[0]

        ifhead[0] isnotNone:
            head[0].left =root

        head[0] =root

        self.convertIntoSortedDLL(root.left, head)

    # Merge sorted Double linked list
    defmergeLinkedList(self, head1, head2):
        dummy =Node(0)

        # tail points to the last result node
        tail =dummy

        # so tail->next is the place to
      # add new nodes to the result.
        whileTrue:
            ifhead1 isNone:
              # if either list runs out, use the
              # other list
                tail.right =head2
                break

            ifhead2 isNone:
                tail.right =head1
                break

            ifhead1.data <=head2.data:
                tail.right =head1
                head1.left =tail
                head1 =head1.right
            else:
                tail.right =head2
                head2.left =tail
                head2 =head2.right

            tail =tail.right

        res =dummy.right
        res.left =None
        returnres

    # Function to print nodes in a given linked list
    defprintList(self, node):
        whilenode isnotNone:
            print(node.data, end="" "")
            node =node.right


if__name__ ==""__main__"":
    tree1 =BinaryTree()
    tree2 =BinaryTree()

    # Let us create the following tree as first tree
    #       3
    #       / \
    #     1   5

    tree1.insert(3)
    tree1.insert(1)
    tree1.insert(5)

    # Let us create the following tree as second tree
    #         4
    #         / \
    #       2   6

    tree2.insert(4)
    tree2.insert(2)
    tree2.insert(6)

    # Convert BST into sorted DLL
    head1 =[None]
    head2 =[None]

    tree1.convertIntoSortedDLL(tree1.root, head1)
    tree2.convertIntoSortedDLL(tree2.root, head2)

    # merge sorted DLL
    ans =tree1.mergeLinkedList(head1[0], head2[0])

    tree1.printList(ans)
",O(M+N),"O(max(H1,H2))"
"# A Naive recursive implementation of MCP(Minimum Cost Path) problem
importsys
R =3
C =3

# Returns cost of minimum cost path from (0,0) to (m, n) in mat[R][C]


defminCost(cost, m, n):
    if(n < 0orm < 0):
        returnsys.maxsize
    elif(m ==0andn ==0):
        returncost[m][n]
    else:
        returncost[m][n] +min(minCost(cost, m-1, n-1),
                                minCost(cost, m-1, n),
                                minCost(cost, m, n-1))

# A utility function that returns minimum of 3 integers */


defmin(x, y, z):
    if(x < y):
        returnx if(x < z) elsez
    else:
        returny if(y < z) elsez


# Driver code
cost =[[1, 2, 3],
        [4, 8, 2],
        [1, 5, 3]]
print(minCost(cost, 2, 2))

# This code is contributed by
# Smitha Dinesh Semwal
",O((M * N)3),O(M + N)
"R =3
C =3

# Returns cost of minimum cost path
# from (0,0) to (m, n) in mat[R][C]
defmin_cost_memoized(cost, m, n, memo):
    ifn < 0orm < 0:
        returnfloat('inf')
    elifm ==0andn ==0:
        returncost[m][n]

    ifmemo[m][n] !=-1:
        returnmemo[m][n]

    memo[m][n] =cost[m][n] +min(
        min_cost_memoized(cost, m -1, n -1, memo),
        min_cost_memoized(cost, m -1, n, memo),
        min_cost_memoized(cost, m, n -1, memo)
    )

    returnmemo[m][n]

# Returns cost of minimum cost path
# from (0,0) to (m, n) in mat[R][C]
defmin_cost(cost, m, n):
    memo =[[-1] *C for_ inrange(R)]  # Initialize memo table with -1

    returnmin_cost_memoized(cost, m, n, memo)

# Driver code
cost =[
    [1, 2, 3],
    [4, 8, 2],
    [1, 5, 3]
]

print(min_cost(cost, 2, 2))
",O(M * N),O(M * N)
"# Python3 program for the
# above approach


defminCost(cost, row, col):

    # For 1st column
    fori inrange(1, row):
        cost[i][0] +=cost[i -1][0]

    # For 1st row
    forj inrange(1, col):
        cost[0][j] +=cost[0][j -1]

    # For rest of the 2d matrix
    fori inrange(1, row):
        forj inrange(1, col):
            cost[i][j] +=(min(cost[i -1][j -1],
                               min(cost[i -1][j],
                                   cost[i][j -1])))

    # Returning the value in
    # last cell
    returncost[row -1][col -1]


# Driver code
if__name__ =='__main__':

    row =3
    col =3

    cost =[[1, 2, 3],
            [4, 8, 2],
            [1, 5, 3]]

    print(minCost(cost, row, col))

# This code is contributed by Amit Katiyar
",O(M * N),O(M * N)
"# Python3 program for the
# above approach


defminCost(cost, row, col):

    # For 1st column
    fori inrange(1, row):
        cost[i][0] +=cost[i -1][0]

    # For 1st row
    forj inrange(1, col):
        cost[0][j] +=cost[0][j -1]

    # For rest of the 2d matrix
    fori inrange(1, row):
        forj inrange(1, col):
            cost[i][j] +=(min(cost[i -1][j -1],
                               min(cost[i -1][j],
                                   cost[i][j -1])))

    # Returning the value in
    # last cell
    returncost[row -1][col -1]


# Driver code
if__name__ =='__main__':

    row =3
    col =3

    cost =[[1, 2, 3],
            [4, 8, 2],
            [1, 5, 3]]

    print(minCost(cost, row, col))

# This code is contributed by Amit Katiyar
",O(N * M),O(1)
"# Minimum Cost Path using Dijkstras shortest path
#  algorithm with Min Heap by dinglizeng
# Python3

# Define the number of rows and the number of columns
R =4
C =5

# 8 possible moves 
dx =[ 1, -1, 0, 0, 1, 1, -1, -1] 
dy =[ 0, 0, 1, -1, 1, -1, 1, -1] 

# The data structure to store the coordinates of 
#  the unit square and the cost of path from the top 
#  left. 
classCell(): 
    def__init__(self, x, y, z): 
        self.x =x 
        self.y =y 
        self.cost =z 

# To verify whether a move is within the boundary. 
defisSafe(x, y): 
    return(x >=0andx < R and
            y >=0andy < C) 

# This solution is based on Dijkstras shortest
#  path algorithm 
# For each unit square being visited, we examine all
#  possible next moves in 8 directions, 
# calculate the accumulated cost of path for each
#  next move, adjust the cost of path of the adjacent 
#  units to the minimum as needed. 
# then add the valid next moves into a Min Heap. 
# The Min Heap pops out the next move with the minimum 
# accumulated cost of path. 
# Once the iteration reaches the last unit at the lower 
# right corner, the minimum cost path will be returned. 
defminCost(cost, m, n): 

    # the array to store the accumulated cost
    # of path from top left corner 
    dp =[[0forx inrange(C)] forx inrange(R)] 

    # the array to record whether a unit
    # square has been visited 
    visited =[[Falseforx inrange(C)] 
                forx inrange(R)] 

    # Initialize these two arrays, set path cost 
    # to maximum integer value, each unit as 
    # not visited 
    fori inrange(R): 
        forj inrange(C): 
            dp[i][j] =float(""Inf"") 
            visited[i][j] =False

    # Define a reverse priority queue. 
    # Priority queue is a heap based implementation. 
    # The default behavior of a priority queue is
    # to have the maximum element at the top. 
    # The compare class is used in the definition of
    # the Min Heap. 
    pq =[] 

    # initialize the starting top left unit with the 
    # cost and add it to the queue as the first move. 
    dp[0][0] =cost[0][0] 
    pq.append(Cell(0, 0, cost[0][0])) 

    while(len(pq)): 
    
        # pop a move from the queue, ignore the units 
        # already visited 
        cell =pq[0] 
        pq.pop(0) 
        x =cell.x 
        y =cell.y 
        if(visited[x][y]): 
            continue

        # mark the current unit as visited 
        visited[x][y] =True

        # examine all non-visited adjacent units in 8
        # directions 
        # calculate the accumulated cost of path for
        # each next move from this unit, 
        # adjust the cost of path for each next
        # adjacent units to the minimum if possible. 
        fori inrange(8): 
            next_x =x +dx[i] 
            next_y =y +dy[i] 
            if(isSafe(next_x, next_y) and
                notvisited[next_x][next_y]): 
                dp[next_x][next_y] =min(dp[next_x][next_y],
                                        dp[x][y] +cost[next_x][next_y]) 
                pq.append(Cell(next_x, next_y, 
                                dp[next_x][next_y])) 

    # return the minimum cost path at the lower 
    # right corner 
    returndp[m][n] 

# Driver code 
cost =[[1, 8, 8, 1, 5], 
        [4, 1, 1, 8, 1], 
        [4, 2, 8, 8, 1], 
        [1, 5, 8, 8, 1]] 
print(minCost(cost, 3, 4)) 
",O(V + E * logV),O(N*M)
"# Python3 program to find maximum
# cash flow among a set of persons

# Number of persons(or vertices in graph)
N =3

# A utility function that returns
# index of minimum value in arr[]
defgetMin(arr):
    
    minInd =0
    fori inrange(1, N):
        if(arr[i] < arr[minInd]):
            minInd =i
    returnminInd

# A utility function that returns
# index of maximum value in arr[]
defgetMax(arr):

    maxInd =0
    fori inrange(1, N):
        if(arr[i] > arr[maxInd]):
            maxInd =i
    returnmaxInd

# A utility function to
# return minimum of 2 values
defminOf2(x, y):

    returnx ifx < y elsey

# amount[p] indicates the net amount to
# be credited/debited to/from person 'p'
# If amount[p] is positive, then i'th 
# person will amount[i]
# If amount[p] is negative, then i'th
# person will give -amount[i]
defminCashFlowRec(amount):

    # Find the indexes of minimum
    # and maximum values in amount[]
    # amount[mxCredit] indicates the maximum
    # amount to be given(or credited) to any person.
    # And amount[mxDebit] indicates the maximum amount
    # to be taken (or debited) from any person.
    # So if there is a positive value in amount[], 
    # then there must be a negative value
    mxCredit =getMax(amount)
    mxDebit =getMin(amount)

    # If both amounts are 0, 
    # then all amounts are settled
    if(amount[mxCredit] ==0andamount[mxDebit] ==0):
        return0

    # Find the minimum of two amounts
    min=minOf2(-amount[mxDebit], amount[mxCredit])
    amount[mxCredit] -=min
    amount[mxDebit] +=min

    # If minimum is the maximum amount to be
    print(""Person "", mxDebit , "" pays "", min
        , "" to "", ""Person "", mxCredit)

    # Recur for the amount array. Note that
    # it is guaranteed that the recursion
    # would terminate as either amount[mxCredit] 
    # or amount[mxDebit] becomes 0
    minCashFlowRec(amount)

# Given a set of persons as graph[] where
# graph[i][j] indicates the amount that
# person i needs to pay person j, this
# function finds and prints the minimum 
# cash flow to settle all debts.
defminCashFlow(graph):

    # Create an array amount[],
    # initialize all value in it as 0.
    amount =[0fori inrange(N)]

    # Calculate the net amount to be paid
    # to person 'p', and stores it in amount[p].
    # The value of amount[p] can be calculated by
    # subtracting debts of 'p' from credits of 'p'
    forp inrange(N):
        fori inrange(N):
            amount[p] +=(graph[i][p] -graph[p][i])

    minCashFlowRec(amount)
    
# Driver code

# graph[i][j] indicates the amount
# that person i needs to pay person j
graph =[ [0, 1000, 2000],
          [0, 0, 5000],
          [0, 0, 0] ]

minCashFlow(graph)

# This code is contributed by Anant Agarwal.
",O(N2),O(N)
"# Program to find minimum number of platforms
# required on a railway station


deffindPlatform(arr, dep, n):
    '''
    Accepts two arrays with arrival and departure time
    and the size of the array
    Returns minimum number of platforms required
    '''

    # plat_needed indicates number of platforms
    # needed at a time
    plat_needed =1
    result =1

    # run a nested loop to find overlap
    fori inrange(n):
        # minimum platform needed
        plat_needed =1

        forj inrange(n):
            # check for overlap
            ifi !=j:
                if(arr[i] >=arr[j] anddep[j] >=arr[i]):
                    plat_needed +=1

        # update result
        result =max(result, plat_needed)

    returnresult

# Driver code


defmain():
    arr =[100, 300, 500]
    dep =[900, 400, 600]

    n =len(arr)

    print(""{}"".format(
        findPlatform(arr, dep, n)))


if__name__ =='__main__':
    main()
",O(n2),O(1)
"importheapq
# Function to find the minimum number
# of platforms required


deffindPlatform(arr, dep, n):
    arr2 =[]
    # Store the arrival and departure time
    fori inrange(n):
        arr2.append([arr[i], dep[i]])
    arr2.sort()  # Sort trains based on arrival time
    p =[]
    count =1
    heapq.heappush(p, arr2[0][1])
    fori inrange(1, n):
        # Check if arrival time of current train
        # is less than or equals to departure time
        # of previous train
        ifp[0] >=arr2[i][0]:
            count +=1
        else:
            heapq.heappop(p)
        heapq.heappush(p, arr2[i][1])
    # return the count of number of platforms required
    returncount


if__name__ ==""__main__"":
    arr =[900, 940, 950, 1100, 1500, 1800]
    dep =[910, 1200, 1120, 1130, 1900, 2000]
    n =len(arr)
    print(findPlatform(arr, dep, n))
",O(N*log(N)),O(1)
"# Program to find minimum
# number of platforms
# required on a railway
# station

# Returns minimum number
# of platforms required


deffindPlatform(arr, dep, n):

    # Sort arrival and
    # departure arrays
    arr.sort()
    dep.sort()

    # plat_needed indicates
    # number of platforms
    # needed at a time
    plat_needed =1
    result =1
    i =1
    j =0

    # Similar to merge in
    # merge sort to process
    # all events in sorted order
    while(i < n andj < n):

        # If next event in sorted
        # order is arrival,
        # increment count of
        # platforms needed
        if(arr[i] <=dep[j]):

            plat_needed +=1
            i +=1

        # Else decrement count
        # of platforms needed
        elif(arr[i] > dep[j]):

            plat_needed -=1
            j +=1

        # Update result if needed
        if(plat_needed > result):
            result =plat_needed

    returnresult

# Driver code


arr =[900, 940, 950, 1100, 1500, 1800]
dep =[910, 1200, 1120, 1130, 1900, 2000]
n =len(arr)

print(""Minimum Number of Platforms Required = "",
      findPlatform(arr, dep, n))

# This code is contributed
# by Anant Agarwal.
",O(N * log N),O(1)
"fromtyping importList

# Function to find the minimum number of platforms required.
deffind_platform_optimized(arr: List[int], dep: List[int], n: int) -> int:

    count =0
    max_platforms =0

    # Find the maximum departure time
    max_departure_time =max(dep)

    # Create a list to store the count of trains at each time
    v =[0] *(max_departure_time +2)

    # Increment the count at the arrival time and decrement at the departure time
    fori inrange(n):
        v[arr[i]] +=1
        v[dep[i] +1] -=1

    # Iterate over the list and keep track of the maximum sum seen so far
    fori inrange(max_departure_time +2):
        count +=v[i]
        max_platforms =max(max_platforms, count)

    returnmax_platforms

# Driver Code
if__name__ =='__main__':
    arr =[100, 300, 600]
    dep =[900, 400, 500]
    n =len(arr)
    print(find_platform_optimized(arr, dep, n))
",O(n),O(1)
"# Function to multiply two numbers
# x and y
defmultiply(x,y):

    # 0 multiplied with anything
    # gives 0 
    if(y ==0):
        return0

    # Add x one by one 
    if(y > 0):
        return(x +multiply(x, y -1))

    # The case where y is negative
    if(y < 0):
        return-multiply(x, -y)
    
# Driver code
print(multiply(5, -11))

# This code is contributed by Anant Agarwal.
",O(y),O(y)
"# Python3 program to Multiply two integers without
# using multiplication, division and bitwise
# operators, and no loops

# divide a number by 2 recursively
defdivideby2(num):

    if(num < 2):
        return0
    return1+divideby2(num-2)

defmultiply(a, b):
    whole_square =(a +b) **2
    a_square =pow(a, 2)
    b_square =pow(b, 2)

    val =whole_square -a_square -b_square

    # for positive value of variable val
    if(val >=0):
        product =divideby2(val)
        
    # for negative value of variable val
    # we first compute the division by 2 for
    # positive val and by subtracting from
    # 0 we can make it negative
    else:
        product =0-divideby2(abs(val))

    returnproduct

# Driver code
a =5
b =-11
print(multiply(a, b))

# This code is contributed by phasing17
",O(num),O(num)
"# Simple Python3 program to multiply two polynomials 
 
# A[] represents coefficients of first polynomial 
# B[] represents coefficients of second polynomial 
# m and n are sizes of A[] and B[] respectively 
defmultiply(A, B, m, n): 
 
    prod =[0] *(m +n -1); 
     
    # Multiply two polynomials term by term 
     
    # Take ever term of first polynomial 
    fori inrange(m): 
         
        # Multiply the current term of first  
        # polynomial with every term of  
        # second polynomial. 
        forj inrange(n): 
            prod[i +j] +=A[i] *B[j]; 
 
    returnprod; 
 
# A utility function to print a polynomial 
defprintPoly(poly, n): 
 
    fori inrange(n): 
        print(poly[i], end =""""); 
        if(i !=0): 
            print(""x^"", i, end =""""); 
        if(i !=n -1): 
            print("" + "", end =""""); 
 
# Driver Code 
 
# The following array represents 
# polynomial 5 + 10x^2 + 6x^3 
A =[5, 0, 10, 6]; 
 
# The following array represents  
# polynomial 1 + 2x + 4x^2 
B =[1, 2, 4]; 
m =len(A); 
n =len(B); 
 
print(""First polynomial is ""); 
printPoly(A, m); 
print(""\nSecond polynomial is ""); 
printPoly(B, n); 
 
prod =multiply(A, B, m, n); 
 
print(""\nProduct polynomial is ""); 
printPoly(prod, m+n-1); 
 
# This code is contributed by chandan_jnu 
",O(mn),O(m + n)
"# Python3 program to solve N Queen
# Problem using backtracking

globalN
N =4


defprintSolution(board):
    fori inrange(N):
        forj inrange(N):
            ifboard[i][j] ==1:
                print(""Q"",end="" "")
            else:
                print(""."",end="" "")
        print()


# A utility function to check if a queen can
# be placed on board[row][col]. Note that this
# function is called when ""col"" queens are
# already placed in columns from 0 to col -1.
# So we need to check only left side for
# attacking queens
defisSafe(board, row, col):

    # Check this row on left side
    fori inrange(col):
        ifboard[row][i] ==1:
            returnFalse

    # Check upper diagonal on left side
    fori, j inzip(range(row, -1, -1),
                    range(col, -1, -1)):
        ifboard[i][j] ==1:
            returnFalse

    # Check lower diagonal on left side
    fori, j inzip(range(row, N, 1),
                    range(col, -1, -1)):
        ifboard[i][j] ==1:
            returnFalse

    returnTrue


defsolveNQUtil(board, col):

    # Base case: If all queens are placed
    # then return true
    ifcol >=N:
        returnTrue

    # Consider this column and try placing
    # this queen in all rows one by one
    fori inrange(N):

        ifisSafe(board, i, col):

            # Place this queen in board[i][col]
            board[i][col] =1

            # Recur to place rest of the queens
            ifsolveNQUtil(board, col +1) ==True:
                returnTrue

            # If placing queen in board[i][col
            # doesn't lead to a solution, then
            # queen from board[i][col]
            board[i][col] =0

    # If the queen can not be placed in any row in
    # this column col then return false
    returnFalse


# This function solves the N Queen problem using
# Backtracking. It mainly uses solveNQUtil() to
# solve the problem. It returns false if queens
# cannot be placed, otherwise return true and
# placement of queens in the form of 1s.
# note that there may be more than one
# solutions, this function prints one of the
# feasible solutions.
defsolveNQ():
    board =[[0, 0, 0, 0],
             [0, 0, 0, 0],
             [0, 0, 0, 0],
             [0, 0, 0, 0]]

    ifsolveNQUtil(board, 0) ==False:
        print(""Solution does not exist"")
        returnFalse

    printSolution(board)
    returnTrue


# Driver Code
if__name__ =='__main__':
    solveNQ()

# This code is contributed by Divyanshu Mehta
",O(N!),O(N2)
"# Python3 program to solve N Queen Problem using
# backtracking
N =4

# ld is an array where its indices indicate row-col+N-1
# (N-1) is for shifting the difference to store negative
# indices
ld =[0] *30

# rd is an array where its indices indicate row+col
# and used to check whether a queen can be placed on
# right diagonal or not
rd =[0] *30

# Column array where its indices indicates column and
# used to check whether a queen can be placed in that
# row or not
cl =[0] *30


# A utility function to print solution
defprintSolution(board):
    fori inrange(N):
        forj inrange(N):
            print(board[i][j], end="" "")
        print()


# A recursive utility function to solve N
# Queen problem
defsolveNQUtil(board, col):

    # Base case: If all queens are placed
    # then return True
    if(col >=N):
        returnTrue

    # Consider this column and try placing
    # this queen in all rows one by one
    fori inrange(N):

        # Check if the queen can be placed on board[i][col]

        # To check if a queen can be placed on 
        # board[row][col] We just need to check 
        # ld[row-col+n-1] and rd[row+coln]
        # where ld and rd are for left and 
        # right diagonal respectively
        if((ld[i -col +N -1] !=1and
             rd[i +col] !=1) andcl[i] !=1):

            # Place this queen in board[i][col]
            board[i][col] =1
            ld[i -col +N -1] =rd[i +col] =cl[i] =1

            # Recur to place rest of the queens
            if(solveNQUtil(board, col +1)):
                returnTrue

            # If placing queen in board[i][col]
            # doesn't lead to a solution,
            # then remove queen from board[i][col]
            board[i][col] =0# BACKTRACK
            ld[i -col +N -1] =rd[i +col] =cl[i] =0

            # If the queen cannot be placed in
            # any row in this column col then return False
    returnFalse


# This function solves the N Queen problem using
# Backtracking. It mainly uses solveNQUtil() to
# solve the problem. It returns False if queens
# cannot be placed, otherwise, return True and
# prints placement of queens in the form of 1s.
# Please note that there may be more than one
# solutions, this function prints one of the
# feasible solutions.
defsolveNQ():
    board =[[0, 0, 0, 0],
             [0, 0, 0, 0],
             [0, 0, 0, 0],
             [0, 0, 0, 0]]
    if(solveNQUtil(board, 0) ==False):
        printf(""Solution does not exist"")
        returnFalse
    printSolution(board)
    returnTrue


# Driver Code
if__name__ =='__main__':
    solveNQ()

# This code is contributed by SHUBHAMSINGH10
",O(N!),O(N)
""""""" Python3 program to solve N Queen Problem 
using Branch or Bound """"""

N =8

"""""" A utility function to print solution """"""
defprintSolution(board):
    fori inrange(N):
        forj inrange(N):
            print(board[i][j], end ="" "")
        print()

"""""" A Optimized function to check if 
a queen can be placed on board[row][col] """"""
defisSafe(row, col, slashCode, backslashCode, 
           rowLookup, slashCodeLookup, 
                       backslashCodeLookup):
    if(slashCodeLookup[slashCode[row][col]] or
        backslashCodeLookup[backslashCode[row][col]] or
        rowLookup[row]):
        returnFalse
    returnTrue

"""""" A recursive utility function 
   to solve N Queen problem """"""
defsolveNQueensUtil(board, col, slashCode, backslashCode, 
                     rowLookup, slashCodeLookup,
                     backslashCodeLookup):
                        
    """""" base case: If all queens are 
       placed then return True """"""
    if(col >=N):
        returnTrue
    fori inrange(N):
        if(isSafe(i, col, slashCode, backslashCode, 
                  rowLookup, slashCodeLookup,
                  backslashCodeLookup)):
                    
            """""" Place this queen in board[i][col] """"""
            board[i][col] =1
            rowLookup[i] =True
            slashCodeLookup[slashCode[i][col]] =True
            backslashCodeLookup[backslashCode[i][col]] =True
            
            """""" recur to place rest of the queens """"""
            if(solveNQueensUtil(board, col +1, 
                                slashCode, backslashCode, 
                                rowLookup, slashCodeLookup, 
                                backslashCodeLookup)):
                returnTrue
            
            """""" If placing queen in board[i][col] 
            doesn't lead to a solution,then backtrack """"""
            
            """""" Remove queen from board[i][col] """"""
            board[i][col] =0
            rowLookup[i] =False
            slashCodeLookup[slashCode[i][col]] =False
            backslashCodeLookup[backslashCode[i][col]] =False
            
    """""" If queen can not be place in any row in 
    this column col then return False """"""
    returnFalse

"""""" This function solves the N Queen problem using 
Branch or Bound. It mainly uses solveNQueensUtil()to 
solve the problem. It returns False if queens 
cannot be placed,otherwise return True or 
prints placement of queens in the form of 1s. 
Please note that there may be more than one 
solutions,this function prints one of the 
feasible solutions.""""""
defsolveNQueens():
    board =[[0fori inrange(N)] 
                forj inrange(N)]
    
    # helper matrices 
    slashCode =[[0fori inrange(N)] 
                    forj inrange(N)]
    backslashCode =[[0fori inrange(N)] 
                        forj inrange(N)]
    
    # arrays to tell us which rows are occupied 
    rowLookup =[False] *N
    
    # keep two arrays to tell us 
    # which diagonals are occupied 
    x =2*N -1
    slashCodeLookup =[False] *x
    backslashCodeLookup =[False] *x
    
    # initialize helper matrices 
    forrr inrange(N):
        forcc inrange(N):
            slashCode[rr][cc] =rr +cc
            backslashCode[rr][cc] =rr -cc +7
    
    if(solveNQueensUtil(board, 0, slashCode, backslashCode, 
                        rowLookup, slashCodeLookup, 
                        backslashCodeLookup) ==False):
        print(""Solution does not exist"")
        returnFalse
        
    # solution found 
    printSolution(board)
    returnTrue

# Driver Code
solveNQueens()

# This code is contributed by SHUBHAMSINGH10
",O(N!),O(N^2)
"# Python3 program for Naive Pattern
# Searching algorithm


defsearch(pat, txt):
    M =len(pat)
    N =len(txt)

    # A loop to slide pat[] one by one */
    fori inrange(N -M +1):
        j =0

        # For current index i, check
        # for pattern match */
        while(j < M):
            if(txt[i +j] !=pat[j]):
                break
            j +=1

        if(j ==M):
            print(""Pattern found at index "", i)


# Driver's Code
if__name__ =='__main__':
    txt =""AABAACAADAABAAABAA""
    pat =""AABA""
    
    # Function call
    search(pat, txt)

# This code is contributed
# by PrinciRaj1992
",O(N2),O(1)
"# Function to sort an array using
# insertion sort


definsertionSort(A, size):
    i, key, j =0, 0, 0
    fori inrange(size):
        key =A[i]
        j =i-1

        # Move elements of A[0..i-1], that are
        # greater than key, to one position
        # ahead of their current position.
        # This loop will run at most k times
        whilej >=0andA[j] > key:
            A[j +1] =A[j]
            j =j -1
        A[j +1] =key
",O(N*K),O(1)
"defsortNearlySortedArray(A, size, k):
    fori inrange(1, size):
        key =A[i]
        j =i -1

        # Check if the previous element is greater than the current
        # element, and shift elements to the right until the correct
        # position is found, but only if the current element is more
        # than k positions away from its correct position
        whilej >=max(0, i -k) andA[j] > key:
            A[j +1] =A[j]
            j -=1
        A[j +1] =key

    fori inrange(size):
        print(A[i], end=' ')

    print()

# Driver Code
A =[2, 6, 3, 12, 56, 8]
size =6
k =3
sortNearlySortedArray(A, size, k)
",O(nk),O(1)
"# A Python3 program to sort a
# nearly sorted array.

fromheapq importheappop, heappush, heapify


# A utility function to print
# array elements
defprint_array(arr: list):
    forelem inarr:
        print(elem, end=' ')

# Given an array of size n, where every
# element is k away from its target
# position, sorts the array in O(nLogk) time.


defsort_k(arr: list, n: int, k: int):
    """"""
    :param arr: input array
    :param n: length of the array
    :param k: max distance, which every 
     element is away from its target position.
    :return: None
    """"""
    # List of first k+1 items
    heap =arr[:k +1]

    # using heapify to convert list
    # into heap(or min heap)
    heapify(heap)

    # ""rem_elmnts_index"" is index for remaining
    # elements in arr and ""target_index"" is
    # target index of for current minimum element
    # in Min Heap ""heap"".
    target_index =0

    # here even if size=k then n will be n=k,so i<n works fine
    forrem_elmnts_index inrange(k +1, n):
        arr[target_index] =heappop(heap)
        heappush(heap, arr[rem_elmnts_index])
        target_index +=1

    whileheap:
        arr[target_index] =heappop(heap)
        target_index +=1


# Driver Code
k =3
arr =[2, 6, 3, 12, 56, 8]
n =len(arr)
sort_k(arr, n, k)

print_array(arr)

# This code is contributed by
# Veerat Beri(viratberi)
",O(K) + O(m * log(k)),O(K) + O(m * log(k))
"# Python3 code
classSolution:
    defnextLargerElement(self, arr, n):
        # code here
        s =[]
        fori inrange(len(arr)):
            whiles ands[-1].get(""value"") < arr[i]:
                d =s.pop()
                arr[d.get(""ind"")] =arr[i]
            s.append({""value"": arr[i], ""ind"": i})
        whiles:
            d =s.pop()
            arr[d.get(""ind"")] =-1
        returnarr


if__name__ ==""__main__"":
    print(Solution().nextLargerElement([6, 8, 0, 1, 3], 5))
",O(N2),O(1)
"# Python3 code
classSolution:
    defnextLargerElement(self, arr, n):
        # code here
        s =[]
        fori inrange(len(arr)):
            whiles ands[-1].get(""value"") < arr[i]:
                d =s.pop()
                arr[d.get(""ind"")] =arr[i]
            s.append({""value"": arr[i], ""ind"": i})
        whiles:
            d =s.pop()
            arr[d.get(""ind"")] =-1
        returnarr


if__name__ ==""__main__"":
    print(Solution().nextLargerElement([6, 8, 0, 1, 3], 5))
",O(N),O(N)
"# Python3 code
classSolution:
    defnextLargerElement(self, arr, n):
        # code here
        s =[]
        fori inrange(len(arr)):
            whiles ands[-1].get(""value"") < arr[i]:
                d =s.pop()
                arr[d.get(""ind"")] =arr[i]
            s.append({""value"": arr[i], ""ind"": i})
        whiles:
            d =s.pop()
            arr[d.get(""ind"")] =-1
        returnarr


if__name__ ==""__main__"":
    print(Solution().nextLargerElement([6, 8, 0, 1, 3], 5))
",O(N),O(N)
"# Function to Check if a substring is a palindrome
defis_palindrome(string, i, j):

    whilei < j:
        ifstring[i] !=string[j]:
            returnFalse
        i +=1
        j -=1
    returnTrue

#  Function to find the minimum number of cuts needed for palindrome partitioning


defmin_pal_partition(string, i, j):

    # Base case: If the substring is empty or a palindrome, no cuts needed
    ifi >=j oris_palindrome(string, i, j):
        return0

    ans =float('inf')

    # Iterate through all possible partitions and find the minimum cuts needed
    fork inrange(i, j):
        count =min_pal_partition(string, i, k) +\
            min_pal_partition(string, k +1, j) +1
        ans =min(ans, count)

    returnans


# Driver code
if__name__ ==""__main__"":
    str=""ababbbabbababa""

    # Find the minimum cuts needed for palindrome partitioning and display the result
    print(""Min cuts needed for Palindrome Partitioning is"",
          min_pal_partition(str, 0, len(str) -1))
",O(2n),O(n)
"# Dynamic Programming Solution for
# Palindrome Partitioning Problem

# Returns the minimum number of
# cuts needed to partition a string
# such that every part is a palindrome


defminPalPartion(str):

    # Get the length of the string
    n =len(str)

    # Create two arrays to build the
    # solution in bottom up manner
    # C[i][j] = Minimum number of cuts
    # needed for palindrome
    # partitioning of substring str[i..j]
    # P[i][j] = true if substring str[i..j]
    # is palindrome, else false. Note that
    # C[i][j] is 0 if P[i][j] is true
    C =[[0fori inrange(n)]
         fori inrange(n)]
    P =[[Falsefori inrange(n)]
         fori inrange(n)]

    # different looping variables
    j =0
    k =0
    L =0

    # Every substring of length
    # 1 is a palindrome
    fori inrange(n):
        P[i][i] =True
        C[i][i] =0

    # L is substring length. Build the
    # solution in bottom-up manner by
    # considering all substrings of
    # length starting from 2 to n.
    # The loop structure is the same as
    # Matrix Chain Multiplication problem
    # (See https://www.geeksforgeeks.org / matrix-chain-multiplication-dp-8/ )
    forL inrange(2, n +1):

        # For substring of length L, set
        # different possible starting indexes
        fori inrange(n -L +1):
            j =i +L -1# Set ending index

            # If L is 2, then we just need to
            # compare two characters. Else
            # need to check two corner characters
            # and value of P[i + 1][j-1]
            ifL ==2:
                P[i][j] =(str[i] ==str[j])
            else:
                P[i][j] =((str[i] ==str[j]) and
                           P[i +1][j -1])

            # IF str[i..j] is palindrome,
            # then C[i][j] is 0
            ifP[i][j] ==True:
                C[i][j] =0
            else:

                # Make a cut at every possible
                # location starting from i to j,
                # and get the minimum cost cut.
                C[i][j] =100000000
                fork inrange(i, j):
                    C[i][j] =min(C[i][j], C[i][k] +
                                  C[k +1][j] +1)

    # Return the min cut value for
    # complete string. i.e., str[0..n-1]
    returnC[0][n -1]


# Driver code
str=""ababbbabbababa""
print('Min cuts needed for Palindrome Partitioning is',
      minPalPartion(str))

# This code is contributed
# by Sahil shelangia
",O(n3),O(n2)
"defgenerate_palindrome(s, pal):
    n =len(s)

    # Initialize the palindrome matrix for single characters
    fori inrange(n):
        pal[i][i] =True

    # Iterate over different lengths of substrings
    forlength inrange(2, n +1):
        # Iterate over the starting positions of substrings of current length
        fori inrange(n -length +1):
            # Calculate the ending position of the substring
            j =i +length -1

            # Check if the characters at the starting and ending positions are equal
            # and if the substring between them is a palindrome or a single character
            ifs[i] ==s[j] and(length ==2orpal[i +1][j -1]):
                # Mark the substring from i to j as a palindrome
                pal[i][j] =True


defmin_cut(s):
    ifnots:
        return0
    n =len(s)

    # 2D list to store whether substring [i, j] is a palindrome
    pal =[[False] *n for_ inrange(n)]

    generate_palindrome(s, pal)

    # List to store minimum cuts required to make substring [i, n-1] palindromic
    min_cut_dp =[float('inf')] *n

    # There is no cut required for a single character as it is always a palindrome
    min_cut_dp[0] =0

    # Iterate over the given string
    fori inrange(1, n):
        # Check if string 0 to i is a palindrome. Then minCut required will be 0.
        ifpal[0][i]:
            min_cut_dp[i] =0
        else:
            forj inrange(i, 0, -1):
                # If s[i] and s[j] are equal and the inner substring [i+1, j-1]
                # is a palindrome or it has a length of 1
                ifpal[j][i]:
                    # Update the minimum cuts required if cutting at position 'j+1' results in a smaller value
                    ifmin_cut_dp[j -1] +1< min_cut_dp[i]:
                        min_cut_dp[i] =min_cut_dp[j -1] +1

    # Return the minimum cuts required for the entire string 's'
    returnmin_cut_dp[n -1]


# Driver code
if__name__ ==""__main__"":
    str=""ababbbabbababa""

    cuts =min_cut(str)
    print(""Minimum cuts required:"", cuts)
",O(n2),O(n2)
"# Python 3 code for Pascal's Triangle
# A simple O(n^3) 
# program for 
# Pascal's Triangle

# Function to print 
# first n lines of
# Pascal's Triangle
defprintPascal(n) :
    
    # Iterate through every line 
    # and print entries in it
    forline inrange(0, n) :
        
        # Every line has number of 
        # integers equal to line
        # number
        fori inrange(0, line +1) :
            print(binomialCoeff(line, i),
                "" "", end ="""")
        print()
    

# See https://www.geeksforgeeks.org/space-and-time-efficient-binomial-coefficient/
# for details of this function
defbinomialCoeff(n, k) :
    res =1
    if(k > n -k) :
        k =n -k
    fori inrange(0, k) :
        res =res *(n -i)
        res =res //(i +1)
    
    returnres

# Driver program
n =7
printPascal(n)


# This code is contributed by Nikita Tiwari.
",O(N^3),O(1)
"# Python3 program for Pascal's Triangle

# A O(n^2) time and O(n^2) extra 
# space method for Pascal's Triangle
defprintPascal(n:int):

    # An auxiliary array to store 
    # generated pascal triangle values
    arr =[[0forx inrange(n)] 
              fory inrange(n)] 

    # Iterate through every line
    # and print integer(s) in it
    forline inrange(0, n):

        # Every line has number of 
        # integers equal to line number
        fori inrange(0, line +1):

            # First and last values 
            # in every row are 1
            if(i is0ori isline):
                arr[line][i] =1
                print(arr[line][i], end ="" "") 

            # Other values are sum of values
            # just above and left of above 
            else:
                arr[line][i] =(arr[line -1][i -1] +
                                arr[line -1][i])
                print(arr[line][i], end ="" "")             
        print(""\n"", end ="""")

# Driver Code
n =5
printPascal(n)

# This code is contributed 
# by Sanju Maderna
",O(N^2),O(N^2)
"# Python3 program for Pascal's Triangle 
# A O(n^2) time and O(1) extra 
# space method for Pascal's Triangle 

# Pascal function 
defprintPascal(n): 

    forline inrange(1, n +1): 
        C =1; # used to represent C(line, i) 
        fori inrange(1, line +1): 
            
            # The first value in a 
            # line is always 1 
            print(C, end ="" ""); 
            C =int(C *(line -i) /i); 
        print(""""); 

# Driver code 
n =5; 
printPascal(n);

# This code is contributed by mits
",O(n2),O(1)
"classSuffixTrieNode:
    def__init__(self):
        self.children =[None] *256
        self.indexes =[]

    definsert_suffix(self, suffix, index):
        self.indexes.append(index)
        ifsuffix:
            c_index =ord(suffix[0])
            ifnotself.children[c_index]:
                self.children[c_index] =SuffixTrieNode()
            self.children[c_index].insert_suffix(suffix[1:], index +1)
            
    defsearch(self, pat):
        ifnotpat:
            returnself.indexes
        c_index =ord(pat[0])
        ifself.children[c_index]:
            returnself.children[c_index].search(pat[1:])
        returnNone

classSuffixTrie:
    def__init__(self, txt):
        self.root =SuffixTrieNode()
        fori inrange(len(txt)):
            self.root.insert_suffix(txt[i:], i)
    
    defsearch(self, pat):
        result =self.root.search(pat)
        ifnotresult:
            print(""Pattern not found"")
        else:
            pat_len =len(pat)
            fori inresult:
                print(f""Pattern found at position {i - pat_len}"")

if__name__ ==""__main__"":
    # Let us build the suffix trie for text ""geeksforgeeks.org""
    txt =""geeksforgeeks.org""
    st =SuffixTrie(txt)

    # Let us search for different patterns
    pat =""ee""
    print(f""Search for '{pat}'"")
    st.search(pat)
    print()

    pat =""geek""
    print(f""Search for '{pat}'"")
    st.search(pat)
    print()
    
    pat =""quiz""
    print(f""Search for '{pat}'"")
    st.search(pat)
    print()
    
    pat =""forgeeks""
    print(f""Search for '{pat}'"")
    st.search(pat)
    print()
",O(m+k),O(n * MAX_CHAR)
"# Python program to implement persistent segment tree.

MAXN =100

# data type for individual node in the segment tree
classNode:
    def__init__(self, left=None, right=None, val=0):
        # stores sum of the elements in node
        self.val =val
        # pointer to left and right children
        self.left =left
        self.right =right

# input array
arr =[0] *MAXN

# root pointers for all versions
version =[None] *MAXN

# Constructs Version-0
# Time Complexity : O(nlogn)
defbuild(n, low, high):
    iflow ==high:
        n.val =arr[low]
        return
    mid =(low+high) //2
    n.left =Node()
    n.right =Node()
    build(n.left, low, mid)
    build(n.right, mid+1, high)
    n.val =n.left.val +n.right.val

# Upgrades to new Version
# @param prev : points to node of previous version
# @param cur  : points to node of current version
# Time Complexity : O(logn)
# Space Complexity : O(logn)
defupgrade(prev, cur, low, high, idx, value):
    ifidx > high oridx < low orlow > high:
        return

    iflow ==high:
        # modification in new version
        cur.val =value
        return

    mid =(low+high) //2
    ifidx <=mid:
        # link to right child of previous version
        cur.right =prev.right

        # create new node in current version
        cur.left =Node()

        upgrade(prev.left,cur.left, low, mid, idx, value)
    else:
        # link to left child of previous version
        cur.left =prev.left

        # create new node for current version
        cur.right =Node()

        upgrade(prev.right, cur.right, mid+1, high, idx, value)

    # calculating data for current version
    # by combining previous version and current
    # modification
    cur.val =cur.left.val +cur.right.val

defquery(n, low, high, l, r):
    ifl > high orr < low orlow > high:
        return0
    ifl <=low andhigh <=r:
        returnn.val
    mid =(low+high) //2
    p1 =query(n.left,low,mid,l,r)
    p2 =query(n.right,mid+1,high,l,r)
    returnp1+p2

if__name__ =='__main__':
    A =[1,2,3,4,5]
    n =len(A)

    fori inrange(n):
        arr[i] =A[i]

    # creating Version-0
    root =Node()
    build(root, 0, n-1)

    # storing root node for version-0
    version[0] =root

    # upgrading to version-1
    version[1] =Node()
    upgrade(version[0], version[1], 0, n-1, 4, 1)

    # upgrading to version-2
    version[2] =Node()
    upgrade(version[1], version[2], 0, n-1, 2, 5)

    # querying in version-0
    print(""In version 0 , query(0,3) :"",query(version[0], 0, n-1, 0, 3)) 

    # querying in version-1
    print(""In version 1 , query(0,4) :"",query(version[1], 0, n-1, 0, 4)) 

    # querying in version-2
    print(""In version 2 , query(3,4) :"",query(version[2], 0, n-1, 3, 4))
",O(1),O(log n)
"# python3 program for the above approach


defspiralOrder(matrix):
    ans =[]

    if(len(matrix) ==0):
        returnans

    m =len(matrix)
    n =len(matrix[0])
    seen =[[0fori inrange(n)] forj inrange(m)]
    dr =[0, 1, 0, -1]
    dc =[1, 0, -1, 0]
    x =0
    y =0
    di =0

    # Iterate from 0 to R * C - 1
    fori inrange(m *n):
        ans.append(matrix[x][y])
        seen[x][y] =True
        cr =x +dr[di]
        cc =y +dc[di]

        if(0<=cr andcr < m and0<=cc andcc < n andnot(seen[cr][cc])):
            x =cr
            y =cc
        else:
            di =(di +1) %4
            x +=dr[di]
            y +=dc[di]
    returnans


# Driver code
if__name__ ==""__main__"":
    a =[[1, 2, 3, 4],
         [5, 6, 7, 8],
         [9, 10, 11, 12],
         [13, 14, 15, 16]]

    # Function call
    forx inspiralOrder(a):
        print(x, end="" "")
    print()
",O(N),O(N)
"# Python3 program to print
# given matrix in spiral form


defspiralPrint(m, n, a):
    k =0
    l =0

    ''' k - starting row index
        m - ending row index
        l - starting column index
        n - ending column index
        i - iterator '''

    while(k < m andl < n):

        # Print the first row from
        # the remaining rows
        fori inrange(l, n):
            print(a[k][i], end="" "")

        k +=1

        # Print the last column from
        # the remaining columns
        fori inrange(k, m):
            print(a[i][n -1], end="" "")

        n -=1

        # Print the last row from
        # the remaining rows
        if(k < m):

            fori inrange(n -1, (l -1), -1):
                print(a[m -1][i], end="" "")

            m -=1

        # Print the first column from
        # the remaining columns
        if(l < n):
            fori inrange(m -1, k -1, -1):
                print(a[i][l], end="" "")

            l +=1


# Driver Code
a =[[1, 2, 3, 4],
     [5, 6, 7, 8],
     [9, 10, 11, 12],
     [13, 14, 15, 16]]

R =4
C =4

# Function Call
spiralPrint(R, C, a)

# This code is contributed by Nikita Tiwari.
",O(M*N),O(1)
"# Python3 program for the above approach

# Function for printing matrix in spiral
# form i, j: Start index of matrix, row
# and column respectively m, n: End index
# of matrix row and column respectively


defprintdata(arr, i, j, m, n):

    # If i or j lies outside the matrix
    if(i >=m orj >=n):
        return

    # Print First Row
    forp inrange(i, n):
        print(arr[i][p], end="" "")

    # Print Last Column
    forp inrange(i +1, m):
        print(arr[p][n -1], end="" "")

    # Print Last Row, if Last and
    # First Row are not same
    if((m -1) !=i):
        forp inrange(n -2, j -1, -1):
            print(arr[m -1][p], end="" "")

    # Print First Column, if Last and
    # First Column are not same
    if((n -1) !=j):
        forp inrange(m -2, i, -1):
            print(arr[p][j], end="" "")

    printdata(arr, i +1, j +1, m -1, n -1)


# Driver code
if__name__ ==""__main__"":
    R =4
    C =4
    arr =[[1, 2, 3, 4],
           [5, 6, 7, 8],
           [9, 10, 11, 12],
           [13, 14, 15, 16]]

    # Function Call
    printdata(arr, 0, 0, R, C)

# This code is contributed by avsadityavardhan
",O(M*N),O(1)
"# Python3 program for the above approach

R =4
C =4


defisInBounds(i, j):
    globalR
    globalC
    if(i < 0ori >=R orj < 0orj >=C):
        returnFalse
    returnTrue

# Check if the position is blocked


defisBlocked(matrix, i, j):
    if(notisInBounds(i, j)):
        returnTrue
    if(matrix[i][j] ==-1):
        returnTrue

    returnFalse

# DFS code to traverse spirally


defspirallyDFSTraverse(matrix, i, j, Dir, res):
    if(isBlocked(matrix, i, j)):
        return

    allBlocked =True
    fork inrange(-1, 2, 2):
        allBlocked =allBlocked andisBlocked(
            matrix, k +i, j) andisBlocked(matrix, i, j +k)

    res.append(matrix[i][j])
    matrix[i][j] =-1
    if(allBlocked):
        return

    # dir: 0 - right, 1 - down, 2 - left, 3 - up
    nxt_i =i
    nxt_j =j
    nxt_dir =Dir
    if(Dir==0):
        if(notisBlocked(matrix, i, j +1)):
            nxt_j +=1
        else:
            nxt_dir =1
            nxt_i +=1

    elif(Dir==1):
        if(notisBlocked(matrix, i +1, j)):
            nxt_i +=1
        else:
            nxt_dir =2
            nxt_j -=1

    elif(Dir==2):
        if(notisBlocked(matrix, i, j -1)):
            nxt_j -=1
        else:
            nxt_dir =3
            nxt_i -=1

    elif(Dir==3):
        if(notisBlocked(matrix, i -1, j)):
            nxt_i -=1
        else:
            nxt_dir =0
            nxt_j +=1

    spirallyDFSTravserse(matrix, nxt_i, nxt_j, nxt_dir, res)

# To traverse spirally


defspirallyTraverse(matrix):
    res =[]
    spirallyDFSTravserse(matrix, 0, 0, 0, res)
    returnres


# Driver code
if__name__ ==""__main__"":
    a =[[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]

    # Function Call
    res =spirallyTraverse(a)
    print(*res)

# This code is contributed by rag2127
",O(M*N),O(1)
"# Python program to print ancestors of given node in
# binary tree

# A Binary Tree node
classNode:

    # Constructor to create a new node
    def__init__(self, data):
        self.data =data 
        self.left =None
        self.right =None

# If target is present in tree, then prints the ancestors
# and returns true, otherwise returns false
defprintAncestors(root, target):
    
    # Base case
    ifroot ==None:
        returnFalse
    
    ifroot.data ==target:
        returnTrue

    # If target is present in either left or right subtree 
    # of this node, then print this node
    if(printAncestors(root.left, target) or
        printAncestors(root.right, target)):
        print(root.data,end=' ')
        returnTrue

    # Else return False 
    returnFalse

# Driver program to test above function
root =Node(1)
root.left =Node(2)
root.right =Node(3)
root.left.left =Node(4)
root.left.right =Node(5)
root.left.left.left =Node(7)

printAncestors(root, 7)

# This code is contributed by Nikhil Kumar Singh(nickzuck_007)
",O(n),O(h)
"classNode:
    def__init__(self, data):
        self.data =data
        self.left =None
        self.right =None

defprint_ancestors(root, target):
    st =[]
    whileroot orst:
        whileroot androot.data !=target:
            st.append(root)
            root =root.left
        
        ifroot androot.data ==target:
            break
        
        ifst andnotst[-1].right:
            root =st.pop()
            whilest andst[-1].right ==root:
                root =st.pop()
        
        root =st[-1].right ifst elseNone

    ifst:
        whilest:
            print(st[-1].data, end=' ')
            st.pop()
        returnTrue
    
    returnFalse

defnew_node(data):
    returnNode(data)

# Driver code
""""""
Construct the following binary tree
            1
          /   \
        2      3
      /  \
    4     5
   /
  7
""""""
root =new_node(1)
root.left =new_node(2)
root.right =new_node(3)
root.left.left =new_node(4)
root.left.right =new_node(5)
root.left.left.left =new_node(7)

print_ancestors(root, 7)
",O(n),O(h)
"# Python 3 program to Print all elements 
# in sorted order from row and column 
# wise sorted matrix
importsys

INF =sys.maxsize
N =4

# A utility function to youngify a Young 
# Tableau. This is different from standard 
# youngify. It assumes that the value at 
# mat[0][0] is infinite.
defyoungify(mat, i, j):

    # Find the values at down and
    # right sides of mat[i][j]
    downVal =mat[i +1][j] if(i +1< N) elseINF
    rightVal =mat[i][j +1] if(j +1< N) elseINF

    # If mat[i][j] is the down right
    # corner element, return
    if(downVal ==INF andrightVal ==INF):
        return

    # Move the smaller of two values 
    # (downVal and rightVal) to mat[i][j] 
    # and recur for smaller value
    if(downVal < rightVal):
        mat[i][j] =downVal
        mat[i +1][j] =INF
        youngify(mat, i +1, j)
    
    else:
        mat[i][j] =rightVal
        mat[i][j +1] =INF
        youngify(mat, i, j +1)

# A utility function to extract minimum 
# element from Young tableau
defextractMin(mat):

    ret =mat[0][0]
    mat[0][0] =INF
    youngify(mat, 0, 0)
    returnret

# This function uses extractMin() to 
# print elements in sorted order
defprintSorted(mat):
        
    print(""Elements of matrix in sorted order n"")
    i =0
    whilei < N *N: 
        print(extractMin(mat), end ="" "")
        i +=1

# Driver Code
if__name__ ==""__main__"":
    
    mat =[[10, 20, 30, 40],
           [15, 25, 35, 45],
           [27, 29, 37, 48],
           [32, 33, 39, 50]]
    printSorted(mat)

# This code is contributed by ita_c
",O(N3),O(N2)
"# Function to print all elements of matrix in sorted orderd
defsortedMatrix(N, Mat):
    temp =[]

    # Store all elements of matrix into temp
    fori inrange(0, N):
        forj inrange(0, N):
            temp.append(Mat[i][j])

    # Sort the temp
    temp.sort()

    # Print the values of temp
    fori inrange(len(temp)):
        print(temp[i], end=' ')


if__name__ ==""__main__"":
    N =4
    Mat =[[10, 20, 30, 40], [15, 25, 35, 45],
           [27, 29, 37, 48], [32, 33, 39, 50]]
    sortedMatrix(N, list(Mat))

# This code is contributed by Aarti_Rathi
",O(N2log(N2)),O(N2)
"# Python code to merge k sorted arrays of size n each.

N =4

# A min heap node
classMinHeapNode:
    def__init__(self, element, i, j):
        self.element =element  # The element to be stored
        self.i =i  # index of the row from which the element is taken
        self.j =j  # index of the next element to be picked from row


# A class for Min Heap
classMinHeap:
    def__init__(self, a, size):
        self.harr =a  # pointer to array of elements in heap
        self.heapSize =size  # size of min heap

        # Build heap
        i =(self.heapSize -1) //2
        whilei >=0:
            self.minHeapify(i)
            i -=1

    defminHeapify(self, i):
        l =self.left(i)
        r =self.right(i)
        smallest =i
        ifl < self.heapSize andself.harr[l].element < self.harr[i].element:
            smallest =l
        ifr < self.heapSize andself.harr[r].element < self.harr[smallest].element:
            smallest =r
        ifsmallest !=i:
            temp =self.harr[i]
            self.harr[i] =self.harr[smallest]
            self.harr[smallest] =temp
            self.minHeapify(smallest)

    # to get index of left child of node at index i
    defleft(self, i): return2*i +1

    # to get index right child of node at index i
    defright(self, i): return2*i +2
    
    # to get the root 
    defgetMin(self):
        returnself.harr[0]
    
    # to replace root with new node x and heapify() new root
    defreplaceMin(self, x):
        self.harr[0] =x 
        self.minHeapify(0)
    
    defswap(x, y):
        x.element, y.element =y.element, x.element

# This function prints elements of a given matrix in non-decreasing
# order. It assumes that ma[][] is sorted row wise sorted.
defprintSorted(mat):
    # Create a min heap with k heap nodes. Every heap node
    # has first element of an array
    harr =[MinHeapNode(mat[i][0], i, 1) fori inrange(N)]
    heap =MinHeap(harr, N) # Create the min heap

    # Now one by one get the minimum element from min
    # heap and replace it with next element of its array
    forcount inrange(N*N):
        # Get the minimum element and store it in output
        root =heap.getMin()
        print(root.element, end="" "")

        # Find the next element that will replace current
        # root of heap. The next element belongs to same
        # array as the current root.
        if(root.j < N):
            root.element =mat[root.i][root.j]
            root.j +=1
        # If root was the last element of its array
        else:
            root.element =float('inf')

        # Replace root with next element of array
        heap.replaceMin(root)

# Test
mat =[
[10, 20, 30, 40],
[15, 25, 35, 45],
[27, 29, 37, 48],
[32, 33, 39, 50]
]

printSorted(mat)


# This code is contributed by phasing17
",O(N2LogN),O(N)
"# Python program to find the nodes at k distance from root

# A Binary tree node
classNode:
    
    # Constructor to create a new node
    def__init__(self, data):
        self.data =data
        self.left =None
        self.right =None

defprintKDistant(root, k):
    
    ifroot isNone:
        return
    ifk ==0:
        print(root.data,end=' ')
    else:
        printKDistant(root.left, k-1)
        printKDistant(root.right, k-1)

# Driver program to test above function
""""""
   Constructed binary tree is
            1
          /   \
        2      3
      /  \    /
    4     5  8 
""""""
root =Node(1)
root.left =Node(2)
root.right =Node(3)
root.left.left =Node(4)
root.left.right =Node(5)
root.right.left =Node(8)

printKDistant(root, 2)

# This code is contributed by Nikhil Kumar Singh(nickzuck_007)
",O(n),O(height of the binary tree)
"# Python program to find the nodes at k distance from root

# A Binary tree node
classNode:

    # Constructor to create a new node
    def__init__(self, data):
        self.data =data
        self.left =None
        self.right =None

defprintKDistant(root, k):
   # check if root is None
    ifroot isNone:
        return
    q =[]
    # ans = []
    q.append(root)
    lvl =0# tracking of level
    while(q):
        n =len(q)
        # when lvl becomes k we add all values of q in ans.
        iflvl ==k:

            fori inrange(n):
                print((q[i].data), end="" "")
            return

        fori inrange(1, n+1):
            temp =q.pop(0)
            iftemp.left:
                q.append(temp.left)
            iftemp.right:
                q.append(temp.right)
        lvl +=1
    # if after traversing ,if lvl is less than k ,
    # that means nodes at k distance does not exist.
    iflvl < k:
        return

# Driver program to test above function
""""""
   Constructed binary tree is
            1
          /   \
        2      3
      /  \    /
    4     5  8 
""""""
root =Node(1)
root.left =Node(2)
root.right =Node(3)
root.left.left =Node(4)
root.left.right =Node(5)
root.right.left =Node(8)

printKDistant(root, 2)
#this code is contributed by Vivek Maddeshiya
",O(n),O(n)
"classNode:
    def__init__(self, data):
        self.data =data
        self.left =self.right =None

defnewNode(data):
    node =Node(data)
    returnnode

defKdistance(root, k):
    result =[]  # To store nodes at distance K from the root
    stack =[]   # Stack for iterative traversal
    stack.append((root, 0))  # Push root node with level 0

    whilestack:
        curr, level =stack.pop()  # Pop current node and its level

        ifcurr isNone:
            continue# Skip if current node is None

        iflevel ==k:
            result.append(curr.data)  # If current level is K, add the data to result

        # Push right child onto the stack with its level incremented by 1
        stack.append((curr.right, level +1))

        # Push left child onto the stack with its level incremented by 1
        stack.append((curr.left, level +1))

    returnresult

# Driver code to test above functions
# Create the binary tree
root =newNode(10)
root.left =newNode(10)
root.right =newNode(4)
root.left.left =newNode(4)
root.left.right =newNode(10)

k =1
result =Kdistance(root, k)

# Print the nodes at distance K from the root
iflen(result) ==0:
    print(f""No nodes found at distance {k} from the root."")
else:
    print(f""Nodes at distance {k} from the root: {' '.join(map(str, result))}"")
",O(N),O(N)
"# Given a binary matrix of M X N of
# integers, you need to return only
# unique rows of binary array
ROW =4
COL =5

# The main function that prints
# all unique rows in a given matrix.
deffindUniqueRows(M):
    
    # Traverse through the matrix
    fori inrange(ROW):
        flag =0

        # Check if there is similar column
        # is already printed, i.e if i and
        # jth column match.
        forj inrange(i):
            flag =1

            fork inrange(COL):
                if(M[i][k] !=M[j][k]):
                    flag =0

            if(flag ==1):
                break

        # If no row is similar
        if(flag ==0):
            
            # Print the row
            forj inrange(COL):
                print(M[i][j], end ="" "")
                
            print()    

# Driver Code
if__name__ =='__main__':
    
    M =[ [ 0, 1, 0, 0, 1],
          [ 1, 0, 1, 1, 0],
          [ 0, 1, 0, 0, 1],
          [ 1, 0, 1, 0, 0] ]

    findUniqueRows(M)

# This code is contributed by mohit kumar 29
",O(ROW^2 x COL),O(1)
"# Given a binary matrix of M X N of integers, 
# you need to return only unique rows of binary array 
ROW =4
COL =5

# print the column represented as integers
defPrint(p):

    fori inrange(COL):
        print(p %2,end ="" "")
        p =int(p//2)
    print("""")

classBST:

    def__init__(self,data):
        self.data =data
        self.left =None
        self.right =None

    # Insert function definition. 
    defInsert(self,root, value): 

        if(notroot): 
            # Insert the first node, if root is NULL. 
            returnBST(value) 
        
        #if the value is present
        if(value ==root.data):
            returnroot
    
        # Insert data. 
        if(value > root.data): 
            # Insert right node data, if the 'value' 
            # to be inserted is greater than 'root' node data. 
            
            # Process right nodes. 
            root.right =self.Insert(root.right, value)
        else:
            # Insert left node data, if the 'value' 
            # to be inserted is greater than 'root' node data. 
            
            # Process left nodes. 
            root.left =self.Insert(root.left, value)
        
        # Return 'root' node, after insertion. 
        returnroot 

    # Inorder traversal function. 
    # This gives data in sorted order. 
    defInorder(self,root): 
        if(notroot): 
            return
        self.Inorder(root.left); 
        Print( root.data ); 
        self.Inorder(root.right)

# convert array to decimal
defconvert(arr):
    sum=0
    
    fori inrange(COL):
        sum+=pow(2,i)*arr[i]
    returnsum


# The main function that prints 
# all unique rows in a given matrix.
deffindUniqueRows(M):
    
    b,root =BST(0),None
    
    #Traverse through the matrix
    fori inrange(ROW):
        #insert the row into BST
        root =b.Insert(root,convert(M[i]))
    
    #print 
    b.Inorder(root)

# Driver Code
M =[[0, 1, 0, 0, 1], 
     [1, 0, 1, 1, 0], 
     [0, 1, 0, 0, 1], 
     [1, 0, 1, 0, 0]]

findUniqueRows(M)

# This code is contributed by shinjanpatra
",O(ROW x COL + ROW x log(ROW)),O(ROW)
"classNode:
    def__init__(self):
        self.isEndOfCol =False
        self.child =[None, None]

defnewNode():
    temp =Node()
    returntemp

definsert(root, M, row, col):
    """"""Insert a row of binary values into the trie.
    If the row is already in the trie, return False.
    Otherwise, return True.
    """"""
    ifroot isNone:
        root =newNode()

    ifcol < COL:
        returninsert(root.child[M[row][col]], M, row, col+1)
    else:
        ifnotroot.isEndOfCol:
            root.isEndOfCol =True
            returnTrue
        returnFalse

defprintRow(row):
    # Print a row of binary values
    fori inrow:
        print(i, end="" "")
    print()

deffindUniqueRows(M):
    # Find and print unique rows in a matrix of binary values
    unique_rows =[]
    fori inrange(ROW):
        ifnotany(M[i] ==row forrow inunique_rows):
            unique_rows.append(M[i])
    forrow inunique_rows:
        printRow(row)
# Number of rows and columns in the matrix
ROW =4
COL =5

# Example matrix of binary values
M =[[0, 1, 0, 0, 1], 
     [1, 0, 1, 1, 0], 
     [0, 1, 0, 0, 1], 
     [1, 0, 1, 0, 0]]

# Find and print unique rows in the matrix
findUniqueRows(M)

# This code is contributed by Vikram_Shirsat
",O(ROW x COL),O(ROW x COL)
"# Python3 code to print unique row in a 
# given binary matrix

defprintArray(matrix):

    rowCount =len(matrix)
    ifrowCount ==0:
        return

    columnCount =len(matrix[0])
    ifcolumnCount ==0:
        return

    row_output_format ="" "".join([""%s""] *columnCount)

    printed ={}

    forrow inmatrix:
        routput =row_output_format %tuple(row)
        ifroutput notinprinted:
            printed[routput] =True
            print(routput)

# Driver Code
mat =[[0, 1, 0, 0, 1], 
       [1, 0, 1, 1, 0], 
       [0, 1, 0, 0, 1],
       [1, 1, 1, 0, 0]]

printArray(mat)

# This code is contributed by myronwalker
",O(ROW x COL),O(ROW x COL)
"# Simple Python 3 program to add two
# polynomials

# A utility function to return maximum 
# of two integers

# A[] represents coefficients of first polynomial
# B[] represents coefficients of second polynomial
# m and n are sizes of A[] and B[] respectively
defadd(A, B, m, n):

    size =max(m, n);
    sum=[0fori inrange(size)]

    # Initialize the product polynomial
    
    fori inrange(0, m, 1):
        sum[i] =A[i]

    # Take ever term of first polynomial
    fori inrange(n):
        sum[i] +=B[i]

    returnsum

# A utility function to print a polynomial
defprintPoly(poly, n):
    fori inrange(n):
        print(poly[i], end ="""")
        if(i !=0):
            print(""x^"", i, end ="""")
        if(i !=n -1):
            print("" + "", end ="""")

# Driver Code
if__name__ =='__main__':
    
    # The following array represents
    # polynomial 5 + 10x^2 + 6x^3
    A =[5, 0, 10, 6]

    # The following array represents
    # polynomial 1 + 2x + 4x^2
    B =[1, 2, 4]
    m =len(A)
    n =len(B)

    print(""First polynomial is"")
    printPoly(A, m)
    print(""\n"", end ="""")
    print(""Second polynomial is"")
    printPoly(B, n)
    print(""\n"", end ="""")
    sum=add(A, B, m, n)
    size =max(m, n)

    print(""sum polynomial is"")
    printPoly(sum, size)
    
# This code is contributed by
# Sahil_Shelangia
",O(m+n),"O(max(m, n))"
"# Program to add two polynomials represented
# in linkedlist using recursion
classNode:
    def__init__(self, coeff, power):
        self.coeff =coeff
        self.power =power
        self.next=None
        
# Function to add polynomials
defadd_polynomials(head1, head2):
    ifnothead1 andnothead2:
        return
    elifhead1.power ==head2.power:
        print(f' {head1.coeff + head2.coeff}x^{head1.power}', end='')
        add_polynomials(head1.next, head2.next)
    elifhead1.power > head2.power:
        print(f' {head1.coeff}x^{head1.power}', end='')
        add_polynomials(head1.next, head2)
    else:
        print(f' {head2.coeff}x^{head2.power}', end='')
        add_polynomials(head1, head2.next)

definsert(head, coeff, power):
    new_node =Node(coeff, power)
    whilehead.next:
        head =head.next
    head.next=new_node

defprint_list(head):
    print('Linked List')
    whilehead:
        print(f' {head.coeff}x^{head.power}', end='')
        head =head.next

if__name__ =='__main__':
    head =Node(5, 2)
    insert(head, 4, 1)
    head2 =Node(6, 2)
    insert(head2, 4, 1)
    print_list(head)
    print()
    print_list(head2)
    print('\nAddition:')
    add_polynomials(head, head2)
",O(m + n),O(m + n)
"defadd_polynomials(p1, p2):
    len1, len2 =len(p1), len(p2)
    iflen1 < len2:
        p1 +=[0] *(len2 -len1)
    else:
        p2 +=[0] *(len1 -len2)
    return[sum(x) forx inzip(p1, p2)]

p1 =[2, 0, 4, 6, 8]
p2 =[0, 0, 1, 2]
print(add_polynomials(p1, p2))
",O(n),O(n)
"# Python program for reversal algorithm of array rotation

# Function to reverse arr[] from index start to end


defreverseArray(arr, start, end):
    while(start < end):
        temp =arr[start]
        arr[start] =arr[end]
        arr[end] =temp
        start +=1
        end =end-1

# Function to left rotate arr[] of size n by d


defleftRotate(arr, d):

    ifd ==0:
        return
    n =len(arr)
    # in case the rotating factor is
    # greater than array length
    d =d %n
    reverseArray(arr, 0, d-1)
    reverseArray(arr, d, n-1)
    reverseArray(arr, 0, n-1)

# Function to print an array


defprintArray(arr):
    fori inrange(0, len(arr)):
        print(arr[i],end=' ')


# Driver function to test above functions
arr =[1, 2, 3, 4, 5, 6, 7]
n =len(arr)
d =2

leftRotate(arr, d)  # Rotate array by 2
printArray(arr)

# This code is contributed by Devesh Agrawal
",O(N),O(1)
"# Function to rotate an array by k elements to the right
defrotateArray(arr, k):
    # Find the size of the array
    n =len(arr);

    # Mod k with the size of the array
    # To handle the case where k is greater than the size of the array
    k %=n;

    # Reverse the entire array
    arr[0:n] =arr[0:n][::-1]

    # Reverse the first k elements
    arr[0:k] =arr[0:k][::-1]

    # Reverse the remaining n-k elements
    arr[k:n] =arr[k:n][::-1]

# Initialize the array
arr =[ 1, 2, 3, 4, 5];

# Number of elements to rotate to the right
k =2;

# Call the rotateArray function to rotate the array
rotateArray(arr, k);

# Print the rotated array
fori inrange(0,len(arr)):
    print(arr[i], end="" "");
",O(N),O(1)
"# Function for nth fibonacci number - Space Optimisation
# Taking 1st two fibonacci numbers as 0 and 1


deffibonacci(n):
    a =0
    b =1
    ifn < 0:
        print(""Incorrect input"")
    elifn ==0:
        returna
    elifn ==1:
        returnb
    else:
        fori inrange(2, n+1):
            c =a +b
            a =b
            b =c
        returnb

# Driver Program


print(fibonacci(9))

# This code is contributed by Saket Modi
",O(n),O(1)
"# Fibonacci series using recursion
deffibonacci(n):
    ifn <=1:
        returnn
    returnfibonacci(n-1) +fibonacci(n-2)


if__name__ ==""__main__"":
    n =9
    print(n, ""th Fibonacci Number: "")
    print(fibonacci(n))

 # This code is contributed by Manan Tyagi.
",Exponential,O(n)
"# Fibonacci Series using Dynamic Programming
deffibonacci(n):

    # Taking 1st two fibonacci numbers as 0 and 1
    f =[0, 1]

    fori inrange(2, n+1):
        f.append(f[i-1] +f[i-2])
    returnf[n]


print(fibonacci(9))
",O(n),O(n)
"# Fibonacci Series using
# Optimized Method

# function that returns nth
# Fibonacci number


deffib(n):

    F =[[1, 1],
         [1, 0]]
    if(n ==0):
        return0
    power(F, n -1)

    returnF[0][0]


defmultiply(F, M):

    x =(F[0][0] *M[0][0] +
         F[0][1] *M[1][0])
    y =(F[0][0] *M[0][1] +
         F[0][1] *M[1][1])
    z =(F[1][0] *M[0][0] +
         F[1][1] *M[1][0])
    w =(F[1][0] *M[0][1] +
         F[1][1] *M[1][1])

    F[0][0] =x
    F[0][1] =y
    F[1][0] =z
    F[1][1] =w

# Optimized version of
# power() in method 4


defpower(F, n):

    if(n ==0orn ==1):
        return
    M =[[1, 1],
         [1, 0]]

    power(F, n //2)
    multiply(F, F)

    if(n %2!=0):
        multiply(F, M)


# Driver Code
if__name__ ==""__main__"":
    n =9
    print(fib(n))

# This code is contributed
# by ChitraNayal
",O(Log n),O(Log n)
"# Python3 program to demonstrate linked list
# based implementation of queue

# A linked list (LL) node
# to store a queue entry


classNode:

    def__init__(self, data):
        self.data =data
        self.next=None

# A class to represent a queue

# The queue, front stores the front node
# of LL and rear stores the last node of LL


classQueue:

    def__init__(self):
        self.front =self.rear =None

    defisEmpty(self):
        returnself.front ==None

    # Method to add an item to the queue
    defEnQueue(self, item):
        temp =Node(item)

        ifself.rear ==None:
            self.front =self.rear =temp
            return
        self.rear.next=temp
        self.rear =temp

    # Method to remove an item from queue
    defDeQueue(self):

        ifself.isEmpty():
            return
        temp =self.front
        self.front =temp.next

        if(self.front ==None):
            self.rear =None


# Driver Code
if__name__ =='__main__':
    q =Queue()
    q.EnQueue(10)
    q.EnQueue(20)
    q.DeQueue()
    q.DeQueue()
    q.EnQueue(30)
    q.EnQueue(40)
    q.EnQueue(50)
    q.DeQueue()
    print(""Queue Front : ""+str(q.front.data ifq.front !=Noneelse-1))
    print(""Queue Rear : ""+str(q.rear.data ifq.rear !=Noneelse-1))
",O(1),O(1)
"# Python3 program to implement Queue using 
# two stacks with costly enQueue() 

classQueue: 
    def__init__(self):
        self.s1 =[]
        self.s2 =[]

    defenQueue(self, x):
        
        # Move all elements from s1 to s2 
        whilelen(self.s1) !=0: 
            self.s2.append(self.s1[-1]) 
            self.s1.pop()

        # Push item into self.s1 
        self.s1.append(x) 

        # Push everything back to s1 
        whilelen(self.s2) !=0: 
            self.s1.append(self.s2[-1]) 
            self.s2.pop()

    # Dequeue an item from the queue 
    defdeQueue(self):
        
            # if first stack is empty 
        iflen(self.s1) ==0: 
            return-1;
    
        # Return top of self.s1 
        x =self.s1[-1] 
        self.s1.pop() 
        returnx

# Driver code 
if__name__ =='__main__':
    q =Queue()
    q.enQueue(1) 
    q.enQueue(2) 
    q.enQueue(3) 

    print(q.deQueue())
    print(q.deQueue())
    print(q.deQueue())

# This code is contributed by PranchalK 
",O(N),O(N)
"# Python3 program to implement Queue using 
# two stacks with costly deQueue()

classQueue:
    def__init__(self):
        self.s1 =[]
        self.s2 =[]

    # EnQueue item to the queue
    defenQueue(self, x):
        self.s1.append(x)

    # DeQueue item from the queue
    defdeQueue(self):

        # if both the stacks are empty
        iflen(self.s1) ==0andlen(self.s2) ==0:
            return-1

        # if s2 is empty and s1 has elements
        eliflen(self.s2) ==0andlen(self.s1) > 0:
            whilelen(self.s1):
                temp =self.s1.pop()
                self.s2.append(temp)
            returnself.s2.pop()

        else:
            returnself.s2.pop()

    # Driver code
if__name__ =='__main__':
    q =Queue()
    q.enQueue(1)
    q.enQueue(2)
    q.enQueue(3)

    print(q.deQueue())
    print(q.deQueue())
    print(q.deQueue())

# This code is contributed by Pratyush Kumar 
",O(1),O(N)
"# Python3 program to implement Queue using  
# one stack and recursive call stack. 
classQueue:
    def__init__(self):
        self.s =[]
        
    # Enqueue an item to the queue 
    defenQueue(self, data):
        self.s.append(data)
        
    # Dequeue an item from the queue 
    defdeQueue(self):
        # Return if queue is empty
        iflen(self.s) <=0:
            return-1
        
        # pop an item from the stack
        x =self.s[len(self.s) -1]
        self.s.pop()
        
        # if stack become empty
        # return the popped item
        iflen(self.s) <=0:
            returnx
            
        # recursive call
        item =self.deQueue()
        
        # push popped item back to
        # the stack
        self.s.append(x)
        
        # return the result of 
        # deQueue() call
        returnitem
    
# Driver code  
if__name__ =='__main__':
    q =Queue()
    q.enQueue(1)
    q.enQueue(2)
    q.enQueue(3)
    
    print(q.deQueue())
    print(q.deQueue())
    print(q.deQueue())  
    
# This code is contributed by iArman
",O(1),O(N)
"""""""A typical recursive implementation of Quicksort for array """"""
 
"""""" This function takes last element as pivot, 
   places the pivot element at its correct 
   position in sorted array, and places all 
   smaller (smaller than pivot) to left of
   pivot and all greater elements to right 
   of pivot 
""""""

""""""
 i --> is the first index in the array
 x --> is the last index in the array
 tmp --> is a temporary variable for swapping values (integer)
""""""
# array arr, integer l, integer h
defpartition (arr, l, h):
    x =arr[h]
    i =(l -1)
    forj inrange(l, h):
        if(arr[j] <=x):
            i +=1
            tmp =arr[i]
            arr[i] =arr[j]
            arr[j] =tmp

    tmp =arr[i +1]
    arr[i +1] =arr[h]
    arr[h] =tmp
    return(i +1)

""""""
A --> Array to be sorted,
l --> Starting index, 
h --> Ending index
""""""

# array A, integer l, integer h
defquickSort(A, l, h):
    if(l < h):
        p =partition(A, l, h) # pivot index
        quickSort(A, l, p -1) # left
        quickSort(A, p +1, h) # right

# This code is contributed by humphreykibet.
",O(N log N),O(N)
"# A Python program to sort a linked list using Quicksort
head =None

# a node of the doubly linked list
classNode:
    def__init__(self, d):
        self.data =d
        self.next=None
        self.prev =None

# A utility function to find last node of linked list
deflastNode(node):
    while(node.next!=None):
            node =node.next;
    returnnode;

# Considers last element as pivot, places the pivot element at its
#   correct position in sorted array, and places all smaller (smaller than
#   pivot) to left of pivot and all greater elements to right of pivot 
defpartition(l, h):

    # set pivot as h element
        x =h.data;
         
        # similar to i = l-1 for array implementation
        i =l.prev;
        
        j =l
        
        # Similar to ""for (int j = l; j <= h- 1; j++)""
        while(j !=h):
            if(j.data <=x):
              
                # Similar to i++ for array
                i =l if(i ==None) elsei.next;

                temp =i.data;
                i.data =j.data;
                j.data =temp;
            j =j.next
                        
        i =l if(i ==None) elsei.next;  # Similar to i++
        temp =i.data;
        i.data =h.data;
        h.data =temp;
        returni;

# A recursive implementation of quicksort for linked list 
def_quickSort(l,h):
    if(h !=Noneandl !=h andl !=h.next):
            temp =partition(l, h);
            _quickSort(l,temp.prev);
            _quickSort(temp.next, h);
        
# The main function to sort a linked list. It mainly calls _quickSort()
defquickSort(node):
  
    # Find last node
        head =lastNode(node);
         
        # Call the recursive QuickSort
        _quickSort(node,head);

# A utility function to print contents of arr
defprintList(head):
    while(head !=None):
            print(head.data, end="" "");
            head =head.next;
        
# Function to insert a node at the beginning of the Doubly Linked List 
defpush(new_Data):
    globalhead;
    new_Node =Node(new_Data);     # allocate node 
         
    # if head is null, head = new_Node
    if(head ==None):
        head =new_Node;
        return;
    
    # link the old list of the new node 
    new_Node.next=head;
        
    # change prev of head node to new node 
    head.prev =new_Node;
        
    # since we are adding at the beginning, prev is always NULL 
    new_Node.prev =None;
        
    # move the head to point to the new node 
    head =new_Node;

# Driver program to test above function 
push(5);
push(20);
push(4);
push(3);
push(30);


print(""Linked List before sorting "");
printList(head);
print(""\nLinked List after sorting"");
quickSort(head);
printList(head);

# This code is contributed by _saurabh_jaiswal
",O(n^2),O(n)
"# Following program is the python implementation of
# Rabin Karp Algorithm given in CLRS book

# d is the number of characters in the input alphabet
d =256

# pat  -> pattern
# txt  -> text
# q    -> A prime number


defsearch(pat, txt, q):
    M =len(pat)
    N =len(txt)
    i =0
    j =0
    p =0# hash value for pattern
    t =0# hash value for txt
    h =1

    # The value of h would be ""pow(d, M-1)%q""
    fori inrange(M-1):
        h =(h*d) %q

    # Calculate the hash value of pattern and first window
    # of text
    fori inrange(M):
        p =(d*p +ord(pat[i])) %q
        t =(d*t +ord(txt[i])) %q

    # Slide the pattern over text one by one
    fori inrange(N-M+1):
        # Check the hash values of current window of text and
        # pattern if the hash values match then only check
        # for characters one by one
        ifp ==t:
            # Check for characters one by one
            forj inrange(M):
                iftxt[i+j] !=pat[j]:
                    break
                else:
                    j +=1

            # if p == t and pat[0...M-1] = txt[i, i+1, ...i+M-1]
            ifj ==M:
                print(""Pattern found at index ""+str(i))

        # Calculate hash value for next window of text: Remove
        # leading digit, add trailing digit
        ifi < N-M:
            t =(d*(t-ord(txt[i])*h) +ord(txt[i+M])) %q

            # We might get negative values of t, converting it to
            # positive
            ift < 0:
                t =t+q


# Driver Code
if__name__ =='__main__':
    txt =""GEEKS FOR GEEKS""
    pat =""GEEK""

    # A prime number
    q =101

    # Function Call
    search(pat, txt, q)

# This code is contributed by Bhavya Jain
",O(n),O(1)
"# Python3 program to solve Rat in a Maze
# problem using backtracking

# Maze size
n =4

# A utility function to check if x, y is valid
# index for N * N Maze


defisValid(n, maze, x, y, res):
    ifx >=0andy >=0andx < n andy < n andmaze[x][y] ==1andres[x][y] ==0:
        returnTrue
    returnFalse

# A recursive utility function to solve Maze problem


defRatMaze(n, maze, move_x, move_y, x, y, res):
    # if (x, y is goal) return True
    ifx ==n-1andy ==n-1:
        returnTrue
    fori inrange(4):
        # Generate new value of x
        x_new =x +move_x[i]

        # Generate new value of y
        y_new =y +move_y[i]

        # Check if maze[x][y] is valid
        ifisValid(n, maze, x_new, y_new, res):

            # mark x, y as part of solution path
            res[x_new][y_new] =1
            ifRatMaze(n, maze, move_x, move_y, x_new, y_new, res):
                returnTrue
            res[x_new][y_new] =0
    returnFalse


defsolveMaze(maze):
    # Creating a 4 * 4 2-D list
    res =[[0fori inrange(n)] fori inrange(n)]
    res[0][0] =1

    # x matrix for each direction
    move_x =[-1, 1, 0, 0]

    # y matrix for each direction
    move_y =[0, 0, -1, 1]

    ifRatMaze(n, maze, move_x, move_y, 0, 0, res):
        fori inrange(n):
            forj inrange(n):
                print(res[i][j], end=' ')
            print()
    else:
        print('Solution does  not exist')


# Driver program to test above function
if__name__ ==""__main__"":
    # Initialising the maze
    maze =[[1, 0, 0, 0],
             [1, 1, 0, 1],
             [0, 1, 0, 0],
             [1, 1, 1, 1]]

    solveMaze(maze)

# This code is contributed by Anvesh Govind Saxena
",O(2^(n^2)),O(n^2)
"classSolution:
    defsolve(self, i, j, arr, n, ans, move, direction, dir1, djr, visited):
      #if we reach the last cell of the matrix. just add the current move to the list of answers (ans) and return from the function, effectively stopping any further exploration.
        ifi ==n -1andj ==n -1:
            ans.append(move)
            return
        
        forind inrange(4):
          #calculate the next row index based on the current i (row) and the di array, which holds values for direction changes.
            nexti =i +dir1[ind]
            #calculate the next column index based on the current j (column) and the dj array, which holds values for direction changes.
            nextj =j +djr[ind]
            # to check whether is is valid to move to the next cell
      # make sure to check if the next cell has been visited before.
            
            if0<=nexti < n and0<=nextj < n andvisited[nexti][nextj] ==0andarr[nexti][nextj] ==1:
              #Also Mark the current cell as visited to prevent revisiting it during the same path exploration. 
              visited[i][j] =1
              #Recursively call the solve function with the updated position , the updated path move(adding the current direction), and the current direction), and the updated state information.
              self.solve(nexti, nextj, arr, n, ans, move +direction[ind], direction, dir1, djr, visited)
               # Reset the current cell's visited status to 0 to allow backtracking(an essential step)
              visited[i][j] =0

    deffindPath(self, m, n):
       #we intialise with array to get all the required values.
        ans =[]
         #initialise a string direction which represents all the directions.
        direction =""DLRU""
        dir1 =[1, 0, 0, -1]
        djr =[0, -1, 1, 0]
        #for visited cell
        visited =[[0for_ inrange(n)] for_ inrange(n)]
        
         #if top-left corner of the grid is equal to 1 to verify if there is a valid starting point in the grid.
        ifm[0][0] ==1:
            self.solve(0, 0, m, n, ans, """", direction, dir1, djr, visited)

        returnans

if__name__ ==""__main__"":
    n =4
    m =[
        [1, 0, 0, 0],
        [1, 1, 0, 1],
        [1, 1, 0, 0],
        [0, 1, 1, 1]
    ]

    obj =Solution()
    result =obj.findPath(m, n)
    iflen(result) ==0:
        print(-1)
    else:
        forpath inresult:
            print(path, end="" "")
        print()
",O(4^(m*n)),O(m*n)
"# An efficient Python3 program 
# to randomly select k items
# from a stream of items
importrandom
# A utility function 
# to print an array
defprintArray(stream,n):
    fori inrange(n):
        print(stream[i],end="" "");
    print();

# A function to randomly select
# k items from stream[0..n-1].
defselectKItems(stream, n, k):
        i=0; 
        # index for elements
        # in stream[]
        
        # reservoir[] is the output 
        # array. Initialize it with
        # first k elements from stream[]
        reservoir =[0]*k;
        fori inrange(k):
            reservoir[i] =stream[i];
        
        # Iterate from the (k+1)th
        # element to nth element
        while(i < n):
            # Pick a random index
            # from 0 to i.
            j =random.randrange(i+1);
            
            # If the randomly picked
            # index is smaller than k,
            # then replace the element
            # present at the index
            # with new element from stream
            if(j < k):
                reservoir[j] =stream[i];
            i+=1;
        
        print(""Following are k randomly selected items"");
        printArray(reservoir, k);
    
# Driver Code

if__name__ ==""__main__"":
    stream =[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];
    n =len(stream);
    k =5;
    selectKItems(stream, n, k);

# This code is contributed by mits
",O(n),O(k)
"# Python3 Program to reverse a doubly linked list

# A node of the doubly linked list

classNode:

    # Constructor to create a new node
    def__init__(self, data):
        self.data =data
        self.next=None
        self.prev =None


classDoublyLinkedList:
     # Constructor for empty Doubly Linked List
    def__init__(self):
        self.head =None

    # Function reverse a Doubly Linked List
    defreverse(self):
        temp =None
        current =self.head

        # Swap next and prev for all nodes of
        # doubly linked list
        whilecurrent isnotNone:
            temp =current.prev
            current.prev =current.next
            current.next=temp
            current =current.prev

        # Before changing head, check for the cases like
        # empty list and list with only one node
        iftemp isnotNone:
            self.head =temp.prev

    # Given a reference to the head of a list and an
    # integer,inserts a new node on the front of list
    defpush(self, new_data):

        # 1. Allocates node
        # 2. Put the data in it
        new_node =Node(new_data)

        # 3. Make next of new node as head and
        # previous as None (already None)
        new_node.next=self.head

        # 4. change prev of head node to new_node
        ifself.head isnotNone:
            self.head.prev =new_node

        # 5. move the head to point to the new node
        self.head =new_node

    defprintList(self, node):
        while(node isnotNone):
            print(node.data, end=' ')
            node =node.next


# Driver's code
if__name__ ==""__main__"":
    dll =DoublyLinkedList()
    dll.push(2)
    dll.push(4)
    dll.push(8)
    dll.push(10)

    print(""\nOriginal Linked List"")
    dll.printList(dll.head)

    # Function call
    dll.reverse()

    print(""\nReversed Linked List"")
    dll.printList(dll.head)

# This code is contributed by Nikhil Kumar Singh(nickzuck_007)
",O(N),O(1)
"# Python3 code for the above approach

classNode:
    def__init__(self, data):
        self.data =data
        self.next=None
        self.prev =None


classDoublyLinkedList:
    def__init__(self):
        self.head =None

    """"""
    method to reverse a Doubly-Linked List using Stacks
    """"""

    defreverseUsingStacks(self):

        stack =[]
        temp =self.head
        whiletemp isnotNone:
            stack.append(temp.data)
            temp =temp.next

        # Add all the elements in the stack
        # in a sequence to the stack
        temp =self.head
        whiletemp isnotNone:
            temp.data =stack.pop()
            temp =temp.next

        # Popped all the elements and the
        # added in the linked list,
        # in a reversed order.

    """"""
    method to push a new item before the head
    """"""

    defpush(self, new_data):
        new_node =Node(new_data)
        new_node.next=self.head

        ifself.head isnotNone:
            self.head.prev =new_node

        self.head =new_node

    """"""
    method to traverse the doubly-linked 
    list and print every node in the list
    """"""

    defprintList(self, node):
        while(node isnotNone):
            print(node.data)
            node =node. next


# driver's code
if__name__ ==""__main__"":
    dll =DoublyLinkedList()
    dll.push(2)
    dll.push(4)
    dll.push(8)
    dll.push(10)

    print(""original doubly-linked list"")
    dll.printList(dll.head)

    # Function call
    dll.reverseUsingStacks()

    print("" reversed doubly-linked list"")
    dll.printList(dll.head)
",O(N),O(N)
"# Define Node class
classNode:
    def__init__(self):
        self.data =0
        self.prev =None
        self.next=None

# Define function to reverse the doubly linked list


defreverse(head_ref):
    current =head_ref
    temp =None

    whilecurrent !=None:
        temp =current.prev
        current.prev =current.next
        current.next=temp
        current =current.prev

    iftemp !=None:
        head_ref =temp.prev

    returnhead_ref

# Define function to print the doubly linked list


defprintList(node):
    whilenode !=None:
        print(node.data, end="" "")
        node =node.next


# Create nodes
head =Node()
second =Node()
third =Node()

# Link nodes
head.data =1
head.prev =None
head.next=second

second.data =2
second.prev =head
second.next=third

third.data =3
third.prev =second
third.next=None

# Print original list
print(""Original List: "", end="""")
printList(head)

# Reverse the list
head =reverse(head)

# Print the reversed list
print(""\nReversed List: "", end="""")
printList(head)
",O(n),O(n)
"# Python program to reverse a
# stack using recursion

# Below is a recursive function
# that inserts an element
# at the bottom of a stack.


definsertAtBottom(stack, item):
    ifisEmpty(stack):
        push(stack, item)
    else:
        temp =pop(stack)
        insertAtBottom(stack, item)
        push(stack, temp)

# Below is the function that
# reverses the given stack
# using insertAtBottom()


defreverse(stack):
    ifnotisEmpty(stack):
        temp =pop(stack)
        reverse(stack)
        insertAtBottom(stack, temp)

# Below is a complete running
# program for testing above
# functions.

# Function to create a stack.
# It initializes size of stack
# as 0


defcreateStack():
    stack =[]
    returnstack

# Function to check if
# the stack is empty


defisEmpty(stack):
    returnlen(stack) ==0

# Function to push an
# item to stack


defpush(stack, item):
    stack.append(item)

# Function to pop an
# item from stack


defpop(stack):

    # If stack is empty
    # then error
    if(isEmpty(stack)):
        print(""Stack Underflow "")
        exit(1)

    returnstack.pop()

# Function to print the stack


defprints(stack):
    fori inrange(len(stack)-1, -1, -1):
        print(stack[i], end=' ')
    print()

# Driver Code


stack =createStack()
push(stack, str(4))
push(stack, str(3))
push(stack, str(2))
push(stack, str(1))
print(""Original Stack "")
prints(stack)

reverse(stack)

print(""Reversed Stack "")
prints(stack)

# This code is contributed by Sunny Karira
",O(N2),O(N)
"# Python3 code to 
# rotate bits of number

INT_BITS =32

# Function to left
# rotate n by d bits
defleftRotate(n, d):

    # In n<<d, last d bits are 0.
    # To put first 3 bits of n at 
    # last, do bitwise or of n<<d
    # with n >>(INT_BITS - d) 
    return(n << d)|(n >> (INT_BITS -d))

# Function to right
# rotate n by d bits
defrightRotate(n, d):

    # In n>>d, first d bits are 0.
    # To put last 3 bits of at 
    # first, do bitwise or of n>>d
    # with n <<(INT_BITS - d) 
    return(n >> d)|(n << (INT_BITS -d)) & 0xFFFFFFFF

# Driver program to
# test above functions 
n =16
d =2

print(""Left Rotation of"",n,""by""
      ,d,""is"",end="" "")
print(leftRotate(n, d))

print(""Right Rotation of"",n,""by""
     ,d,""is"",end="" "")
print(rightRotate(n, d))

# This code is contributed by
# Smitha Dinesh Semwal
",O(1),O(1)
"SHORT_SIZE =16

# function to rotate the given unsigned short
# in the left direction
defleftRotate(x, d):

    return(x << d) | (x >> (SHORT_SIZE -d))

  # function to rotate the given unsigned short
# in the right direction
defrightRotate(x, d):

    return(x >> d) | (x << (SHORT_SIZE -d)) & 0xDDDDDF

# Driver program to test above functions
# Test case
n =28
d =2

print(""Left Rotation of"",n,""by""
      ,d,""is"",end="" "")
print(leftRotate(n, d))

print(""Right Rotation of"",n,""by""
     ,d,""is"",end="" "")
print(rightRotate(n, d))

# This code is contributed by shivanisinghss2110
",O(1),O(1)
"# Python Program to search an element
# in a sorted and pivoted array

# Searches an element key in a pivoted
# sorted array arrp[] of size n
defpivotedBinarySearch(arr, n, key):

    pivot =findPivot(arr, 0, n-1)

    # If we didn't find a pivot,
    # then array is not rotated at all
    ifpivot ==-1:
        returnbinarySearch(arr, 0, n-1, key)

    # If we found a pivot, then first
    # compare with pivot and then
    # search in two subarrays around pivot
    ifarr[pivot] ==key:
        returnpivot
    ifarr[0] <=key:
        returnbinarySearch(arr, 0, pivot-1, key)
    returnbinarySearch(arr, pivot +1, n-1, key)


# Function to get pivot. For array
# 3, 4, 5, 6, 1, 2 it returns 3
# (index of 6)
deffindPivot(arr, low, high):

    # base cases
    ifhigh < low:
        return-1
    ifhigh ==low:
        returnlow

    # low + (high - low)/2;
    mid =int((low +high)/2)

    ifmid < high andarr[mid] > arr[mid +1]:
        returnmid
    ifmid > low andarr[mid] < arr[mid -1]:
        return(mid-1)
    ifarr[low] >=arr[mid]:
        returnfindPivot(arr, low, mid-1)
    returnfindPivot(arr, mid +1, high)

# Standard Binary Search function
defbinarySearch(arr, low, high, key):

    ifhigh < low:
        return-1

    # low + (high - low)/2;
    mid =int((low +high)/2)

    ifkey ==arr[mid]:
        returnmid
    ifkey > arr[mid]:
        returnbinarySearch(arr, (mid +1), high,
                            key)
    returnbinarySearch(arr, low, (mid -1), key)


# Driver program to check above functions
# Let us search 3 in below array
if__name__ =='__main__':
    arr1 =[5, 6, 7, 8, 9, 10, 1, 2, 3]
    n =len(arr1)
    key =3
    print(""Index of the element is : "", \
          pivotedBinarySearch(arr1, n, key))

# This is contributed by Smitha Dinesh Semwal
",O(log N),O(1)
"# Search an element in sorted and rotated array using
# single pass of Binary Search

# Returns index of key in arr[l..h] if key is present,
# otherwise returns -1
defsearch(arr, l, h, key):
    ifl > h:
        return-1

    mid =(l +h) //2
    ifarr[mid] ==key:
        returnmid

    # If arr[l...mid] is sorted
    ifarr[l] <=arr[mid]:

        # As this subarray is sorted, we can quickly
        # check if key lies in half or other half
        ifkey >=arr[l] andkey <=arr[mid]:
            returnsearch(arr, l, mid-1, key)
        returnsearch(arr, mid +1, h, key)

    # If arr[l..mid] is not sorted, then arr[mid... r]
    # must be sorted
    ifkey >=arr[mid] andkey <=arr[h]:
        returnsearch(arr, mid +1, h, key)
    returnsearch(arr, l, mid-1, key)


# Driver program
if__name__ =='__main__':
    arr =[4, 5, 6, 7, 8, 9, 1, 2, 3]
    key =3
    i =search(arr, 0, len(arr)-1, key)
    ifi !=-1:
        print(""Index: % d""%i)
    else:
        print(""Key not found"")

# This code is contributed by Shreyanshi Arun
",O(log N),O(1)
"defsearch_rotated_array(arr, key):
    n =len(arr)
    fori inrange(n):
        ifarr[i] ==key:
            returni
    return-1

arr =[5, 6, 7, 8, 9, 10, 1, 2, 3]
key =3
index =search_rotated_array(arr, key)
ifindex !=-1:
    print(f""Found at index {index}"")
else:
    print(""Not found"")
",O(n),O(1)
"# A Python program to demonstrate operations of KD tree
importsys

# Number of dimensions
k =2

# A structure to represent node of kd tree
classNode:
    def__init__(self, point):
        self.point =point
        self.left =None
        self.right =None

# A method to create a node of K D tree
defnewNode(point):
    returnNode(point)

# Inserts a new node and returns root of modified tree
# The parameter depth is used to decide axis of comparison
definsertRec(root, point, depth):
    # Tree is empty?
    ifnotroot:
        returnnewNode(point)

    # Calculate current dimension (cd) of comparison
    cd =depth %k

    # Compare the new point with root on current dimension 'cd'
    # and decide the left or right subtree
    ifpoint[cd] < root.point[cd]:
        root.left =insertRec(root.left, point, depth +1)
    else:
        root.right =insertRec(root.right, point, depth +1)

    returnroot

# Function to insert a new point with given point in
# KD Tree and return new root. It mainly uses above recursive
# function ""insertRec()""
definsert(root, point):
    returninsertRec(root, point, 0)

# A utility method to determine if two Points are same
# in K Dimensional space
defarePointsSame(point1, point2):
    # Compare individual coordinate values
    fori inrange(k):
        ifpoint1[i] !=point2[i]:
            returnFalse

    returnTrue

# Searches a Point represented by ""point[]"" in the K D tree.
# The parameter depth is used to determine current axis.
defsearchRec(root, point, depth):
    # Base cases
    ifnotroot:
        returnFalse
    ifarePointsSame(root.point, point):
        returnTrue

    # Current dimension is computed using current depth and total
    # dimensions (k)
    cd =depth %k

    # Compare point with root with respect to cd (Current dimension)
    ifpoint[cd] < root.point[cd]:
        returnsearchRec(root.left, point, depth +1)

    returnsearchRec(root.right, point, depth +1)

# Searches a Point in the K D tree. It mainly uses
# searchRec()
defsearch(root, point):
    # Pass current depth as 0
    returnsearchRec(root, point, 0)

# Driver program to test above functions
if__name__ =='__main__':
    root =None
    points =[[3, 6], [17, 15], [13, 15], [6, 12], [9, 1], [2, 7], [10, 19]]

    n =len(points)

    fori inrange(n):
        root =insert(root, points[i])

    point1 =[10, 19]
    ifsearch(root, point1):
        print(""Found"")
    else:
        print(""Not Found"")

    point2 =[12, 19]
    ifsearch(root, point2):
        print(""Found"")
    else:
        print(""Not Found"")
        
# This code is contributed by Prajwal Kandekar
",O(n),O(n)
"# Python program to search an element in row-wise
# and column-wise sorted matrix

# Searches the element x in mat[][]. If the
# element is found, then prints its position
# and returns true, otherwise prints ""not found""
# and returns false


defsearch(mat, n, x):
    if(n ==0):
        return-1

    # Traverse through the matrix
    fori inrange(n):
        forj inrange(n):

            # If the element is found
            if(mat[i][j] ==x):
                print(""Element found at ("", i, "","", j, "")"")
                return1

    print("" Element not found"")
    return0


# Driver code
if__name__ ==""__main__"":
    mat =[[10, 20, 30, 40], [15, 25, 35, 45],
           [27, 29, 37, 48], [32, 33, 39, 50]]

    # Function call
    search(mat, 4, 29)

# This code is contributed by rag2127
",O(N2),O(1)
"# Python3 program to search an element
# in row-wise and column-wise sorted matrix

# Searches the element x in mat[][]. If the
# element is found, then prints its position
# and returns true, otherwise prints ""not found""
# and returns false


defsearch(mat, n, x):

    i =0

    # set indexes for top right element
    j =n -1
    while(i < n andj >=0):

        if(mat[i][j] ==x):

            print(""Element found at "", i, "", "", j)
            return1

        if(mat[i][j] > x):
            j -=1

        # if mat[i][j] < x
        else:
            i +=1

    print(""Element not found"")
    return0# if (i == n || j == -1 )


# Driver Code
if__name__ ==""__main__"":
    mat =[[10, 20, 30, 40],
           [15, 25, 35, 45],
           [27, 29, 37, 48],
           [32, 33, 39, 50]]

    # Function call
    search(mat, 4, 29)

# This code is contributed by Anant Agarwal.
",O(M + N),O(M + N)
"defsearch_element(mat, x):
    fori inrange(len(mat)):
        forj inrange(len(mat[0])):
            ifmat[i][j] ==x:
                returnf""Found at ({i}, {j})""
    return""Element not found""
        
mat =[
    [10, 20, 30, 40],
    [15, 25, 35, 45],
    [27, 29, 37, 48],
    [32, 33, 39, 50]
]

x =29
print(search_element(mat, x))  # Output: Found at (2, 1)

x =100
print(search_element(mat, x))  # Output: Element not found
",O(n^2),O(1)
"# python 3  program to implement 
# binary search in sorted array 
 
 
defbinarySearch(arr, low, high, key): 
 
    mid =(low +high)/2
 
    if(key ==arr[int(mid)]): 
        returnmid 
 
    if(key > arr[int(mid)]): 
        returnbinarySearch(arr, 
                            (mid +1), high, key) 
 
    if(key < arr[int(mid)]): 
        returnbinarySearch(arr, low, (mid-1), key) 
 
    return0
 
 
# Driver code 
if__name__ ==""__main__"": 
    # Let us search 3 in below array 
    arr =[5, 6, 7, 8, 9, 10] 
    n =len(arr) 
    key =10
 
    # Function call 
    print(""Index:"", int(binarySearch(arr, 0, n-1, key))) 
 
# This code is contributed by 
# Smitha Dinesh Semwal 
",O(log(n)),O(log(n))
"# Python3 program to implement insert 
# operation in an sorted array. 
 
# Inserts a key in arr[] of given capacity. 
# n is current size of arr[]. This function 
# returns n+1 if insertion is successful, else n. 
 
 
definsertSorted(arr, n, key, capacity): 
 
    # Cannot insert more elements if n is 
    # already more than or equal to capacity 
    if(n >=capacity): 
        returnn 
 
    i =n -1
    whilei >=0andarr[i] > key: 
        arr[i +1] =arr[i] 
        i -=1
 
    arr[i +1] =key 
 
    return(n +1) 
 
 
# Driver Code 
if__name__ ==""__main__"": 
    arr =[12, 16, 20, 40, 50, 70] 
 
    fori inrange(20): 
        arr.append(0) 
 
    capacity =len(arr) 
    n =6
    key =26
 
    print(""Before Insertion: "", end="" "") 
    fori inrange(n): 
        print(arr[i], end="" "") 
 
    # Function call 
    n =insertSorted(arr, n, key, capacity) 
 
    print(""\nAfter Insertion: "", end="""") 
    fori inrange(n): 
        print(arr[i], end="" "") 
 
# This code is contributed by Mohit Kumar 
",O(N),O(1)
"# Python program to implement delete operation in a 
# sorted array 
 
# /* Function to delete an element */ 
 
 
defdeleteElement(arr, n, key): 
 
    # Find position of element to be deleted 
    pos =binarySearch(arr, 0, n -1, key) 
 
    if(pos ==-1): 
        print(""Element not found"") 
        returnn 
 
    # Deleting element 
    fori inrange(pos, n -1): 
        arr[i] =arr[i +1] 
 
    returnn -1
 
# To search a key to be deleted 
 
 
defbinarySearch(arr, low, high, key): 
 
    if(high < low): 
        return-1
    mid =(low +high) //2
 
    if(key ==arr[mid]): 
        returnmid 
    if(key > arr[mid]): 
        returnbinarySearch(arr, (mid +1), high, key) 
 
    returnbinarySearch(arr, low, (mid -1), key) 
 
 
# Driver code 
if__name__ ==""__main__"": 
    arr =[10, 20, 30, 40, 50] 
 
    n =len(arr) 
    key =30
 
    print(""Array before deletion"") 
 
    fori inrange(n): 
        print(arr[i], end="" "") 
 
    # Function call 
    n =deleteElement(arr, n, key) 
    print(""\n\nArray after deletion"") 
    fori inrange(n): 
        print(arr[i], end="" "") 
 
# This code is contributed by shubhamsingh10 
",O(N),O(log N)
"# Python program for searching in
# unsorted array


deffindElement(arr, n, key):
    fori inrange(n):
        if(arr[i] ==key):
            returni
          
    # If the key is not found
    return-1


# Driver's code
if__name__ =='__main__':
    arr =[12, 34, 10, 6, 40]
    key =40
    n =len(arr)

    # search operation
    index =findElement(arr, n, key)
    ifindex !=-1:
        print(""Element Found at position: ""+str(index +1))
    else:
        print(""Element not found"")

    # Thanks to Aditi Sharma for contributing
    # this code
",O(N),O(1)
"# Python program for inserting
# an element in an unsorted array

# method to insert element


definsert(arr, element):
    arr.append(element)


# Driver's code
if__name__ =='__main__':
    # declaring array and key to insert
    arr =[12, 16, 20, 40, 50, 70]
    key =26

    # array before inserting an element
    print(""Before Inserting: "")
    print(arr)

    # array after Inserting element
    insert(arr, key)
    print(""After Inserting: "")
    print(arr)

    # Thanks to Aditi Sharma for contributing
    # this code
",O(1),O(1)
"# python Program to Insert an element
# at a specific position in an Array
definsertElement(arr, n, x, pos) :
    
    # shift elements to the right
    # which are on the right side of pos
    fori inrange(n-1,pos-1,-1) :
        arr[i +1] =arr[i]
        
    arr[pos] =x

# Driver's code
if__name__ =='__main__':
    # Declaring array and key to delete
    # here -1 is for empty space
    arr =[2, 4, 1, 8, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1]
    n =5
    
    print(""Before insertion : "")
    fori inrange(0,n) :
        print(arr[i],end=' ')

    print(""\n"")

    x =10;
    pos =2;
  
    # Function call
    insertElement(arr, n, x, pos);
    n+=1

    print(""After insertion : "")
    fori inrange(0,n) :
        print(arr[i],end=' ')
        
 #This Code is contributed by aditya942003patil
",O(N),O(1)
"# Python program to delete an element
# from an unsorted array

# Driver's code
if__name__ =='__main__':
    # Declaring array and key to delete
    arr =[10, 50, 30, 40, 20]
    key =30
 
    print(""Array before deletion:"")
    print(arr)
 
    # deletes key if found in the array 
    # otherwise shows error not in list
    arr.remove(key)
    print(""Array after deletion"")
    print(arr)
 
    # This code is contributed by Aditi Sharma. 
",O(N),O(1)
"classNode: 
    # constructor for Node class
    def__init__(self, key): 
        self.key =key
        self.left =None
        self.right =None

defnewNode(key):
    # create a new node
    node =Node(key)
    returnnode
  
defrightRotate(x): 
    # rotate the tree to the right
    y =x.left
    x.left =y.right
    y.right =x
    returny
  
defleftRotate(x):
    # rotate the tree to the left
    y =x.right
    x.right =y.left
    y.left =x
    returny
  
defsplay(root, key):
    # perform the splay operation
    ifroot isNoneorroot.key ==key: 
        returnroot
    ifroot.key > key: 
        ifroot.left isNone: 
            returnroot
        ifroot.left.key > key: 
            root.left.left =splay(root.left.left, key) 
            root =rightRotate(root) 
        elifroot.left.key < key: 
            root.left.right =splay(root.left.right, key) 
            ifroot.left.right: 
                root.left =leftRotate(root.left) 
        return(root.left isNone) androot orrightRotate(root) 
    else: 
        ifroot.right isNone: 
            returnroot
        ifroot.right.key > key: 
            root.right.left =splay(root.right.left, key) 
            ifroot.right.left: 
                root.right =rightRotate(root.right) 
        elifroot.right.key < key: 
            root.right.right =splay(root.right.right, key) 
            root =leftRotate(root) 
        return(root.right isNone) androot orleftRotate(root)

defsearch(root, key):
    # search for a key in the tree
    returnsplay(root, key) 

definsert(root, key):
    # insert a new key in the tree
    ifroot isNone: 
        returnnewNode(key) 
    root =splay(root, key) 
    ifroot.key ==key: 
        returnroot 
    ifroot.key > key: 
        new_node =newNode(key) 
        new_node.right =root 
        new_node.left =root.left 
        root.left =None
        returnnew_node 
    else: 
        new_node =newNode(key) 
        new_node.left =root 
        new_node.right =root.right 
        root.right =None
        returnnew_node 

defdelete(root, key): 
    # delete a key from the tree
    ifroot isNone: 
        returnroot 
    root =splay(root, key) 
    ifroot.key !=key: 
        returnroot 
    ifroot.left isNone: 
        new_root =root.right 
    else: 
        new_root =splay(root.left, key) 
        new_root.right =root.right 
    returnnew_root 

defpreOrder(root):
    # perform pre-order traversal of the tree
    ifroot: 
        print(root.key, end =' ') 
        preOrder(root.left) 
        preOrder(root.right) 
#Driver Code
if__name__ =='__main__':
    root =newNode(100) 
    root.left =newNode(50) 
    root.right =newNode(200) 
    root.left.left =newNode(40) 
    root.left.left.left =newNode(30) 
    root.left.left.left.left =newNode(20) 
  
    root =splay(root, 20) 
    print(""Preorder traversal of the modified Splay tree is"") 
    preOrder(root)
# This code is contributed by Vikram_Shirsat
",O(log n),O(n log n)
"# Python3 program for range minimum  
# query using segment tree  
importsys; 
frommath importceil,log2; 
 
INT_MAX =sys.maxsize; 
 
# A utility function to get  
# minimum of two numbers  
defminVal(x, y) : 
    returnx if(x < y) elsey;  
 
# A utility function to get the  
# middle index from corner indexes.  
defgetMid(s, e) : 
    returns +(e -s) //2;  
 
"""""" A recursive function to get the  
minimum value in a given range  
of array indexes. The following  
are parameters for this function.  
 
    st --> Pointer to segment tree  
    index --> Index of current node in the  
        segment tree. Initially 0 is  
        passed as root is always at index 0  
    ss & se --> Starting and ending indexes  
                of the segment represented  
                by current node, i.e., st[index]  
    qs & qe --> Starting and ending indexes of query range """"""
defRMQUtil( st, ss, se, qs, qe, index) : 
 
    # If segment of this node is a part  
    # of given range, then return  
    # the min of the segment  
    if(qs <=ss andqe >=se) : 
        returnst[index];  
 
    # If segment of this node  
    # is outside the given range  
    if(se < qs orss > qe) : 
        returnINT_MAX;  
 
    # If a part of this segment  
    # overlaps with the given range  
    mid =getMid(ss, se);  
    returnminVal(RMQUtil(st, ss, mid, qs,  
                          qe, 2*index +1),  
                  RMQUtil(st, mid +1, se, 
                          qs, qe, 2*index +2));  
 
# Return minimum of elements in range  
# from index qs (query start) to  
# qe (query end). It mainly uses RMQUtil()  
defRMQ( st, n, qs, qe) :  
 
    # Check for erroneous input values  
    if(qs < 0orqe > n -1orqs > qe) : 
     
        print(""Invalid Input"");  
        return-1;  
     
    returnRMQUtil(st, 0, n -1, qs, qe, 0);  
 
# A recursive function that constructs  
# Segment Tree for array[ss..se].  
# si is index of current node in segment tree st  
defconstructSTUtil(arr, ss, se, st, si) : 
 
    # If there is one element in array,  
    # store it in current node of  
    # segment tree and return  
    if(ss ==se) : 
 
        st[si] =arr[ss];  
        returnarr[ss];  
 
    # If there are more than one elements,  
    # then recur for left and right subtrees  
    # and store the minimum of two values in this node  
    mid =getMid(ss, se);  
    st[si] =minVal(constructSTUtil(arr, ss, mid, 
                                    st, si *2+1), 
                    constructSTUtil(arr, mid +1, se, 
                                    st, si *2+2));  
     
    returnst[si];  
 
""""""Function to construct segment tree  
from given array. This function allocates  
memory for segment tree and calls constructSTUtil() 
to fill the allocated memory """"""
defconstructST( arr, n) : 
 
    # Allocate memory for segment tree  
 
    # Height of segment tree  
    x =(int)(ceil(log2(n)));  
 
    # Maximum size of segment tree  
    max_size =2*(int)(2**x) -1;  
  
    st =[0] *(max_size);  
 
    # Fill the allocated memory st  
    constructSTUtil(arr, 0, n -1, st, 0);  
 
    # Return the constructed segment tree  
    returnst;  
 
# Driver Code 
if__name__ ==""__main__"":  
 
    arr =[1, 3, 2, 7, 9, 11];  
    n =len(arr);  
 
    # Build segment tree from given array  
    st =constructST(arr, n);  
 
    qs =1; # Starting index of query range  
    qe =5; # Ending index of query range  
 
    # Print minimum value in arr[qs..qe]  
    print(""Minimum of values in range ["", qs,  
          "","", qe, ""]"", ""is ="", RMQ(st, n, qs, qe));  
 
# This code is contributed by AnkitRai01  
",O(n),O(n)
"# Python3 program to show segment tree operations like 
# construction, query and update 
frommath importceil, log2;

# A utility function to get the
# middle index from corner indexes. 
defgetMid(s, e) :
    returns +(e -s) //2; 

"""""" A recursive function to get the sum of values 
    in the given range of the array. The following 
    are parameters for this function. 

    st --> Pointer to segment tree 
    si --> Index of current node in the segment tree. 
           Initially 0 is passed as root is always at index 0 
    ss & se --> Starting and ending indexes of the segment
                represented by current node, i.e., st[si] 
    qs & qe --> Starting and ending indexes of query range """"""
defgetSumUtil(st, ss, se, qs, qe, si) : 

    # If segment of this node is a part of given range, 
    # then return the sum of the segment 
    if(qs <=ss andqe >=se) :
        returnst[si]; 

    # If segment of this node is
    # outside the given range 
    if(se < qs orss > qe) :
        return0; 

    # If a part of this segment overlaps 
    # with the given range 
    mid =getMid(ss, se); 
    
    return(getSumUtil(st, ss, mid, qs, qe, 2*si +1) +
           getSumUtil(st, mid +1, se, qs, qe, 2*si +2)); 

"""""" A recursive function to update the nodes 
which have the given index in their range. 
The following are parameters st, si, ss and se 
are same as getSumUtil() 
i --> index of the element to be updated. 
      This index is in the input array. 
diff --> Value to be added to all nodes 
which have i in range """"""
defupdateValueUtil(st, ss, se, i, diff, si) : 

    # Base Case: If the input index lies 
    # outside the range of this segment 
    if(i < ss ori > se) :
        return; 

    # If the input index is in range of this node, 
    # then update the value of the node and its children 
    st[si] =st[si] +diff; 
    
    if(se !=ss) :
    
        mid =getMid(ss, se); 
        updateValueUtil(st, ss, mid, i, 
                        diff, 2*si +1); 
        updateValueUtil(st, mid +1, se, i, 
                         diff, 2*si +2); 

# The function to update a value in input array 
# and segment tree. It uses updateValueUtil() 
# to update the value in segment tree 
defupdateValue(arr, st, n, i, new_val) : 

    # Check for erroneous input index 
    if(i < 0ori > n -1) :
        
        print(""Invalid Input"", end =""""); 
        return; 

    # Get the difference between 
    # new value and old value 
    diff =new_val -arr[i]; 

    # Update the value in array 
    arr[i] =new_val; 

    # Update the values of nodes in segment tree 
    updateValueUtil(st, 0, n -1, i, diff, 0); 

# Return sum of elements in range from 
# index qs (query start) to qe (query end).
# It mainly uses getSumUtil() 
defgetSum(st, n, qs, qe) : 

    # Check for erroneous input values 
    if(qs < 0orqe > n -1orqs > qe) :

        print(""Invalid Input"", end =""""); 
        return-1; 
    
    returngetSumUtil(st, 0, n -1, qs, qe, 0); 

# A recursive function that constructs 
# Segment Tree for array[ss..se]. 
# si is index of current node in segment tree st 
defconstructSTUtil(arr, ss, se, st, si) : 

    # If there is one element in array, 
    # store it in current node of 
    # segment tree and return 
    if(ss ==se) :
    
        st[si] =arr[ss]; 
        returnarr[ss]; 
    
    # If there are more than one elements, 
    # then recur for left and right subtrees 
    # and store the sum of values in this node 
    mid =getMid(ss, se); 
    
    st[si] =(constructSTUtil(arr, ss, mid, st, si *2+1) +
             constructSTUtil(arr, mid +1, se, st, si *2+2)); 
    
    returnst[si]; 

"""""" Function to construct segment tree 
from given array. This function allocates memory
for segment tree and calls constructSTUtil() to 
fill the allocated memory """"""
defconstructST(arr, n) : 

    # Allocate memory for the segment tree 

    # Height of segment tree 
    x =(int)(ceil(log2(n))); 

    # Maximum size of segment tree 
    max_size =2*(int)(2**x) -1;
    
    # Allocate memory
    st =[0] *max_size; 

    # Fill the allocated memory st 
    constructSTUtil(arr, 0, n -1, st, 0); 

    # Return the constructed segment tree 
    returnst; 

# Driver Code
if__name__ ==""__main__"": 

    arr =[1, 3, 5, 7, 9, 11]; 
    n =len(arr); 

    # Build segment tree from given array 
    st =constructST(arr, n); 

    # Print sum of values in array from index 1 to 3 
    print(""Sum of values in given range = "",
                       getSum(st, n, 1, 3)); 

    # Update: set arr[1] = 10 and update 
    # corresponding segment tree nodes 
    updateValue(arr, st, n, 1, 10); 

    # Find sum after the value is updated 
    print(""Updated sum of values in given range = "",
                     getSum(st, n, 1, 3), end =""""); 
    
# This code is contributed by AnkitRai01
",O(N*log(N)),O(N*log(N))
"classSegmentTree:
    def__init__(self, array):
        self.size =len(array)
        self.tree =[0] *(4*self.size)
        self.build_tree(array, 0, 0, self.size -1)

    defbuild_tree(self, array, tree_index, left, right):
        ifleft ==right:
            self.tree[tree_index] =array[left]
            return
        mid =(left +right) //2
        self.build_tree(array, 2*tree_index +1, left, mid)
        self.build_tree(array, 2*tree_index +2, mid +1, right)
        self.tree[tree_index] =min(self.tree[2*tree_index +1], self.tree[2*tree_index +2])

    defquery(self, tree_index, left, right, query_left, query_right):
        ifquery_left <=left andright <=query_right:
            returnself.tree[tree_index]
        mid =(left +right) //2
        min_value =float('inf')
        ifquery_left <=mid:
            min_value =min(min_value, self.query(2*tree_index +1, left, mid, query_left, query_right))
        ifquery_right > mid:
            min_value =min(min_value, self.query(2*tree_index +2, mid +1, right, query_left, query_right))
        returnmin_value

    defquery_range(self, left, right):
        returnself.query(0, 0, self.size -1, left, right)


if__name__ =='__main__':
    array =[1, 3, 2, 5, 4, 6]
    st =SegmentTree(array)
    print(st.query_range(1, 5)) # 2
",O(N*log(N),O(4n)
"# Python program to print all 
# primes smaller than or equal to 
# n using Sieve of Eratosthenes 
 
 
defSieveOfEratosthenes(n): 
 
    # Create a boolean array 
    # ""prime[0..n]"" and initialize 
    #  all entries it as true. 
    # A value in prime[i] will 
    # finally be false if i is 
    # Not a prime, else true. 
    prime =[Truefori inrange(n+1)] 
    p =2
    while(p *p <=n): 
 
        # If prime[p] is not 
        # changed, then it is a prime 
        if(prime[p] ==True): 
 
            # Update all multiples of p 
            fori inrange(p *p, n+1, p): 
                prime[i] =False
        p +=1
 
    # Print all prime numbers 
    forp inrange(2, n+1): 
        ifprime[p]: 
            print(p) 
 
 
# Driver code 
if__name__ =='__main__': 
    n =20
    print(""Following are the prime numbers smaller""), 
    print(""than or equal to"", n) 
    SieveOfEratosthenes(n) 
",O(n*log(log(n))),O(n)
"# Python program for the above approach 
Primes =[0] *500001
defSieveOfEratosthenes(n) : 
     
    Primes[0] =1
    i =3
    while(i*i <=n) :  
        if(Primes[i //2] ==0) : 
            forj inrange(3*i, n+1, 2*i) :  
                Primes[j //2] =1
                 
        i +=2
         
# Driver Code 
if__name__ ==""__main__"": 
 
    n =100
    SieveOfEratosthenes(n) 
    fori inrange(1, n+1) : 
        if(i ==2) : 
            print( i, end ="" "") 
        elif(i %2==1andPrimes[i //2] ==0) : 
            print( i, end ="" "") 
     
    # This code is contributed by code_hunt.
",O(n*log(log(n))),O(n)
"# Python3 program for the above approach

# Method to find the maximum for each
# and every contiguous subarray
# of size K

defprintMax(arr, N, K):
    max=0

    fori inrange(N -K +1):
        max=arr[i]
        forj inrange(1, K):
            ifarr[i +j] > max:
                max=arr[i +j]
        print(str(max) +"" "", end="""")


# Driver's code
if__name__ ==""__main__"":
    arr =[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    N =len(arr)
    K =3
    
    # Function call
    printMax(arr, N, K)

# This code is contributed by Shiv Shankar
",O(N * K),O(1)
"importheapq


defmax_sliding_window(arr, k):
    ans =[]
    heap =[]

    # Initialize the heap with the first k elements
    fori inrange(k):
        heapq.heappush(heap, (-arr[i], i))

    # The maximum element in the first window
    ans.append(-heap[0][0])

    # Process the remaining elements
    fori inrange(k, len(arr)):
        heapq.heappush(heap, (-arr[i], i))

        # Remove elements that are outside the current window
        whileheap[0][1] <=i -k:
            heapq.heappop(heap)

        # The maximum element in the current window
        ans.append(-heap[0][0])

    returnans


arr =[2, 3, 7, 9, 5, 1, 6, 4, 3]
k =3

# Find the maximum element in each sliding window of size k
result =max_sliding_window(arr, k)

# Print the results
fornum inresult:
    print(num, end="" "")
",O(NlogN),O(N)
"# Python3 program to find the maximum for
# each and every contiguous subarray of
# size K

fromcollections importdeque

# A Deque (Double ended queue) based
# method for printing maximum element
# of all subarrays of size K


defprintMax(arr, N, K):
    """""" Create a Double Ended Queue, Qi that 
    will store indexes of array elements. 
    The queue will store indexes of useful 
    elements in every window and it will
    maintain decreasing order of values from
    front to rear in Qi, i.e., arr[Qi.front[]]
    to arr[Qi.rear()] are sorted in decreasing
    order""""""
    Qi =deque()

    # Process first k (or first window)
    # elements of array
    fori inrange(K):

        # For every element, the previous
        # smaller elements are useless
        # so remove them from Qi
        whileQi andarr[i] >=arr[Qi[-1]]:
            Qi.pop()

        # Add new element at rear of queue
        Qi.append(i)

    # Process rest of the elements, i.e.
    # from arr[k] to arr[n-1]
    fori inrange(K, N):

        # The element at the front of the
        # queue is the largest element of
        # previous window, so print it
        print(str(arr[Qi[0]]) +"" "", end="""")

        # Remove the elements which are
        # out of this window
        whileQi andQi[0] <=i-K:

            # remove from front of deque
            Qi.popleft()

        # Remove all elements smaller than
        # the currently being added element
        # (Remove useless elements)
        whileQi andarr[i] >=arr[Qi[-1]]:
            Qi.pop()

        # Add current element at the rear of Qi
        Qi.append(i)

    # Print the maximum element of last window
    print(str(arr[Qi[0]]))


# Driver's code
if__name__ ==""__main__"":
    arr =[12, 1, 78, 90, 57, 89, 56]
    K =3
    
    # Function call
    printMax(arr, len(arr), K)

# This code is contributed by Shiv Shankar
",O(NlogN),O(K)
"# Python3 program to find the maximum for
# each and every contiguous subarray of
# size K

fromcollections importdeque

# A Deque (Double ended queue) based
# method for printing maximum element
# of all subarrays of size K


defprintMax(arr, N, K):
    """""" Create a Double Ended Queue, Qi that 
    will store indexes of array elements. 
    The queue will store indexes of useful 
    elements in every window and it will
    maintain decreasing order of values from
    front to rear in Qi, i.e., arr[Qi.front[]]
    to arr[Qi.rear()] are sorted in decreasing
    order""""""
    Qi =deque()

    # Process first k (or first window)
    # elements of array
    fori inrange(K):

        # For every element, the previous
        # smaller elements are useless
        # so remove them from Qi
        whileQi andarr[i] >=arr[Qi[-1]]:
            Qi.pop()

        # Add new element at rear of queue
        Qi.append(i)

    # Process rest of the elements, i.e.
    # from arr[k] to arr[n-1]
    fori inrange(K, N):

        # The element at the front of the
        # queue is the largest element of
        # previous window, so print it
        print(str(arr[Qi[0]]) +"" "", end="""")

        # Remove the elements which are
        # out of this window
        whileQi andQi[0] <=i-K:

            # remove from front of deque
            Qi.popleft()

        # Remove all elements smaller than
        # the currently being added element
        # (Remove useless elements)
        whileQi andarr[i] >=arr[Qi[-1]]:
            Qi.pop()

        # Add current element at the rear of Qi
        Qi.append(i)

    # Print the maximum element of last window
    print(str(arr[Qi[0]]))


# Driver's code
if__name__ ==""__main__"":
    arr =[12, 1, 78, 90, 57, 89, 56]
    K =3
    
    # Function call
    printMax(arr, len(arr), K)

# This code is contributed by Shiv Shankar
",O(N),O(K)
"# Python3 program to find minimum number
# of dice throws required to reach last
# cell from first cell of a given
# snake and ladder board

# An entry in queue used in BFS


classQueueEntry(object):
    def__init__(self, v=0, dist=0):
        self.v =v
        self.dist =dist


'''This function returns minimum number of
dice throws required to. Reach last cell 
from 0'th cell in a snake and ladder game.
move[] is an array of size N where N is 
no. of cells on board. If there is no 
snake or ladder from cell i, then move[i] 
is -1. Otherwise move[i] contains cell to
which snake or ladder at i takes to.'''


defgetMinDiceThrows(move, N):

    # The graph has N vertices. Mark all
    # the vertices as not visited
    visited =[False] *N

    # Create a queue for BFS
    queue =[]

    # Mark the node 0 as visited and enqueue it
    visited[0] =True

    # Distance of 0't vertex is also 0
    # Enqueue 0'th vertex
    queue.append(QueueEntry(0, 0))

    # Do a BFS starting from vertex at index 0
    qe =QueueEntry()  # A queue entry (qe)
    whilequeue:
        qe =queue.pop(0)
        v =qe.v  # Vertex no. of queue entry

        # If front vertex is the destination
        # vertex, we are done
        ifv ==N -1:
            break

        # Otherwise dequeue the front vertex
        # and enqueue its adjacent vertices
        # (or cell numbers reachable through
        # a dice throw)
        j =v +1
        whilej <=v +6andj < N:

            # If this cell is already visited,
            # then ignore
            ifvisited[j] isFalse:

                # Otherwise calculate its
                # distance and mark it
                # as visited
                a =QueueEntry()
                a.dist =qe.dist +1
                visited[j] =True

                # Check if there a snake or ladder
                # at 'j' then tail of snake or top
                # of ladder become the adjacent of 'i'
                a.v =move[j] ifmove[j] !=-1elsej

                queue.append(a)

            j +=1

    # We reach here when 'qe' has last vertex
    # return the distance of vertex in 'qe
    returnqe.dist


# driver code
N =30
moves =[-1] *N

# Ladders
moves[2] =21
moves[4] =7
moves[10] =25
moves[19] =28

# Snakes
moves[26] =0
moves[20] =8
moves[16] =3
moves[18] =6

print(""Min Dice throws required is {0}"".
      format(getMinDiceThrows(moves, N)))

# This code is contributed by Ajitesh Pathak
",O(N),O(N)
"fromtyping importList, Dict


defmin_throw(n: int, arr: List[int]) -> int:
    # Initialise an array t of length 31, we will use from
    # index to 1 to 30
    t =[-1] *31

    # create a dictionary to store snakes and ladders start
    # and end for better efficiency
    h ={}
    fori inrange(0, 2*n, 2):
        # store start as key and end as value
        h[arr[i]] =arr[i +1]

    # final ans
    returnsol(1, h, t)

# recursive function


defsol(i: int, h: Dict[int, int], t: List[int]) -> int:
    # base condition
    ifi >=30:
        return0

    # checking if block is already visited or
    # not(memoization).
    elift[i] !=-1:
        returnt[i]

    # initialising min as max int value
    min_value =float(""inf"")

    # for loop for every dice value from 1 to 6
    forj inrange(1, 7):
        # incrementing value of i with dice value i.e j
        # taking new variable k
        # ->taking new variable so that we dont change i
        # as we will need it again in another iteration
        k =i +j
        ifk inh:
            # checking if this is a snake or ladder
            # if a snake then we continue as we dont
            # need a snake
            ifh[k] < k:
                continue
            # updating if it's a ladder to ladder end value
            k =h[k]
        # updating min in every iteration for getting
        # minimum throws from this particular block
        min_value =min(min_value, sol(k, h, t) +1)

    # updating value of t[i] to min
    # memoization
    t[i] =min_value
    returnt[i]


# Given a 5x6 snakes and ladders board
# You are given an integer N denoting the total
# number of snakes and ladders and a list arr[]
# of 2*N size where 2*i and (2*i + 1)th values
# denote the starting and ending point respectively
# of ith snake or ladder
N =8
arr =[3, 22, 5, 8, 11, 26, 20, 29, 17, 4, 19, 7, 27, 1, 29, 9]

print(""Min Dice throws required is"", min_throw(N, arr))
# This code is contributed by sanjanasikarwar24
",O(N),O(N)
"# Python program to sort a stack using recursion

# Recursive method to insert element in sorted way


defsortedInsert(s, element):

    # Base case: Either stack is empty or newly inserted
    # item is greater than top (more than all existing)
    iflen(s) ==0orelement > s[-1]:
        s.append(element)
        return
    else:

        # Remove the top item and recur
        temp =s.pop()
        sortedInsert(s, element)

        # Put back the top item removed earlier
        s.append(temp)

# Method to sort stack


defsortStack(s):

    # If stack is not empty
    iflen(s) !=0:

        # Remove the top item
        temp =s.pop()

        # Sort remaining stack
        sortStack(s)

        # Push the top item back in sorted stack
        sortedInsert(s, temp)

# Printing contents of stack


defprintStack(s):
    fori ins[::-1]:
        print(i, end="" "")
    print()


# Driver Code
if__name__ =='__main__':
    s =[]
    s.append(30)
    s.append(-5)
    s.append(18)
    s.append(14)
    s.append(-3)

    print(""Stack elements before sorting: "")
    printStack(s)

    sortStack(s)

    print(""\nStack elements after sorting: "")
    printStack(s)

# This code is contributed by Muskan Kalra.
",O(N2),O(N)
"# Function to sort a stack using recursion
defsortStack(s):
    # If the stack is empty, return
    ifnots:
        return

    # Remove the top element of the stack
    x =s.pop()

    # Sort the remaining elements in the stack using recursion
    sortStack(s)

    # Create two auxiliary stacks
    tempStack =[]

    # Move all elements that are greater than x from the main stack to the tempStack
    whiles ands[-1] > x:
        tempStack.append(s.pop())

    # Push x back into the main stack
    s.append(x)

    # Move all elements from tempStack back to the main stack
    whiletempStack:
        s.append(tempStack.pop())

# Create a stack
s =[]

# Push elements into the stack
s.append(34)
s.append(3)
s.append(31)
s.append(98)
s.append(92)
s.append(23)

# Sort the stack
sortStack(s)

# Print the sorted elements
print(""Sorted numbers are: "", end="""")
whiles:
    print(s.pop(), end="" "")
",O(n^2),O(n)
"# Python3 program that performs the following
# operations: Sort elements by frequency. If two elements
# have same count, then put the elements that appears first

# Used for sorting


classele:
    def__init__(self):

        self.count =0
        self.index =0
        self.val =0


defmycomp(a):
    returna.val

# Used for sorting by frequency. And if frequency is same,
# then by appearance


defmycomp2(a):
    # using negative value for a.index
    # since the sorting should be in
    # descending order
    return(a.count, -a.index)


defsortByFrequency(arr, n):
    element =[Nonefor_ inrange(n)]
    fori inrange(n):

        element[i] =ele()

        # Fill Indexes
        element[i].index =i

        # Initialize counts as 0
        element[i].count =0

        # Fill values in structure
        # elements
        element[i].val =arr[i]

    # Sort the structure elements according to value,
    # we used stable sort so relative order is maintained.
    #
    element.sort(key=mycomp)

    # initialize count of first element as 1
    element[0].count =1

    # Count occurrences of remaining elements
    fori inrange(1, n):

        if(element[i].val ==element[i -1].val):
            element[i].count +=element[i -1].count +1

            # Set count of previous element as -1, we are
            #  doing this because we'll again sort on the
            #  basis of counts (if counts are equal than on
            # the basis of index)*/
            element[i -1].count =-1

            # Retain the first index (Remember first index
            #  is always present in the first duplicate we
            #  used stable sort. */
            element[i].index =element[i -1].index

        # Else If previous element is not equal to current
        #  so set the count to 1
        else:
            element[i].count =1

    # Now we have counts and first index for each element
    # so now sort on the basis of count and in case of tie
    # use index to sort.*/
    element.sort(key=mycomp2)

    index =0
    fori inrange(n -1, -1, -1):
        if(element[i].count !=-1):
            forj inrange(element[i].count):
                arr[index] =element[i].val
                index +=1


# Driver code
arr =[2, 5, 2, 6, -1, 9999999, 5, 8, 8, 8]
n =len(arr)

# Function call
sortByFrequency(arr, n)

print(*arr)

# This code is contributed by phasing17
",O(N log N),O(N)
"# Python3 program for above approach

fromcollections importdefaultdict

# Sort by Frequency


defsortByFreq(arr, n):
    # arr -> Array to be sorted
    # n   -> Length of Array

    # d is a hashmap(referred as dictionary in python)
    d =defaultdict(lambda: 0)
    fori inrange(n):
        d[arr[i]] +=1

    # Sorting the array 'arr' where key
    # is the function based on which
    # the array is sorted
    # While sorting we want to give
    # first priority to Frequency
    # Then to value of item
    arr.sort(key=lambdax: (-d[x], x), reverse =True) 
    #require Updation:- reverse = True, to sort an array in descending order (Jayesh Verma)
    return(arr)


# Driver code
if__name__ ==""__main__"":
    arr =[2, 5, 2, 6, -1, 9999999, 5, 8, 8, 8]
    n =len(arr)

    # Function call
    solution =sortByFreq(arr, n)
    print(*solution)
",O(N log N),O(N)
"# Python code to implement the approach
classTree:
    element =None

    # to handle ties
    first_index =None
    count =None


BST =Tree()

# This code is contributed by phasing17
",O(N log N),O(N log N)
"fromcollections importdefaultdict
fromqueue importPriorityQueue

classCompare:
    def__init__(self, freq, val):
        self.freq =freq
        self.val =val

    def__lt__(self, other):
        ifself.freq ==other.freq:
            returnself.val < other.val
        returnself.freq > other.freq

defsolve(arr):
    n =len(arr)
    mpp =defaultdict(int)
    fora inarr:
        mpp[a] +=1
    max_heap =PriorityQueue()
    forkey, value inmpp.items():
        max_heap.put(Compare(value, key))

    i =0
    whilenotmax_heap.empty():
        item =max_heap.get()
        freq =item.freq
        val =item.val
        for_ inrange(freq):
            arr[i] =val
            i +=1
    returnarr

vec =[2, 5, 2, 8, 5, 6, 8, 8]
print(solve(vec))
",O(d * log(d)),O(d)
"# A program to take numbers from different machines and print them in sorted order

# A Linked List node
classListNode:
    def__init__(self, val=0, next=None):
        self.val =val
        self.next=next

# A Min Heao (Collection of Min Heap nodes)
classMinHeap:
    def__init__(self, capacity):
        self.count =0
        self.capacity =capacity
        self.array =[]

# A utility function to insert a new node at the beginning of linked list
defpush(head_ref, new_data):
    new_node =ListNode(new_data)
    new_node.next=head_ref
    head_ref =new_node
    returnhead_ref

# A utility function to swap two min heap nodes. This function
# is needed in minHeapify
defswap(a, b):
    temp =a
    a =b
    b =temp
    returna, b

# The standard minHeapify function.
defmin_heapify(min_heap, idx):
    left =2*idx +1
    right =2*idx +2
    smallest =idx

    if(left < min_heap.count and
            min_heap.array[left][0].val < min_heap.array[smallest][0].val):
        smallest =left
    if(right < min_heap.count and
            min_heap.array[right][0].val < min_heap.array[smallest][0].val):
        smallest =right
    ifsmallest !=idx:
        min_heap.array[smallest], min_heap.array[idx] =swap(
            min_heap.array[smallest], min_heap.array[idx])
        min_heapify(min_heap, smallest)

# A utility function to check whether a Min Heap is empty or not


defis_empty(min_heap):
    returnmin_heap.count ==0

# A standard function to build a heap
defbuild_min_heap(min_heap):
    n =min_heap.count -1
    fori inrange((n -1) //2, -1, -1):
        min_heapify(min_heap, i)

# This function inserts array elements to heap and then calls
# buildHeap for heap property among nodes
defpopulate_min_heap(min_heap, array, n):
    fori inrange(n):
        min_heap.array.append((array[i], i))
        min_heap.count +=1
    build_min_heap(min_heap)

# Return minimum element from all linked lists
defextract_min(min_heap):
    ifis_empty(min_heap):
        returnNone
    temp =min_heap.array[0][0]

    iftemp.nextisnotNone:
        min_heap.array[0] =(temp.next, min_heap.array[0][1])
    else:
        min_heap.array[0] =min_heap.array[min_heap.count -1]
        min_heap.count -=1

    min_heapify(min_heap, 0)
    returntemp

# The main function that takes an array of lists from N machines
# and generates the sorted output
defexternal_sort(array, n):
     # Create a min heap of size equal to number of machines
    min_heap =MinHeap(n)

    populate_min_heap(min_heap, array, n)

    whilenotis_empty(min_heap):
        temp =extract_min(min_heap)
        print(temp.val, end="" "")


# Driver program to test above functions
if__name__ =='__main__':
    N =3# Number of machines
    array =[None] *N

    # an array of pointers storing the head nodes of the linked lists
    array[0] =None
    array[0] =push(array[0], 50)
    array[0] =push(array[0], 40)
    array[0] =push(array[0], 30)

    # Create a Linked List 35->45 for second machine
    array[1] =None
    array[1] =push(array[1], 45)
    array[1] =push(array[1], 35)

    # Create Linked List 10->60->70->80 for third machine

    array[2] =None
    array[2] =push(array[2], 100)
    array[2] =push(array[2], 80)
    array[2] =push(array[2], 70)
    array[2] =push(array[2], 60)
    array[2] =push(array[2], 10)

    external_sort(array, N)
",O(N),O(N)
"importheapq

classListNode:
    def__init__(self, data):
        self.data =data
        self.next=None

defpush(head, data):
    # Function to insert a new node at the beginning of a linked list
    new_node =ListNode(data)
    new_node.next=head
    head =new_node
    returnhead

defprint_list(head):
    # Function to print the linked list
    whilehead:
        print(head.data, end="" "")
        head =head.next
    print()

defmerge_lists(lists):
    # Function to merge K sorted linked lists into a single sorted linked list
    dummy =ListNode(0)
    tail =dummy

    # Use a min heap to keep track of the smallest nodes from each list
    min_heap =[]

    forlst inlists:
        iflst:
            # Push the first node of each list into the min heap
            heapq.heappush(min_heap, (lst.data, lst))

    whilemin_heap:
        # Pop the smallest node from the min heap
        data, node =heapq.heappop(min_heap)

        # Append the smallest node to the sorted linked list
        tail.next=node
        tail =tail.next

        # If the popped node has a next node, push it into the min heap
        ifnode.next:
            heapq.heappush(min_heap, (node.next.data, node.next))

    returndummy.next

defexternal_sort(array):
    # Function to perform external sorting on an array of linked lists
    sorted_list =merge_lists(array)
    print_list(sorted_list)

if__name__ ==""__main__"":
    N =3# Number of machines

    array =[None] *N

    # Create the linked lists for each machine
    array[0] =None
    array[0] =push(array[0], 50)
    array[0] =push(array[0], 40)
    array[0] =push(array[0], 30)

    array[1] =None
    array[1] =push(array[1], 45)
    array[1] =push(array[1], 35)

    array[2] =None
    array[2] =push(array[2], 100)
    array[2] =push(array[2], 80)
    array[2] =push(array[2], 70)
    array[2] =push(array[2], 60)
    array[2] =push(array[2], 10)

    # Sort all elements
    external_sort(array)
",O(N + K log N),O(N + K)
"# Node class  
classNode: 
 
    # Constructor to initialize the node object 
    def__init__(self, data): 
        self.data =data 
        self.next=None
 
classLinkedList: 
 
    # Function to initialize head 
    def__init__(self): 
        self.head =None
 
    # Function to insert a new node at the beginning 
    defpush(self, new_data): 
        new_node =Node(new_data) 
        new_node.next=self.head 
        self.head =new_node 
 
    # Utility function to print the linked LinkedList 
    defprintList(self): 
        temp =self.head 
        print(temp.data,end=' ') 
        temp =temp.next
        while(temp !=self.head): 
            print(temp.data,end=' ') 
            temp =temp.next
 
    """""" function to insert a new_node in a list in sorted way. 
       Note that this function expects a pointer to head node 
       as this can modify the head of the input linked list """"""
    defsortedInsert(self, new_node): 
         
        current =self.head 
 
        # Case 1 of the above algo 
        ifcurrent isNone: 
            new_node.next=new_node  
            self.head =new_node 
         
        # Case 2 of the above algo 
        elif(current.data >=new_node.data): 
             
            # If value is smaller than head's value then we 
            # need to change next of last node 
            whilecurrent.next!=self.head : 
                current =current.next
            current.next=new_node 
            new_node.next=self.head 
            self.head =new_node             
 
         
        # Case 3 of the above algo 
        else: 
             
            # Locate the node before the point of insertion 
            while(current.next!=self.head  and
                   current.next.data < new_node.data): 
                current =current.next
 
            new_node.next=current.next
            current.next=new_node 
 
 
# Driver program to test the above function 
#llist = LinkedList() 
arr =[12, 56, 2, 11, 1, 90] 
 
list_size =len(arr) 
 
# start with empty linked list 
start =LinkedList() 
 
# Create linked list from the array arr[] 
# Created linked list will be 1->2->11->12->56->90 
fori inrange(list_size): 
    temp =Node(arr[i]) 
    start.sortedInsert(temp) 
 
start.printList() 
 
# This code is contributed by Nikhil Kumar Singh(nickzuck_007) 
",O(n),O(1)
"# Case 2 of the above algo 
elif(current.data >=new_node.data): 
   
  # swap the data part of head node and new node 
  # assuming that we have a function swap(int *, int *) 
  tmp =current.data; 
  current.data =new_node.data; 
  new_node.data =tmp; 
  new_node.next=(head_ref).next; 
  (head_ref).next=new_node; 
 
# This code is contributed by _saurabh_jaiswal 
",O(1),O(1)
"# Python program to split circular linked list into two halves

# A node structure
classNode:
    
    # Constructor to create a new node
    def__init__(self, data):
        self.data =data
        self.next=None


# Class to create a new  Circular Linked list
classCircularLinkedList:
    
    # Constructor to create a empty circular linked list
    def__init__(self):
        self.head =None

    # Function to insert a node at the beginning of a
    # circular linked list
    defpush(self, data):
        ptr1 =Node(data)
        temp =self.head
        
        ptr1.next=self.head

        # If linked list is not None then set the next of
        # last node
        ifself.head isnotNone:
            while(temp.next!=self.head):
                temp =temp.next
            temp.next=ptr1

        else:
            ptr1.next=ptr1 # For the first node

        self.head =ptr1 

    # Function to print nodes in a given circular linked list
    defprintList(self):
        temp =self.head
        ifself.head isnotNone:
            while(True):
                print(""%d""%(temp.data),end=' ')
                temp =temp.next
                if(temp ==self.head):
                    break


    # Function to split a list (starting with head) into 
    # two lists. head1 and head2 are the head nodes of the
    # two resultant linked lists
    defsplitList(self, head1, head2):
        slow_ptr =self.head 
        fast_ptr =self.head
    
        ifself.head isNone:
            return
        
        # If there are odd nodes in the circular list then
        # fast_ptr->next becomes head and for even nodes
        # fast_ptr->next->next becomes head
        while(fast_ptr.next!=self.head and
            fast_ptr.next.next!=self.head ):
            fast_ptr =fast_ptr.next.next
            slow_ptr =slow_ptr.next

        # If there are even elements in list then
        # move fast_ptr
        iffast_ptr.next.next==self.head:
            fast_ptr =fast_ptr.next

        # Set the head pointer of first half
        head1.head =self.head

        # Set the head pointer of second half
        ifself.head.next!=self.head:
            head2.head =slow_ptr.next

        # Make second half circular
        fast_ptr.next=slow_ptr.next
    
        # Make first half circular
        slow_ptr.next=self.head


# Driver program to test above functions

# Initialize lists as empty
head =CircularLinkedList() 
head1 =CircularLinkedList()
head2 =CircularLinkedList()

head.push(12)
head.push(56)
head.push(2)
head.push(11)

print(""Original Circular Linked List"")
head.printList()

# Split the list 
head.splitList(head1 , head2)

print(""\nFirst Circular Linked List"")
head1.printList()

print(""\nSecond Circular Linked List"")
head2.printList()

# This code is contributed by Nikhil Kumar Singh(nickzuck_007)
",O(n),O(1)
"# python3 program for Babylonian 
# method for square root

# Returns the square root of n.
# Note that the function
# will not work for numbers 
# which are not perfect squares

defsquareRoot(n):
    x =n;
    y =1;
    while(x > y):
        x =(x +y) /2;
        y =n /x;
    returnx;

# Driver Code
n =49;
print(""root of"", n, ""is"", squareRoot(n));

# This code is contributed by mits.
",O(n1/2),O(1)
"# python3 program for Babylonian 
# method for square root

# Returns the square root of n.
# Note that the function
# will not work for numbers 
# which are not perfect squares

defsquareRoot(n):
    x =n;
    y =1;
    while(x > y):
        x =(x +y) /2;
        y =n /x;
    returnx;

# Driver Code
n =49;
print(""root of"", n, ""is"", squareRoot(n));

# This code is contributed by mits.
",O(n1/2),O(1)
"# Python program to reverse a string using stack

# Function to create an empty stack.
# It initializes size of stack as 0


defcreateStack():
    stack =[]
    returnstack

# Function to determine the size of the stack


defsize(stack):
    returnlen(stack)

# Stack is empty if the size is 0


defisEmpty(stack):
    ifsize(stack) ==0:
        returntrue

# Function to add an item to stack .
# It increases size by 1


defpush(stack, item):
    stack.append(item)

# Function to remove an item from stack.
# It decreases size by 1


defpop(stack):
    ifisEmpty(stack):
        return
    returnstack.pop()

# A stack based function to reverse a string


defreverse(string):
    n =len(string)

    # Create a empty stack
    stack =createStack()

    # Push all characters of string to stack
    fori inrange(0, n, 1):
        push(stack, string[i])

    # Making the string empty since all
    # characters are saved in stack
    string =""""

    # Pop all characters of string and
    # put them back to string
    fori inrange(0, n, 1):
        string +=pop(stack)

    returnstring


# Driver program to test above functions
string =""GeeksQuiz""
string =reverse(string)
print(""Reversed string is ""+string)

# This code is contributed by Sunny Karira
",O(N),O(N)
"# import the required module
importstring

# define a function to reverse a string
defthe_helper(s):
    # create an empty stack
    stack =[]
    # push all characters of the string into the stack
    fori ins:
        stack.append(i)
    # empty the string
    s =""""
    # pop all characters from the stack and append to the string
    whilestack:
        s +=stack.pop()
    # return the reversed string
    returns

# main function
if__name__ ==""__main__"":
    # define the input string
    str=""GeeksQuiz""
    
    # call the function to reverse the string
    reversed_str =the_helper(str)
    
    # print the reversed string
    print(""Reversed string is: "", reversed_str)
",O(N),O(N)
"# N is the size of the 2D matrix   N*N
N =9

# A utility function to print grid
defprinting(arr):
    fori inrange(N):
        forj inrange(N):
            print(arr[i][j], end ="" "")
        print()

# Checks whether it will be
# legal to assign num to the
# given row, col
defisSafe(grid, row, col, num):
  
    # Check if we find the same num
    # in the similar row , we
    # return false
    forx inrange(9):
        ifgrid[row][x] ==num:
            returnFalse

    # Check if we find the same num in
    # the similar column , we
    # return false
    forx inrange(9):
        ifgrid[x][col] ==num:
            returnFalse

    # Check if we find the same num in
    # the particular 3*3 matrix,
    # we return false
    startRow =row -row %3
    startCol =col -col %3
    fori inrange(3):
        forj inrange(3):
            ifgrid[i +startRow][j +startCol] ==num:
                returnFalse
    returnTrue

# Takes a partially filled-in grid and attempts
# to assign values to all unassigned locations in
# such a way to meet the requirements for
# Sudoku solution (non-duplication across rows,
# columns, and boxes) */
defsolveSudoku(grid, row, col):
  
    # Check if we have reached the 8th
    # row and 9th column (0
    # indexed matrix) , we are
    # returning true to avoid
    # further backtracking
    if(row ==N -1andcol ==N):
        returnTrue
      
    # Check if column value  becomes 9 ,
    # we move to next row and
    # column start from 0
    ifcol ==N:
        row +=1
        col =0

    # Check if the current position of
    # the grid already contains
    # value >0, we iterate for next column
    ifgrid[row][col] > 0:
        returnsolveSudoku(grid, row, col +1)
    fornum inrange(1, N +1, 1):
      
        # Check if it is safe to place
        # the num (1-9)  in the
        # given row ,col  ->we
        # move to next column
        ifisSafe(grid, row, col, num):
          
            # Assigning the num in
            # the current (row,col)
            # position of the grid
            # and assuming our assigned
            # num in the position
            # is correct
            grid[row][col] =num

            # Checking for next possibility with next
            # column
            ifsolveSudoku(grid, row, col +1):
                returnTrue

        # Removing the assigned num ,
        # since our assumption
        # was wrong , and we go for
        # next assumption with
        # diff num value
        grid[row][col] =0
    returnFalse

# Driver Code

# 0 means unassigned cells
grid =[[3, 0, 6, 5, 0, 8, 4, 0, 0],
        [5, 2, 0, 0, 0, 0, 0, 0, 0],
        [0, 8, 7, 0, 0, 0, 0, 3, 1],
        [0, 0, 3, 0, 1, 0, 0, 8, 0],
        [9, 0, 0, 8, 6, 3, 0, 0, 5],
        [0, 5, 0, 0, 9, 0, 6, 0, 0],
        [1, 3, 0, 0, 0, 0, 2, 5, 0],
        [0, 0, 0, 0, 0, 0, 0, 7, 4],
        [0, 0, 5, 2, 0, 6, 3, 0, 0]]

if(solveSudoku(grid, 0, 0)):
    printing(grid)
else:
    print(""no solution  exists "")

    # This code is contributed by sudhanshgupta2019a
",O(9(N*N)),O(9(N*N))
"# A Backtracking program 
# in Python to solve Sudoku problem

# A Utility Function to print the Grid
defprint_grid(arr):
    fori inrange(9):
        forj inrange(9):
            print(arr[i][j], end ="" ""),
        print()

        
# Function to Find the entry in 
# the Grid that is still  not used
# Searches the grid to find an 
# entry that is still unassigned. If
# found, the reference parameters 
# row, col will be set the location
# that is unassigned, and true is 
# returned. If no unassigned entries
# remains, false is returned.
# 'l' is a list  variable that has 
# been passed from the solve_sudoku function
# to keep track of incrementation 
# of Rows and Columns
deffind_empty_location(arr, l):
    forrow inrange(9):
        forcol inrange(9):
            if(arr[row][col]==0):
                l[0]=row
                l[1]=col
                returnTrue
    returnFalse

# Returns a boolean which indicates 
# whether any assigned entry
# in the specified row matches 
# the given number.
defused_in_row(arr, row, num):
    fori inrange(9):
        if(arr[row][i] ==num):
            returnTrue
    returnFalse

# Returns a boolean which indicates 
# whether any assigned entry
# in the specified column matches 
# the given number.
defused_in_col(arr, col, num):
    fori inrange(9):
        if(arr[i][col] ==num):
            returnTrue
    returnFalse

# Returns a boolean which indicates 
# whether any assigned entry
# within the specified 3x3 box 
# matches the given number
defused_in_box(arr, row, col, num):
    fori inrange(3):
        forj inrange(3):
            if(arr[i +row][j +col] ==num):
                returnTrue
    returnFalse

# Checks whether it will be legal 
# to assign num to the given row, col
# Returns a boolean which indicates 
# whether it will be legal to assign
# num to the given row, col location.
defcheck_location_is_safe(arr, row, col, num):
    
    # Check if 'num' is not already 
    # placed in current row,
    # current column and current 3x3 box
    return(notused_in_row(arr, row, num) and
           (notused_in_col(arr, col, num) and
           (notused_in_box(arr, row -row %3, 
                           col -col %3, num))))

# Takes a partially filled-in grid 
# and attempts to assign values to
# all unassigned locations in such a 
# way to meet the requirements
# for Sudoku solution (non-duplication 
# across rows, columns, and boxes)
defsolve_sudoku(arr):
    
    # 'l' is a list variable that keeps the 
    # record of row and col in 
    # find_empty_location Function    
    l =[0, 0]
    
    # If there is no unassigned 
    # location, we are done    
    if(notfind_empty_location(arr, l)):
        returnTrue
    
    # Assigning list values to row and col 
    # that we got from the above Function 
    row =l[0]
    col =l[1]
    
    # consider digits 1 to 9
    fornum inrange(1, 10):
        
        # if looks promising
        if(check_location_is_safe(arr, 
                          row, col, num)):
            
            # make tentative assignment
            arr[row][col]=num

            # return, if success, 
            # ya ! 
            if(solve_sudoku(arr)):
                returnTrue

            # failure, unmake & try again
            arr[row][col] =0
            
    # this triggers backtracking        
    returnFalse

# Driver main function to test above functions
if__name__==""__main__"":
    
    # creating a 2D array for the grid
    grid =[[0forx inrange(9)]fory inrange(9)]
    
    # assigning values to the grid
    grid =[[3, 0, 6, 5, 0, 8, 4, 0, 0],
          [5, 2, 0, 0, 0, 0, 0, 0, 0],
          [0, 8, 7, 0, 0, 0, 0, 3, 1],
          [0, 0, 3, 0, 1, 0, 0, 8, 0],
          [9, 0, 0, 8, 6, 3, 0, 0, 5],
          [0, 5, 0, 0, 9, 0, 6, 0, 0],
          [1, 3, 0, 0, 0, 0, 2, 5, 0],
          [0, 0, 0, 0, 0, 0, 0, 7, 4],
          [0, 0, 5, 2, 0, 6, 3, 0, 0]]
    
    # if success print the grid
    if(solve_sudoku(grid)):
        print_grid(grid)
    else:
        print(""No solution exists"")

# The above code has been contributed by Harshit Sidhwa.
",O(9(N*N)),O(N*N)
"# N is the size of the 2D matrix N*N
N =9

# A utility function to print grid


defprinting(arr):
    fori inrange(N):
        forj inrange(N):
            print(arr[i][j], end="" "")
        print()

# Checks whether it will be
# legal to assign num to the
# given row, col


defisSafe(grid, row, col, num):

    # Check if we find the same num
    # in the similar row , we
    # return false
    forx inrange(9):
        ifgrid[row][x] ==num:
            returnFalse

    # Check if we find the same num in
    # the similar column , we
    # return false
    forx inrange(9):
        ifgrid[x][col] ==num:
            returnFalse

    # Check if we find the same num in
    # the particular 3*3 matrix,
    # we return false
    startRow =row -row %3
    startCol =col -col %3
    fori inrange(3):
        forj inrange(3):
            ifgrid[i +startRow][j +startCol] ==num:
                returnFalse
    returnTrue

# Takes a partially filled-in grid and attempts
# to assign values to all unassigned locations in
# such a way to meet the requirements for
# Sudoku solution (non-duplication across rows,
# columns, and boxes) */


defsolveSudoku(grid, row, col):

    # Check if we have reached the 8th
    # row and 9th column (0
    # indexed matrix) , we are
    # returning true to avoid
    # further backtracking
    if(row ==N -1andcol ==N):
        returnTrue

    # Check if column value becomes 9 ,
    # we move to next row and
    # column start from 0
    ifcol ==N:
        row +=1
        col =0

    # Check if the current position of
    # the grid already contains
    # value >0, we iterate for next column
    ifgrid[row][col] > 0:
        returnsolveSudoku(grid, row, col +1)
    fornum inrange(1, N +1, 1):

        # Check if it is safe to place
        # the num (1-9) in the
        # given row ,col ->we
        # move to next column
        ifisSafe(grid, row, col, num):

            # Assigning the num in
            # the current (row,col)
            # position of the grid
            # and assuming our assigned
            # num in the position
            # is correct
            grid[row][col] =num

            # Checking for next possibility with next
            # column
            ifsolveSudoku(grid, row, col +1):
                returnTrue

        # Removing the assigned num ,
        # since our assumption
        # was wrong , and we go for
        # next assumption with
        # diff num value
        grid[row][col] =0
    returnFalse

# Driver Code


# 0 means unassigned cells
grid =[[3, 0, 6, 5, 0, 8, 4, 0, 0],
        [5, 2, 0, 0, 0, 0, 0, 0, 0],
        [0, 8, 7, 0, 0, 0, 0, 3, 1],
        [0, 0, 3, 0, 1, 0, 0, 8, 0],
        [9, 0, 0, 8, 6, 3, 0, 0, 5],
        [0, 5, 0, 0, 9, 0, 6, 0, 0],
        [1, 3, 0, 0, 0, 0, 2, 5, 0],
        [0, 0, 0, 0, 0, 0, 0, 7, 4],
        [0, 0, 5, 2, 0, 6, 3, 0, 0]]

if(solveSudoku(grid, 0, 0)):
    printing(grid)
else:
    print(""no solution exists "")

# This code is contributed by sanjoy_62.
",O(9(N*N)),O(N*N)
"# This program works by identifying the remaining elements and backtrack only on those.
# The elements are inserted in the increasing order of the elements left to be inserted. And hence runs much faster.
# Comparing with other back tracking algorithms, it runs 5X faster.

# Input matrix
arr =[
    [3, 0, 6, 5, 0, 8, 4, 0, 0],
    [5, 2, 0, 0, 0, 0, 0, 0, 0],
    [0, 8, 7, 0, 0, 0, 0, 3, 1],
    [0, 0, 3, 0, 1, 0, 0, 8, 0],
    [9, 0, 0, 8, 6, 3, 0, 0, 5],
    [0, 5, 0, 0, 9, 0, 6, 0, 0],
    [1, 3, 0, 0, 0, 0, 2, 5, 0],
    [0, 0, 0, 0, 0, 0, 0, 7, 4],
    [0, 0, 5, 2, 0, 6, 3, 0, 0]
]

# Position of the input elements in the arr
# pos = {
#     element: [[position 1], [position 2]]
# }
pos ={}

# Count of the remaining number of the elements
# rem = {
#     element: pending count
# }
rem ={}

# Graph defining tentative positions of the elements to be filled
# graph = {
#     key: {
#         row1: [columns],
#         row2: [columns]
#     }
# }
graph ={}


# Print the matrix array
defprintMatrix():
    fori inrange(0, 9):
        forj inrange(0, 9):
            print(str(arr[i][j]), end="" "")
        print()


# Method to check if the inserted element is safe
defis_safe(x, y):
    key =arr[x][y]
    fori inrange(0, 9):
        ifi !=y andarr[x][i] ==key:
            returnFalse
        ifi !=x andarr[i][y] ==key:
            returnFalse

    r_start =int(x /3) *3
    r_end =r_start +3

    c_start =int(y /3) *3
    c_end =c_start +3

    fori inrange(r_start, r_end):
        forj inrange(c_start, c_end):
            ifi !=x andj !=y andarr[i][j] ==key:
                returnFalse
    returnTrue


# method to fill the matrix
# input keys: list of elements to be filled in the matrix
#        k   : index number of the element to be picked up from keys
#        rows: list of row index where element is to be inserted
#        r   : index number of the row to be inserted
#
deffill_matrix(k, keys, r, rows):
    forc ingraph[keys[k]][rows[r]]:
        ifarr[rows[r]] > 0:
            continue
        arr[rows[r]] =keys[k]
        ifis_safe(rows[r], c):
            ifr < len(rows) -1:
                iffill_matrix(k, keys, r +1, rows):
                    returnTrue
                else:
                    arr[rows[r]] =0
                    continue
            else:
                ifk < len(keys) -1:
                    iffill_matrix(k +1, keys, 0, list(graph[keys[k +1]].keys())):
                        returnTrue
                    else:
                        arr[rows[r]] =0
                        continue
                returnTrue
        arr[rows[r]] =0
    returnFalse


# Fill the pos and rem dictionary. It will be used to build graph
defbuild_pos_and_rem():
    fori inrange(0, 9):
        forj inrange(0, 9):
            ifarr[i][j] > 0:
                ifarr[i][j] notinpos:
                    pos[arr[i][j]] =[]
                pos[arr[i][j]].append([i, j])
                ifarr[i][j] notinrem:
                    rem[arr[i][j]] =9
                rem[arr[i][j]] -=1

    # Fill the elements not present in input matrix. Example: 1 is missing in input matrix
    fori inrange(1, 10):
        ifi notinpos:
            pos[i] =[]
        ifi notinrem:
            rem[i] =9

# Build the graph


defbuild_graph():
    fork, v inpos.items():
        ifk notingraph:
            graph[k] ={}

        row =list(range(0, 9))
        col =list(range(0, 9))

        forcord inv:
            row.remove(cord[0])
            col.remove(cord[1])

        iflen(row) ==0orlen(col) ==0:
            continue

        forr inrow:
            forc incol:
                ifarr[r] ==0:
                    ifr notingraph[k]:
                        graph[k][r] =[]
                    graph[k][r].append(c)


build_pos_and_rem()

# Sort the rem map in order to start with smaller number of elements to be filled first. Optimization for pruning
rem ={k: v fork, v insorted(rem.items(), key=lambdaitem: item[1])}

build_graph()

key_s =list(rem.keys())
# Util called to fill the matrix
fill_matrix(0, key_s, 0, list(graph[key_s[0]].keys()))

printMatrix()

# This code is contributed by Arun Kumar
",O(9^(n*n)),O(n*n)
"# Naive algorithm for building suffix array of a given text
importsys


classSuffix:
    def__init__(self, index, suff):
        self.index =index
        self.suff =suff

# A comparison function used by sort() to compare two suffixes
defcmp(a, b):
    return(a.suff < b.suff) -(a.suff > b.suff)

# This is the main function that takes a string 'txt' of size n as an
# argument, builds and return the suffix array for the given string
defbuild_suffix_array(txt, n):
    # A structure to store suffixes and their indexes
    suffixes =[Suffix(i, txt[i:]) fori inrange(n)]

    # Sort the suffixes using the comparison function
    # defined above.
    suffixes.sort(key=cmp)

    # Store indexes of all sorted suffixes in the suffix array
    suffix_arr =[suffixes[i].index fori inrange(n)]

    # Return the suffix array
    returnsuffix_arr

# A utility function to print an array of given size
defprint_arr(arr):
    fori inrange(len(arr)):
        print(arr[i], end="" "")
    print()

# Driver program to test above functions
defmain():
    txt =""banana""
    n =len(txt)
    suffix_arr =build_suffix_array(txt, n)
    print(""Following is suffix array for"", txt)
    print_arr(suffix_arr)

if__name__ ==""__main__"":
    main()
",O(n*k*Logn),O(n*k*Logn)
"importsys

# A suffix array based search function to search a given pattern
# 'pat' in given text 'txt' using suffix array suffArr[]
defsearch(pat, txt, suffArr, n):
  
    # Get the length of the pattern
    m =len(pat)
    
    # Initialize left and right indexes
    l =0
    r =n-1
    
    # Do simple binary search for the pat in txt using the built suffix array
    whilel <=r:
      
        # Find the middle index of the current subarray
        mid =l +(r -l)//2
        
        # Get the substring of txt starting from suffArr[mid] and of length m
        res =txt[suffArr[mid]:suffArr[mid]+m]
        
        # If the substring is equal to the pattern
        ifres ==pat:
          
            # Print the index and return
            print(""Pattern found at index"", suffArr[mid])
            return
          
        # If the substring is less than the pattern
        ifres < pat:
          
            # Move to the right half of the subarray
            l =mid +1
        else:
          
            # Move to the left half of the subarray
            r =mid -1
            
    # If the pattern is not found
    print(""Pattern not found"")
    
defbuildSuffixArray(txt, n):
  
    # Create a list of all suffixes
    suffixes =[txt[i:] fori inrange(n)]
    
    # Sort the suffixes
    suffixes.sort()
    
    # Create the suffix array
    suffArr =[txt.index(suffix) forsuffix insuffixes]
    returnsuffArr

# Driver program to test above function
defmain():
    txt =""banana""# text
    pat =""nan""# pattern to be searched in text

    # Build suffix array
    n =len(txt)
    suffArr =buildSuffixArray(txt, n)

    # search pat in txt using the built suffix array
    search(pat, txt, suffArr, n)
    return0

if__name__ =='__main__':
    sys.exit(main())

# This code is contributed by Vikram_Shirsat
",O(mlogn),O(m+n)
"# Python3 program for building suffix 
# array of a given text

# Class to store information of a suffix
classsuffix:
    
    def__init__(self):
        
        self.index =0
        self.rank =[0, 0]

# This is the main function that takes a 
# string 'txt' of size n as an argument, 
# builds and return the suffix array for
# the given string
defbuildSuffixArray(txt, n):
    
    # A structure to store suffixes 
    # and their indexes
    suffixes =[suffix() for_ inrange(n)]

    # Store suffixes and their indexes in
    # an array of structures. The structure
    # is needed to sort the suffixes alphabetically
    # and maintain their old indexes while sorting
    fori inrange(n):
        suffixes[i].index =i
        suffixes[i].rank[0] =(ord(txt[i]) -
                               ord(""a""))
        suffixes[i].rank[1] =(ord(txt[i +1]) -
                        ord(""a"")) if((i +1) < n) else-1

    # Sort the suffixes according to the rank
    # and next rank
    suffixes =sorted(
        suffixes, key =lambdax: (
            x.rank[0], x.rank[1]))

    # At this point, all suffixes are sorted 
    # according to first 2 characters.  Let 
    # us sort suffixes according to first 4
    # characters, then first 8 and so on
    ind =[0] *n  # This array is needed to get the
                   # index in suffixes[] from original
                   # index.This mapping is needed to get
                   # next suffix.
    k =4
    while(k < 2*n):
        
        # Assigning rank and index 
        # values to first suffix
        rank =0
        prev_rank =suffixes[0].rank[0]
        suffixes[0].rank[0] =rank
        ind[suffixes[0].index] =0

        # Assigning rank to suffixes
        fori inrange(1, n):
            
            # If first rank and next ranks are 
            # same as that of previous suffix in
            # array, assign the same new rank to 
            # this suffix
            if(suffixes[i].rank[0] ==prev_rank and
                suffixes[i].rank[1] ==suffixes[i -1].rank[1]):
                prev_rank =suffixes[i].rank[0]
                suffixes[i].rank[0] =rank
                
            # Otherwise increment rank and assign    
            else:  
                prev_rank =suffixes[i].rank[0]
                rank +=1
                suffixes[i].rank[0] =rank
            ind[suffixes[i].index] =i

        # Assign next rank to every suffix
        fori inrange(n):
            nextindex =suffixes[i].index +k //2
            suffixes[i].rank[1] =suffixes[ind[nextindex]].rank[0] \
                if(nextindex < n) else-1

        # Sort the suffixes according to
        # first k characters
        suffixes =sorted(
            suffixes, key =lambdax: (
                x.rank[0], x.rank[1]))

        k *=2

    # Store indexes of all sorted 
    # suffixes in the suffix array
    suffixArr =[0] *n
    
    fori inrange(n):
        suffixArr[i] =suffixes[i].index

    # Return the suffix array
    returnsuffixArr

# A utility function to print an array
# of given size
defprintArr(arr, n):
    
    fori inrange(n):
        print(arr[i], end ="" "")
        
    print()

# Driver code
if__name__ ==""__main__"":
    
    txt =""banana""
    n =len(txt)
    
    suffixArr =buildSuffixArray(txt, n)
    
    print(""Following is suffix array for"", txt)
    
    printArr(suffixArr, n)

# This code is contributed by debrc
",O(n Log n),O(n)
"s =""banana""
n =len(s)
suffix =[0] *n
sub =[""""] *n

# Mapping string with its index of
# it's last letter.
fori inrange(n):
    sub[i] =s[i:]

# Sorting all substrings
sub.sort()

# Storing all values of map
# in suffix array.
fori inrange(n):
    suffix[i] =n -len(sub[i])

# printing suffix array.
print(""Suffix array for banana is"")
fori insuffix:
    print(i,end ="" "")
",O(N2 + Nlog(N)),O(n)
"# Python program to
# swap bits in a given number

defswapBits(x, p1, p2, n):

    # Move all bits of first
    # set to rightmost side 
    set1 =(x >> p1) & ((1<< n) -1)
 
    # Move all bits of second
    # set to rightmost side 
    set2 =(x >> p2) & ((1<< n) -1)
 
    # XOR the two sets 
    xor =(set1 ^ set2)
 
    # Put the xor bits back
    # to their original positions 
    xor =(xor << p1) | (xor << p2)
 
      # XOR the 'xor' with the
      # original number so that the 
      # two sets are swapped
    result =x ^ xor
 
    returnresult
    
# Driver code

res =swapBits(28, 0, 3, 2)
print(""Result ="", res)

# This code is contributed
# by Anant Agarwal.
",O(1),O(1)
"# Python code to implement the approach
defswapBits(x, p1, p2, n) :
    
    # xor contains xor of two sets 
    xor =(((x >> p1) ^ (x >> p2)) & ((1<< n) -1))
 
    # To swap two sets, we need to again XOR the xor with original sets 
    returnx ^ ( (xor << p1) | (xor << p2))
  
  # This code is contributed by sanjoy_62.
",O(1),O(1)
"defswapBits(num, p1, p2, n):
    shift1 =0
    shift2 =0
    value1 =0
    value2 =0

    while(n > 0):
      
        # Setting bit at p1 position to 1 
        shift1 =1<< p1

        # Setting bit at p2 position to 1 
        shift2 =1<< p2

        # value1 and value2 will have 0 if num 
        # at the respective positions - p1 and p2 is 0. 
        value1 =((num & shift1))
        value2 =((num & shift2))

        # check if value1 and value2 are different 
        # i.e. at one position bit is set and other it is not 
        if((value1 ==0andvalue2 !=0) or(value2 ==0andvalue1 !=0)):
            
            # if bit at p1 position is set 
            if(value1 !=0):

                # unset bit at p1 position 
                num =num & (~shift1)

                # set bit at p2 position 
                num =num | shift2

            # if bit at p2 position is set 
            else:

                # set bit at p2 position 
                num =num & (~shift2)

                # unset bit at p2 position
                num =num | shift1
        p1 +=1
        p2 +=1
        n -=1

    # return final result 
    returnnum

# Driver code
res =swapBits(28, 0, 3, 2)
print(""Result ="", res)

# This code is contributed by avanitrachhadiya2155
",O(N),O(1)
"# python program Swap
# two nibbles in a byte

defswapNibbles(x):
    return( (x & 0x0F)<<4| (x & 0xF0)>>4)

# Driver code

x =100
print(swapNibbles(x))

# This code is contributed
# by Anant Agarwal.
",O(1),O(1)
"# Python code for the above approach
frommath importceil, sqrt

defswapNibbles(N) :
    
    # Step 1
    right =(N & 0b00001111)
    
    # Step 3
    right=(right<<4)
    
    # Step 2
    left =(N & 0b11110000)
      
    # Step 4
    left =(left>>4)
    
    # Step 5
    return(right | left)

# Driver Code
n =100;
print(""Original: "", n, end ="" "")
print("" Swapped: "", swapNibbles(n))

# This code is contributed by code_hunt.
",O(1),O(1)
"classNode: 
    def__init__(self, data): 
        self.data =data 
        self.isEndOfString =False
        self.left =None
        self.eq =None
        self.right =None
 
 
definsert(root, word): 
    ifnotroot: 
        root =Node(word[0]) 
    ifword[0] < root.data: 
        root.left =insert(root.left, word) 
    elifword[0] > root.data: 
        root.right =insert(root.right, word) 
    else: 
        iflen(word) > 1: 
            root.eq =insert(root.eq, word[1:]) 
        else: 
            root.isEndOfString =True
    returnroot 
 
 
deftraverseTSTUtil(root, buffer, depth): 
    ifroot: 
        traverseTSTUtil(root.left, buffer, depth) 
        buffer[depth] =root.data 
        ifroot.isEndOfString: 
            print("""".join(buffer[:depth+1])) 
        traverseTSTUtil(root.eq, buffer, depth+1) 
        traverseTSTUtil(root.right, buffer, depth) 
 
 
deftraverseTST(root): 
    buffer=[''] *50
    traverseTSTUtil(root, buffer, 0) 
 
 
defsearchTST(root, word): 
    ifnotroot: 
        returnFalse
    ifword[0] < root.data: 
        returnsearchTST(root.left, word) 
    elifword[0] > root.data: 
        returnsearchTST(root.right, word) 
    else: 
        iflen(word) > 1: 
            returnsearchTST(root.eq, word[1:]) 
        else: 
            returnroot.isEndOfString 
 
 
root =Node('') 
insert(root, ""cat"") 
insert(root, ""cats"") 
insert(root, ""up"") 
insert(root, ""bug"") 
 
print(""Following is traversal of ternary search tree:"") 
traverseTST(root) 
 
print(""\nFollowing are search results for 'cats', 'bu', and 'up':"") 
print(""Found""ifsearchTST(root, ""cats"") else""Not Found"") 
print(""Found""ifsearchTST(root, ""bu"") else""Not Found"") 
print(""Found""ifsearchTST(root, ""up"") else""Not Found"") 
# This code is contributed by Shivam Tiwari 
",O(height),O(n)
"# Python3 program to solve Knight Tour problem using Backtracking 
 
# Chessboard Size 
n =8
 
 
defisSafe(x, y, board): 
    ''' 
        A utility function to check if i,j are valid indexes  
        for N*N chessboard 
    '''
    if(x >=0andy >=0andx < n andy < n andboard[x][y] ==-1): 
        returnTrue
    returnFalse
 
 
defprintSolution(n, board): 
    ''' 
        A utility function to print Chessboard matrix 
    '''
    fori inrange(n): 
        forj inrange(n): 
            print(board[i][j], end=' ') 
        print() 
 
 
defsolveKT(n): 
    ''' 
        This function solves the Knight Tour problem using  
        Backtracking. This function mainly uses solveKTUtil()  
        to solve the problem. It returns false if no complete  
        tour is possible, otherwise return true and prints the  
        tour.  
        Please note that there may be more than one solutions,  
        this function prints one of the feasible solutions. 
    '''
 
    # Initialization of Board matrix 
    board =[[-1fori inrange(n)]fori inrange(n)] 
 
    # move_x and move_y define next move of Knight. 
    # move_x is for next value of x coordinate 
    # move_y is for next value of y coordinate 
    move_x =[2, 1, -1, -2, -2, -1, 1, 2] 
    move_y =[1, 2, 2, 1, -1, -2, -2, -1] 
 
    # Since the Knight is initially at the first block 
    board[0][0] =0
 
    # Step counter for knight's position 
    pos =1
 
    # Checking if solution exists or not 
    if(notsolveKTUtil(n, board, 0, 0, move_x, move_y, pos)): 
        print(""Solution does not exist"") 
    else: 
        printSolution(n, board) 
 
 
defsolveKTUtil(n, board, curr_x, curr_y, move_x, move_y, pos): 
    ''' 
        A recursive utility function to solve Knight Tour  
        problem 
    '''
 
    if(pos ==n**2): 
        returnTrue
 
    # Try all next moves from the current coordinate x, y 
    fori inrange(8): 
        new_x =curr_x +move_x[i] 
        new_y =curr_y +move_y[i] 
        if(isSafe(new_x, new_y, board)): 
            board[new_x][new_y] =pos 
            if(solveKTUtil(n, board, new_x, new_y, move_x, move_y, pos+1)): 
                returnTrue
 
            # Backtracking 
            board[new_x][new_y] =-1
    returnFalse
 
 
# Driver Code 
if__name__ ==""__main__"": 
     
    # Function Call 
    solveKT(n) 
 
# This code is contributed by AAKASH PAL 
",O(8N^2),O(N2)
"# Python3 program for brute force method to calculate stock span values

# Fills list S[] with span values


defcalculateSpan(price, n, S):

    # Span value of first day is always 1
    S[0] =1

    # Calculate span value of remaining days by linearly
    # checking previous days
    fori inrange(1, n, 1):
        S[i] =1# Initialize span value

        # Traverse left while the next element on left is
        # smaller than price[i]
        j =i -1
        while(j >=0) and(price[i] >=price[j]):
            S[i] +=1
            j -=1

# A utility function to print elements of array


defprintArray(arr, n):

    fori inrange(n):
        print(arr[i], end="" "")


# Driver program to test above function
price =[10, 4, 5, 90, 120, 80]
n =len(price)
S =[None] *n

# Fill the span values in list S[]
calculateSpan(price, n, S)

# print the calculated span values
printArray(S, n)


# This code is contributed by Sunny Karira
",O(N2),O(N)
"# Python linear time solution for stock span problem

# A stack based efficient method to calculate s


defcalculateSpan(price, S):

    n =len(price)
    # Create a stack and push index of first element to it
    st =[]
    st.append(0)

    # Span value of first element is always 1
    S[0] =1

    # Calculate span values for rest of the elements
    fori inrange(1, n):

        # Pop elements from stack while stack is not
        # empty and top of stack is smaller than price[i]
        while(len(st) > 0andprice[st[-1]] <=price[i]):
            st.pop()

        # If stack becomes empty, then price[i] is greater
        # than all elements on left of it, i.e. price[0],
        # price[1], ..price[i-1]. Else the price[i] is
        # greater than elements after top of stack
        S[i] =i +1iflen(st) ==0else(i -st[-1])

        # Push this element to stack
        st.append(i)


# A utility function to print elements of array
defprintArray(arr, n):
    fori inrange(0, n):
        print(arr[i], end="" "")


# Driver program to test above function
price =[10, 4, 5, 90, 120, 80]
S =[0fori inrange(len(price)+1)]

# Fill the span values in array S[]
calculateSpan(price, S)

# Print the calculated span values
printArray(S, len(price))

# This code is contributed by Nikhil Kumar Singh (nickzuck_007)
",O(N),O(N)
"# Python3 program for a linear time
# solution for stock span problem
# without using stack

# An efficient method to calculate
# stock span values implementing
# the same idea without using stack


defcalculateSpan(A, n, ans):

    # Span value of first element
    # is always 1
    ans[0] =1

    # Calculate span values for rest
    # of the elements
    fori inrange(1, n):
        counter =1

        while((i -counter) >=0and
               A[i] >=A[i -counter]):
            counter +=ans[i -counter]
        ans[i] =counter

# A utility function to print elements
# of array


defprintArray(arr, n):

    fori inrange(n):
        print(arr[i], end=' ')
    print()


# Driver code
price =[10, 4, 5, 90, 120, 80]
n =len(price)
S =[0] *(n)

# Fill the span values in array S[]
calculateSpan(price, n, S)

# Print the calculated span values
printArray(S, n)

# This code is contributed by Prateek Gupta
",O(N),O(N)
"# Python3 program for a linear time
# solution for stock span problem
# using stack


defcalculateSpan(a, n):
    s =[]
    ans =[]
    fori inrange(0, n):

        while(s !=[] anda[s[-1]] <=a[i]):
            s.pop()

        if(s ==[]):
            ans.append(i+1)

        else:
            top =s[-1]
            ans.append(i -top)

        s.append(i)

    returnans

# A utility function to print elements
# of array


defprintArray(arr, n):

    fori inrange(n):
        print(arr[i], end=' ')
    print()


# Driver code
price =[10, 4, 5, 90, 120, 80]
n =len(price)
ans =calculateSpan(price, n)

# Print the calculated span values
printArray(ans, n)

# This code is contributed by Arpit Jain
",O(N),O(N)
"# Python program to print topological sorting of a DAG
fromcollections importdefaultdict

# Class to represent a graph


classGraph:
    def__init__(self, vertices):
        self.graph =defaultdict(list)  # dictionary containing adjacency List
        self.V =vertices  # No. of vertices

    # function to add an edge to graph
    defaddEdge(self, u, v):
        self.graph[u].append(v)

    # A recursive function used by topologicalSort
    deftopologicalSortUtil(self, v, visited, stack):

        # Mark the current node as visited.
        visited[v] =True

        # Recur for all the vertices adjacent to this vertex
        fori inself.graph[v]:
            ifvisited[i] ==False:
                self.topologicalSortUtil(i, visited, stack)

        # Push current vertex to stack which stores result
        stack.append(v)

    # The function to do Topological Sort. It uses recursive
    # topologicalSortUtil()
    deftopologicalSort(self):
        # Mark all the vertices as not visited
        visited =[False]*self.V
        stack =[]

        # Call the recursive helper function to store Topological
        # Sort starting from all vertices one by one
        fori inrange(self.V):
            ifvisited[i] ==False:
                self.topologicalSortUtil(i, visited, stack)

        # Print contents of the stack
        print(stack[::-1])  # return list in reverse order


# Driver Code
if__name__ =='__main__':
    g =Graph(6)
    g.addEdge(5, 2)
    g.addEdge(5, 0)
    g.addEdge(4, 0)
    g.addEdge(4, 1)
    g.addEdge(2, 3)
    g.addEdge(3, 1)

    print(""Following is a Topological Sort of the given graph"")

    # Function Call
    g.topologicalSort()

# This code is contributed by Neelam Yadav
",O(V+E),O(V)
"# See https:#www.geeksforgeeks.org/program-nth-catalan-number/ 
# for reference of below code. 

# A function to find factorial of a given number 
deffactorial(n) :
    res =1
    
    # Calculate value of [1*(2)*---*
    #(n-k+1)] / [k*(k-1)*---*1] 
    fori inrange(1, n +1): 
        res *=i 
    returnres 

defbinomialCoeff(n, k): 

    res =1

    # Since C(n, k) = C(n, n-k) 
    if(k > n -k): 
        k =n -k 

    # Calculate value of [n*(n-1)*---*(n-k+1)] / 
    # [k*(k-1)*---*1] 
    fori inrange(k): 
    
        res *=(n -i) 
        res //=(i +1) 
    
    returnres 

# A Binomial coefficient based function to 
# find nth catalan number in O(n) time 
defcatalan(n):

    # Calculate value of 2nCn 
    c =binomialCoeff(2*n, n) 

    # return 2nCn/(n+1) 
    returnc //(n +1) 

# A function to count number of BST 
# with n nodes using catalan 
defcountBST(n):

    # find nth catalan number 
    count =catalan(n) 

    # return nth catalan number 
    returncount 

# A function to count number of binary 
# trees with n nodes 
defcountBT(n):

    # find count of BST with n numbers 
    count =catalan(n) 

    # return count * n! 
    returncount *factorial(n) 

# Driver Code 
if__name__ =='__main__':

    n =5

    # find count of BST and binary
    # trees with n nodes 
    count1 =countBST(n) 
    count2 =countBT(n) 

    # print count of BST and binary trees with n nodes 
    print(""Count of BST with"", n, ""nodes is"", count1) 
    print(""Count of binary trees with"", n, 
                       ""nodes is"", count2)

# This code is contributed by
# Shubham Singh(SHUBHAMSINGH10)
",O(n),O(1)
"# Function to print nodes in a given Circular linked list
defprintList(self):

    temp =self.head

    # If linked list is not empty
    ifself.head isnotNone:
        while(True):

            # Print nodes till we reach first node again
            print(temp.data, end="" "")
            temp =temp.next
            if(temp ==self.head):
                break
",O(n),O(1)
"# Python program to demonstrate 
# circular linked list traversal 

# Structure for a Node
classNode:
    
    # Constructor to create  a new node
    def__init__(self, data):
        self.data =data 
        self.next=None

classCircularLinkedList:
    
    # Constructor to create a empty circular linked list
    def__init__(self):
        self.head =None

    # Function to insert a node at the beginning of a
    # circular linked list
    defpush(self, data):
        ptr1 =Node(data)
        temp =self.head
        
        ptr1.next=self.head

        # If linked list is not None then set the next of
        # last node
        ifself.head isnotNone:
            while(temp.next!=self.head):
                temp =temp.next
            temp.next=ptr1

        else:
            ptr1.next=ptr1 # For the first node

        self.head =ptr1 

    # Function to print nodes in a given circular linked list
    defprintList(self):
        temp =self.head
        ifself.head isnotNone:
            while(True):
                print(temp.data, end="" "")
                temp =temp.next
                if(temp ==self.head):
                    break


# Driver program to test above function

# Initialize list as empty
cllist =CircularLinkedList()

# Created linked list will be 11->2->56->12
cllist.push(12)
cllist.push(56)
cllist.push(2)
cllist.push(11)

print(""Contents of circular Linked List"")
cllist.printList()
         
",O(n),O(1)
"classNode(object):
    def__init__(self, data):
        self.data =data
        self.next=None


classCircularLinkedList:
    def__init__(self):
        self.head =None

    defpush(self, data, temp=None):
        ifself.head ==None:
            node =Node(data)
            self.head =node
            node.next=self.head
            return

        iftemp ==None:
            temp =self.head

        iftemp.next==self.head:
            node =Node(data)
            node.next=self.head
            temp.next=node
            return

        self.push(data, temp.next)

    deftraverse(self, temp=None):
        iftemp ==None:
            temp =self.head

        iftemp.next==self.head:
            print(temp.data, end=""\n"")
            return
        print(temp.data, end=""-->"")
        self.traverse(temp.next)


if__name__ ==""__main__"":
    clist =CircularLinkedList()
    clist.push(2)
    clist.push(3)
    clist.push(7)
    clist.push(5)
    print(""Traversed Circular Linked List: "", end=""\n"")
    clist.traverse()
",O(n),O(1)
"# Python3 program to for tree traversals


# A class that represents an individual node in a
# Binary Tree
classNode:
    def__init__(self, key):
        self.left =None
        self.right =None
        self.val =key


# A function to do inorder tree traversal
defprintInorder(root):

    ifroot:

        # First recur on left child
        printInorder(root.left)

        # Then print the data of node
        print(root.val, end="" ""),

        # Now recur on right child
        printInorder(root.right)


# Driver code
if__name__ ==""__main__"":
    root =Node(1)
    root.left =Node(2)
    root.right =Node(3)
    root.left.left =Node(4)
    root.left.right =Node(5)

    # Function call
    print(""Inorder traversal of binary tree is"")
    printInorder(root)
",O(N),O(h)
"# Python3 program to for tree traversals


# A class that represents an individual node
# in a Binary Tree
classNode:
    def__init__(self, key):
        self.left =None
        self.right =None
        self.val =key


# A function to do preorder tree traversal
defprintPreorder(root):

    ifroot:

        # First print the data of node
        print(root.val, end="" ""),

        # Then recur on left child
        printPreorder(root.left)

        # Finally recur on right child
        printPreorder(root.right)


# Driver code
if__name__ ==""__main__"":
    root =Node(1)
    root.left =Node(2)
    root.right =Node(3)
    root.left.left =Node(4)
    root.left.right =Node(5)

    # Function call
    print(""Preorder traversal of binary tree is"")
    printPreorder(root)
",O(N),O(h)
"# Python3 program to for tree traversals


# A class that represents an individual node
# in a Binary Tree
classNode:
    def__init__(self, key):
        self.left =None
        self.right =None
        self.val =key


# A function to do postorder tree traversal
defprintPostorder(root):

    ifroot:

        # First recur on left child
        printPostorder(root.left)

        # The recur on right child
        printPostorder(root.right)

        # Now print the data of node
        print(root.val, end="" ""),


# Driver code
if__name__ ==""__main__"":
    root =Node(1)
    root.left =Node(2)
    root.right =Node(3)
    root.left.left =Node(4)
    root.left.right =Node(5)

    # Function call
    print(""Postorder traversal of binary tree is"")
    printPostorder(root)
",O(N),O(N)
"classTrieNode:
    def__init__(self):
        self.children =[None] *26
        self.isEndOfWord =False

defgetNode():
    pNode =TrieNode()
    pNode.isEndOfWord =False
    returnpNode

definsert(root, key):
    pCrawl =root
    fori inrange(len(key)):
        index =ord(key[i]) -ord('a')
        ifnotpCrawl.children[index]:
            pCrawl.children[index] =getNode()
        pCrawl =pCrawl.children[index]
    pCrawl.isEndOfWord =True

defsearch(root, key):
    pCrawl =root
    fori inrange(len(key)):
        index =ord(key[i]) -ord('a')
        ifnotpCrawl.children[index]:
            returnFalse
        pCrawl =pCrawl.children[index]
    returnpCrawl andpCrawl.isEndOfWord

defisEmpty(root):
    fori inrange(26):
        ifroot.children[i]:
            returnFalse
    returnTrue

defremove(root, key, depth =0):
    ifnotroot:
        returnNone

    ifdepth ==len(key):
        ifroot.isEndOfWord:
            root.isEndOfWord =False
        ifisEmpty(root):
            delroot
            root =None
        returnroot

    index =ord(key[depth]) -ord('a')
    root.children[index] =remove(root.children[index], key, depth +1)

    ifisEmpty(root) andnotroot.isEndOfWord:
        delroot
        root =None
    returnroot

if__name__ =='__main__':
    keys =[""the"", ""a"", ""there"", ""answer"", ""any"", ""by"", ""bye"", ""their"", ""hero"", ""heroplane""]
    root =getNode()
    fori inrange(len(keys)):
        insert(root, keys[i])
    ifsearch(root, ""the""):
        print(""Yes"")
    else:
        print(""No"")
    ifsearch(root, ""these""):
        print(""Yes"")
    else:
        print(""No"")
    root =remove(root, ""heroplane"")
    ifsearch(root, ""hero""):
        print(""Yes"")
    else:
        print(""No"")
",O(n),O(n*m)
"# unsets the rightmost set bit
# of n and returns the result 
deffun(n):

     returnn & (n-1)

# Driver code

n =7
print(""The number after unsetting the rightmost set bit"", fun(n))

# This code is contributed
# by Anant Agarwal.
",O(1),O(1)
"# Python3 program to implement the approach

# unsets the rightmost set bit
# of n and returns the result
deffun(n):
    returnn -(n & (-n))

# Driver Code
n =7
print(""The number after unsetting the rightmost set bit:"", fun(n))

# This code is contributed by phasing17
",O(1),O(1)
"'''Python3  program to implement 2D Binary Indexed Tree 
  
2D BIT is basically a BIT where each element is another BIT. 
Updating by adding v on (x, y) means it's effect will be found 
throughout the rectangle [(x, y), (max_x, max_y)], 
and query for (x, y) gives you the result of the rectangle 
[(0, 0), (x, y)], assuming the total rectangle is 
[(0, 0), (max_x, max_y)]. So when you query and update on 
this BIT,you have to be careful about how many times you are 
subtracting a rectangle and adding it. Simple set union formula 
works here. 
  
So if you want to get the result of a specific rectangle 
[(x1, y1), (x2, y2)], the following steps are necessary: 
  
Query(x1,y1,x2,y2) = getSum(x2, y2)-getSum(x2, y1-1) - 
                    getSum(x1-1, y2)+getSum(x1-1, y1-1) 
  
Here 'Query(x1,y1,x2,y2)' means the sum of elements enclosed 
in the rectangle with bottom-left corner's co-ordinates 
(x1, y1) and top-right corner's co-ordinates - (x2, y2) 
  
Constraints -> x1<=x2 and y1<=y2 
  
    /\ 
y | 
    |     --------(x2,y2) 
    |     | | 
    |     | | 
    |     | | 
    |     --------- 
    | (x1,y1) 
    | 
    |___________________________ 
(0, 0)             x--> 
  
In this program we have assumed a square matrix. The 
program can be easily extended to a rectangular one. '''

N =4# N-.max_x and max_y 

# A structure to hold the queries 
classQuery:

    def__init__(self, x1,y1,x2,y2):
    
        self.x1 =x1;
        self.y1 =y1;
        self.x2 =x2;
        self.y2 =y2;


# A function to update the 2D BIT 
defupdateBIT(BIT,x,y,val):
    
    whilex <=N:
    
        # This loop update all the 1D BIT inside the 
        # array of 1D BIT = BIT[x] 
        whiley <=N:
            BIT[x][y] +=val;
            y +=(y & -y)
        
        x +=(x & -x)
    
    return; 


# A function to get sum from (0, 0) to (x, y) 
defgetSum(BIT,x,y):

    sum=0; 
    
    whilex > 0:
        # This loop sum through all the 1D BIT 
        # inside the array of 1D BIT = BIT[x] 
        whiley > 0:

            sum+=BIT[x][y]; 
            y -=y&-y
        
        x -=x&-x
    
    returnsum; 


# A function to create an auxiliary matrix 
# from the given input matrix 
defconstructAux(mat,aux):
    # Initialise Auxiliary array to 0 
    fori inrange(N +1):
        forj inrange(N +1):
            aux[i][j] =0
  
    # Construct the Auxiliary Matrix 
    forj inrange(1, N +1):
        fori inrange(1, N +1):
            aux[i][j] =mat[N -j][i -1];
  
    return


# A function to construct a 2D BIT 
defconstruct2DBIT(mat,BIT):
    # Create an auxiliary matrix 
    aux =[Nonefori inrange(N +1)]
    fori inrange(N +1) : 
    
        aux[i]=[Nonefori inrange(N +1)]
    
    constructAux(mat, aux)
  
    # Initialise the BIT to 0 
    fori inrange(1, N +1): 
        forj inrange(1, N +1): 
            BIT[i][j] =0; 
  
    forj inrange(1, N +1): 
    
        fori inrange(1, N +1): 
        
            # Creating a 2D-BIT using update function 
            # everytime we/ encounter a value in the 
            # input 2D-array 
            v1 =getSum(BIT, i, j); 
            v2 =getSum(BIT, i, j -1); 
            v3 =getSum(BIT, i -1, j -1); 
            v4 =getSum(BIT, i -1, j); 
  
            # Assigning a value to a particular element 
            # of 2D BIT 
            updateBIT(BIT, i, j, aux[i][j] -
                     (v1 -v2 -v4 +v3)); 
        
    
    return; 


# A function to answer the queries 
defanswerQueries(q,m,BIT):
    
    fori inrange(m):
     
        x1 =q[i].x1 +1; 
        y1 =q[i].y1 +1; 
        x2 =q[i].x2 +1; 
        y2 =q[i].y2 +1; 
  
        ans =getSum(BIT, x2, y2) -\
                  getSum(BIT, x2, y1 -1) -\
                  getSum(BIT, x1 -1, y2) +\
                  getSum(BIT, x1 -1, y1 -1); 
  
        print(""Query ("", q[i].x1, "", "", q[i].y1, "", "", q[i].x2, "", "", q[i].y2, "") = "",ans, sep ="""") 
    
    return; 


# Driver Code
mat=[[1, 2, 3, 4], 
                    [5, 3, 8, 1], 
                    [4, 6, 7, 5], 
                    [2, 4, 8, 9]]; 
  
# Create a 2D Binary Indexed Tree 
BIT =[Nonefori inrange(N +1)]
fori inrange(N +1):

    BIT[i]=[Nonefori inrange(N +1)]
    forj inrange(N +1):
            BIT[i][j]=0
        
    
construct2DBIT(mat, BIT); 
  
''' Queries of the form - x1, y1, x2, y2 
    For example the query- {1, 1, 3, 2} means the sub-matrix- 
        y 
        /\ 
    3 | 1 2 3 4     Sub-matrix 
    2 | 5 3 8 1     {1,1,3,2} --.     3 8 1 
    1 | 4 6 7 5                                 6 7 5 
    0 | 2 4 8 9 
        | 
    --|------ 0 1 2 3 ---. x 
        | 
      
        Hence sum of the sub-matrix = 3+8+1+6+7+5 = 30 
    
    '''
q =[Query(1, 1, 3, 2), Query(2, 3, 3, 3), Query(1, 1, 1, 1)]; 
m =len(q)
  
answerQueries(q, m, BIT); 

# This code is contributed by phasing17
",O(1),O(NM)
"# Python program to find union and
# intersection of two unsorted
# linked lists

# Linked list Node
classNode:
    def__init__(self, data):
        self.data =data
        self.next=None

classLinkedList:
    def__init__(self):
        self.head =None

    # Function to get Union of 2 Linked Lists
    defgetUnion(self, head1, head2):
        t1 =head1
        t2 =head2

        # insert all elements of list1 in the result
        whilet1 isnotNone:
            self.push(t1.data)
            t1 =t1.next

        # insert those elements of list2
        # that are not present
        whilet2 isnotNone:
            ifnotself.isPresent(self.head, t2.data):
                self.push(t2.data)
            t2 =t2.next

    defgetIntersection(self, head1, head2):
        t1 =head1

        # Traverse list1 and search each
        # element of it in list2.
        # If the element is present in
        # list 2, then insert the
        # element to result
        whilet1 isnotNone:
            ifself.isPresent(head2, t1.data):
                self.push(t1.data)
            t1 =t1.next

    # Utility function to print list
    defprintList(self):
        temp =self.head
        whiletemp isnotNone:
            print(temp.data, end="" "")
            temp =temp.next
        print("""")

    # Inserts a node at start of linked list
    defpush(self, new_data):
        new_node =Node(new_data)

        # Make next of new Node as head
        new_node.next=self.head

        # Move the head to point to new Node
        self.head =new_node

    # A utility function that returns true
    # if data is present in linked list
    # else return false
    defisPresent(self, head, data):
        t =head
        whilet isnotNone:
            ift.data ==data:
                returnTrue
            t =t.next
        returnFalse

# Driver program to test above functions
if__name__ =='__main__':
    llist1 =LinkedList()
    llist2 =LinkedList()
    unin =LinkedList()
    intersecn =LinkedList()

    # create a linked lists 10->15->4->20
    llist1.push(20)
    llist1.push(4)
    llist1.push(15)
    llist1.push(10)

    # create a linked lists 8->4->2->10
    llist2.push(10)
    llist2.push(2)
    llist2.push(4)
    llist2.push(8)

    intersecn.getIntersection(llist1.head, llist2.head)
    unin.getUnion(llist1.head, llist2.head)

    print(""First List is"")
    llist1.printList()
    
    print(""Second List is"")
    llist2.printList()
    
    print(""Intersection List is "")
    intersecn.printList()
    
    print(""Union List is "")
    unin.printList()
    
# This code is contributed by lokesh.
",O(m*n),O(1)
"defmerge(ll1,ll2):
    ifll1 isNone:
        returnll2
    ifll2 isNone:
        returnll1
    ifll1.data==ll2.data:
        head=ll1
        tail=ll1
        ll1=ll1.next
        ll2=ll2.next
    elifll1.data>ll2.data:
        head=ll2
        tail=ll2
        ll2=ll2.next
    else:
        head=ll1
        tail=ll1
        ll1=ll1.next
    whilell1 isnotNoneandll2 isnotNone:
        ifll1.data==ll2.data:
            tail.next=ll1
            tail=ll1
            ll1=ll1.next
            ll2=ll2.next
        elifll1.data>ll2.data:
            tail.next=ll2
            tail=ll2
            ll2=ll2.next
        else:
            tail.next=ll1
            tail=ll1
            ll1=ll1.next
    ifll1 isnotNone:
        tail.next=ll1
        
    
    ifll2 isnotNone:
        tail.next=ll2
        

    returnhead

defmid_point_2(head):
    ifhead isNone:
        returnNone
    slow=head
    fast=head
    whilefast.nextisnotNoneandfast.next.nextisnotNone:
        slow=slow.next
        fast=fast.next.next
    returnslow 
    
defmerge_sort(head):
    ifhead isNoneorhead.nextisNone:
        returnhead
    mid=mid_point_2(head)
    head2=merge_sort(mid.next)
    mid.next=None
    head1=merge_sort(head)
    final_head=merge(head1,head2)
    returnfinal_head
    


defunion(head1,head2):
    # code here
    # return head of resultant linkedlist
    
    head1=merge_sort(head1)
    head2=merge_sort(head2)
    returnmerge(head1,head2)
    
    
    


 # Driver Code Starts
#Initial Template for Python 3

classNode:
    def__init__(self,data):
        self.data=data
        self.next=None
        
defprint_ll(head):
    whilehead isnotNone:
        print(head.data,end='-->')
        head=head.next
    print('None')
    
deftake_input(l):
    
    iflen(l)==0orl[0]==-1:
        return
    head,tail=None,None
    fori inl:
        ifi ==-1:
            break
        new_node=Node(i)
        ifhead isNone:
            head=new_node
            tail=new_node
        else:
            tail.next=new_node
            tail=new_node
    returnhead

head1=take_input([10,20,30,40,50,60,70])
head2=take_input([10,30,50,80,90])
print_ll(union(head1,head2))



     

# This code is contributed by Shubham Setia
",O(m+n),O(m+n)
"classLinkedList:
    classNode:
        def__init__(self, data):
            self.data =data
            self.next=None
    
    def__init__(self):
        self.head =None# head of list
    
    # Utility function to print list
    defprintList(self):
        temp =self.head
        whiletemp:
            print(temp.data, end="" "")
            temp =temp.next
        print()
    
    # Inserts a node at start of linked list
    defpush(self, new_data):
        new_node =self.Node(new_data)
        new_node.next=self.head
        self.head =new_node
    
    defappend(self, new_data):
        ifnotself.head:
            n =self.Node(new_data)
            self.head =n
            return
        n1 =self.head
        n2 =self.Node(new_data)
        whilen1.next:
            n1 =n1.next
        n1.next=n2
        n2.next=None
    
    # A utility function that returns true if data is
    # present in linked list else return false
    defisPresent(self, head, data):
        t =head
        whilet:
            ift.data ==data:
                returnTrue
            t =t.next
        returnFalse
    
    defgetIntersection(self, head1, head2):
        hset =set()
        n1 =head1
        n2 =head2
        result =LinkedList()
        
        # loop stores all the elements of list1 in hset
        whilen1:
            ifn1.data notinhset:
                hset.add(n1.data)
            n1 =n1.next
        
        whilen2:
            ifn2.data inhset:
                result.push(n2.data)
            n2 =n2.next
        returnresult
    
    defgetUnion(self, head1, head2):
        hmap ={}
        n1 =head1
        n2 =head2
        result =LinkedList()
        
        # loop inserts the elements and the count of
        # that element of list1 into the hmap
        whilen1:
            ifn1.data inhmap:
                hmap[n1.data] +=1
            else:
                hmap[n1.data] =1
            n1 =n1.next
        
        # loop further adds the elements of list2 with
        # their counts into the hmap
        whilen2:
            ifn2.data inhmap:
                hmap[n2.data] +=1
            else:
                hmap[n2.data] =1
            n2 =n2.next
        
        list1 =[]
        forkey, value inhmap.items():
            # for _ in range(value):
            list1.append(key)
        list1 =set(list1)
        fori inlist1:
            result.append(i)
        returnresult

# Driver program to test above functions
llist1 =LinkedList()
llist2 =LinkedList()
intersection =LinkedList()
union_list =LinkedList()

# create a linked list 10->15->4->20
llist1.push(20)
llist1.push(4)
llist1.push(15)
llist1.push(10)

# create a linked list 8->4->2->10 
llist2.push(10)
llist2.push(2)
llist2.push(4)
llist2.push(8)

intersection =intersection.getIntersection(
               llist1.head, llist2.head)
union_list =union_list.getUnion(
             llist1.head, llist2.head)

print(""First List is"")
llist1.printList()

print(""Second List is"")
llist2.printList()

print(""Intersection List is"")
intersection.printList()

print(""Union List is"")
union_list.printList()
",O(m+n),O(m+n)
"# Python3 program to implement unrolled 
# linked list and traversing it.  
maxElements =4
 
# Unrolled Linked List Node  
classNode: 
     
    def__init__(self): 
         
        self.numElements =0
        self.array =[0fori inrange(maxElements)]  
        self.next=None
 
# Function to traverse an unrolled linked list  
# and print all the elements 
defprintUnrolledList(n): 
 
    while(n !=None): 
 
        # Print elements in current node  
        fori inrange(n.numElements): 
            print(n.array[i], end =' ') 
 
        # Move to next node  
        n =n.next
 
# Driver Code 
if__name__=='__main__': 
     
    head =None
    second =None
    third =None
 
    # Allocate 3 Nodes  
    head =Node() 
    second =Node() 
    third =Node() 
 
    # Let us put some values in second 
    # node (Number of values must be  
    # less than or equal to  
    # maxElement)  
    head.numElements =3
    head.array[0] =1
    head.array[1] =2
    head.array[2] =3
 
    # Link first Node with the second Node  
    head.next=second 
 
    # Let us put some values in second node 
    # (Number of values must be less than 
    # or equal to maxElement)  
    second.numElements =3
    second.array[0] =4
    second.array[1] =5
    second.array[2] =6
 
    # Link second Node with the third Node  
    second.next=third  
 
    # Let us put some values in third node 
    # (Number of values must be less than  
    # or equal to maxElement)  
    third.numElements =3
    third.array[0] =7
    third.array[1] =8
    third.array[2] =9
    third.next=None
 
    printUnrolledList(head) 
     
# This code is contributed by rutvik_56
",O(n),O(n)
"# Python3 program for printing vertical order of a given
# binary tree

# A binary tree node


classNode:
    # Constructor to create a new node
    def__init__(self, key):
        self.key =key
        self.left =None
        self.right =None

# Utility function to store vertical order in map 'm'
# 'hd' is horizontal distance of current node from root
# 'hd' is initially passed as 0


defgetVerticalOrder(root, hd, m):

    # Base Case
    ifroot isNone:
        return

    # Store current node in map 'm'
    try:
        m[hd].append(root.key)
    except:
        m[hd] =[root.key]

    # Store nodes in left subtree
    getVerticalOrder(root.left, hd-1, m)

    # Store nodes in right subtree
    getVerticalOrder(root.right, hd+1, m)

# The main function to print vertical order of a binary
# tree ith given root


defprintVerticalOrder(root):

    # Create a map and store vertical order in map using
    # function getVerticalORder()
    m =dict()
    hd =0
    getVerticalOrder(root, hd, m)

    # Traverse the map and print nodes at every horizontal
    # distance (hd)
    forindex, value inenumerate(sorted(m)):
        fori inm[value]:
            print(i, end="" "")
        print()


# Driver program to test above function
if__name__ =='__main__':
    root =Node(1)
    root.left =Node(2)
    root.right =Node(3)
    root.left.left =Node(4)
    root.left.right =Node(5)
    root.right.left =Node(6)
    root.right.right =Node(7)
    root.right.left.right =Node(8)
    root.right.right.right =Node(9)
    print(""Vertical order traversal is"")
    printVerticalOrder(root)

# This code is contributed by Nikhil Kumar Singh(nickzuck_007)
",O(N log N),O(N)
"importsys

# Python program for printing
# vertical order of a given binary
# tree


classNode:
    def__init__(self, data):
        self.data =data
        self.left =None
        self.right =None

# Store vertical order
# in map ""m"", hd = horizontal
# distance, vd = vertical distance


defpreOrderTraversal(root, hd, vd, m):
    ifnotroot:
        return
    # key = horizontal
    # distance (30 bits) + vertical
    # distance (30 bits) map
    # will store key in sorted
    # order. Thus nodes having same
    # horizontal distance
    # will sort according to
    # vertical distance.
    val =hd << 30| vd

    # insert in map
    ifval inm:
        m[val].append(root.data)
    else:
        m[val] =[root.data]
    preOrderTraversal(root.left, hd-1, vd+1, m)
    preOrderTraversal(root.right, hd+1, vd+1, m)


defverticalOrder(root):

    mp =dict()

    preOrderTraversal(root, 0, 0, mp)

    # print dictionary
    prekey =sys.maxsize

    fori insorted(mp.keys()):
        if(prekey !=sys.maxsize) and(i >> 30!=prekey):
            print()
        prekey =i >> 30
        forj inmp[i]:
            print(j, end="" "")


# Driver code
root =Node(1)
root.left =Node(2)
root.right =Node(3)
root.left.left =Node(4)
root.left.right =Node(5)
root.right.left =Node(6)
root.right.right =Node(7)
root.right.left.right =Node(8)
root.right.right.right =Node(9)
print(""Vertical order traversal :- "")
verticalOrder(root)

# This code is contributed by prashantchandelme.
",O(N Log N),O(N)
"classNode:
    def__init__(self, item):
        self.data =item
        self.left =None
        self.right =None


classBinaryTree:
    def__init__(self):
        self.root =None

    classValues:
        def__init__(self):
            self.max=float('-inf')
            self.min=float('inf')

    defverticalOrder(self, node):
        val =self.Values()

        # Create dictionary to store vertical order
        mp ={}

        # Function call to findHorizontalDistance
        self.findHorizontalDistance(node, val, val, 0, mp)

        # Iterate over dictionary values
        forhd, lst insorted(mp.items()):
            forelement inlst:
                print(element, end="" "")
            print()

    deffindHorizontalDistance(self, node, minVal, maxVal, hd, mp):
        # If node is None
        ifnode isNone:
            return

        # if hd is less than min.min
        ifhd < minVal.min:
            minVal.min=hd

        # if hd is greater than min.min
        ifhd > maxVal.max:
            maxVal.max=hd

        # Using setdefault
        mp.setdefault(hd, []).append(node.data)

        # Function Call with hd equal to hd - 1
        self.findHorizontalDistance(node.left, minVal, maxVal, hd -1, mp)

        # Function Call with hd equal to hd + 1
        self.findHorizontalDistance(node.right, minVal, maxVal, hd +1, mp)


if__name__ =='__main__':
    tree =BinaryTree()

    # Let us construct the tree shown in above diagram
    tree.root =Node(1)
    tree.root.left =Node(2)
    tree.root.right =Node(3)
    tree.root.left.left =Node(4)
    tree.root.left.right =Node(5)
    tree.root.right.left =Node(6)
    tree.root.right.right =Node(7)
    tree.root.right.left.right =Node(8)
    tree.root.right.right.right =Node(9)

    print(""Vertical order traversal is:\n"")

    # Function Call
    tree.verticalOrder(tree.root)
",O(N Log N),O(N)
"# Python program for printing vertical order of a given binary tree using BFS

# Structure for a binary tree node
classNode:
    def__init__(self, key):
        self.key =key
        self.left =None
        self.right =None

# A function to create a new node
defnewNode(key):
    node =Node(key)
    returnnode

# The main function to print vertical
# order of a binary tree with given root
defprintVerticalOrder(root):
    # Base case
    ifnotroot:
        return

    # Create a dictionary and store vertical
    # order in dictionary using
    # function getVerticalOrder()
    m ={}
    hd =0

    # Create queue to do level order
    # traversal Every item of queue contains
    # node and horizontal distance
    q =[]
    q.append((root, hd))

    # mn and mx contain the minimum and
    # maximum horizontal distance from root
    mn, mx =0, 0
    whileq:
        # pop from queue front
        temp =q.pop(0)
        hd =temp[1]
        node =temp[0]

        # insert this node's data
        # in vector of hash
        ifhd inm:
            m[hd].append(node.key)
        else:
            m[hd] =[node.key]

        ifnode.left:
            q.append((node.left, hd -1))
        ifnode.right:
            q.append((node.right, hd +1))

        # Update mn and mx
        ifmn > hd:
            mn =hd
        elifmx < hd:
            mx =hd

    # run the loop from minimum to maximum
    # every horizontal distance hd
    fori inrange(mn, mx+1):
        ifi inm:
            tmp =m[i]
            forj inrange(len(tmp)):
                print(tmp[j], end=' ')
            print()

# Driver code
if__name__ =='__main__':
    root =newNode(1)
    root.left =newNode(2)
    root.right =newNode(3)
    root.left.left =newNode(4)
    root.left.right =newNode(5)
    root.right.left =newNode(6)
    root.right.right =newNode(7)
    root.right.left.right =newNode(8)
    root.right.right.right =newNode(9)
    print(""Vertical order traversal is"")
    printVerticalOrder(root)
",O(N),O(N)
"# Python3 program for the above approach
defpower(x, n):

    # If x^0 return 1
    if(n ==0):
        return1

    # If we need to find of 0^y
    if(x ==0):
        return0

    # For all other cases
    returnx *power(x, n -1)


# Driver Code
if__name__ ==""__main__"":
    x =2
    n =3

    # Function call
    print(power(x, n))

# This code is contributed by shivani.
",O(n),O(1)
"# Python3 program for the above approach
defpower(x, n):

    # If x^0 return 1
    if(n ==0):
        return1

    # If we need to find of 0^y
    if(x ==0):
        return0

    # For all other cases
    returnx *power(x, n -1)


# Driver Code
if__name__ ==""__main__"":
    x =2
    n =3

    # Function call
    print(power(x, n))

# This code is contributed by shivani.
",O(n),O(n)
"# Function to calculate x raised to the power y in O(logn)
defpower(x, y):
    temp =0
    if(y ==0):
        return1
    temp =power(x, int(y /2))
    if(y %2==0)
    returntemp *temp
    else
    returnx *temp *temp

# This code is contributed by avanitrachhadiya2155
",O(n),O(n)
"# Function to calculate x raised to the power y in O(logn)
defpower(x, y):
    temp =0
    if(y ==0):
        return1
    temp =power(x, int(y /2))
    if(y %2==0)
    returntemp *temp
    else
    returnx *temp *temp

# This code is contributed by avanitrachhadiya2155
",O(log n),O(log n)
"# Python3 code for extended version
# of power function that can work
# for float x and negative y


defpower(x, y):

    if(y ==0):
        return1
    temp =power(x, int(y /2))

    if(y %2==0):
        returntemp *temp
    else:
        if(y > 0):
            returnx *temp *temp
        else:
            return(temp *temp) /x


# Driver Code
if__name__ ==""__main__"":
    x, y =2, -3

    # Function call
    print('%.6f'%(power(x, y)))

# This code is contributed by Smitha Dinesh Semwal.
",O(log |n|),O(log |n|)
"# Python3 program for the above approach
defpower(x, n):

    # Return type of pow()
    # function is double
    returnpow(x, n)


# Driver Code
if__name__ ==""__main__"":
    x =2
    n =3

    # Function call
    print(power(x, n))

# This code is contributed by susmitakundugoaldanga
",O(log n),O(1)
"# Python3 program for the above approach
defpower(x, n):

    result =1
    while(n > 0):
        if(n %2==0):
            # y is even

            x =x *x
            n =n /2

        else:
            # y isn't even

            result =result *x
            n =n -1

    returnresult


# Driver Code
if__name__ ==""__main__"":
    x =2
    n =3

    # Function call
    print((power(x, n)))

# This code is contributed by shivanisinghss2110
",O(log n),O(1)
"# Python program to illustrate use of ** operator
# to calculate power of a number
defpower(x, n):

    # Calculate the power
    returnx**n


# Driver Code
if__name__ ==""__main__"":
    x =2
    n =3

    # Function call
    print(power(x, n))

# This code is contributed by Susobhan Akhuli
",O(log n),O(1)
"importnumpy as np

N =2
X =3
result =np.power(N, X)
print(result) # Output: 8

#This code is contributed by Susobhan Akhuli
",O(1),O(1)
"importmath

defcalculatePower(a, n):
    returnround(2**(math.log2(a) *n))

# Driver code
if__name__ =='__main__':
    a =2
    n =3
    print(calculatePower(a, n)) # Output: a^n

# This code is contributed by Susobhan Akhuli
",O(1),O(1)
"importmath

defcalculatePower(x, n):
      ans =math.exp(math.log(x) *n)
      ans =round(ans)
      returnans

# Driver code
if__name__ =='__main__':
    x =2
    n =3
    print(calculatePower(x, n)) # Output: x^n

# This code is contributed by Susobhan Akhuli
",O(1),O(1)
"# Python3 program to print all permutations with 
# duplicates allowed 
 
 
deftoString(List): 
    return''.join(List) 
 
# Function to print permutations of string 
# This function takes three parameters: 
# 1. String 
# 2. Starting index of the string 
# 3. Ending index of the string. 
 
 
defpermute(a, l, r): 
    ifl ==r: 
        print(toString(a)) 
    else: 
        fori inrange(l, r): 
            a[l], a[i] =a[i], a[l] 
            permute(a, l+1, r) 
            a[l], a[i] =a[i], a[l]  # backtrack 
 
 
# Driver code 
string =""ABC""
n =len(string) 
a =list(string) 
 
# Function call 
permute(a, 0, n) 
 
# This code is contributed by Bhavya Jain 
",O(N * N!),O(N * N!)
"# Function to get value of a numeral 
# For example it returns 10 for input 'A' 
# 1 for '1', etc 
defgetNumeralValue(num) :

    if( num >='0'andnum <='9') :
        returnord(num) -ord('0')
    if( num >='A'andnum <='D') :
        returnord(num ) -ord('A') +10

# Function to get numeral for a value. 
# For example it returns 'A' for input 10 
# '1' for 1, etc 
defgetNumeral(val): 

    if( val >=0andval <=9):
        returnchr(val +ord('0'))
    if( val >=10andval <=14) :
        returnchr(val +ord('A') -10)

# Function to add two numbers in base 14 
defsumBase14(num1, num2): 

    l1 =len(num1)
    l2 =len(num2) 
    carry =0
        
    if(l1 !=l2) :
    
        print(""Function doesn't support numbers of different""
                "" lengths. If you want to add such numbers then""
                "" prefix smaller number with required no. of zeroes"") 
    
    # Note the size of the allocated memory is one 
    # more than i/p lengths for the cases where we 
    # have carry at the last like adding D1 and A1
    res =[0]*(l1 +1)
            
    # Add all numerals from right to left 
    fori inrange(l1 -1, -1, -1): 
    
        # Get decimal values of the numerals of 
        # i/p numbers 
        nml1 =getNumeralValue(num1[i]) 
        nml2 =getNumeralValue(num2[i]) 
        
        # Add decimal values of numerals and carry 
        res_nml =carry +nml1 +nml2; 
        
        # Check if we have carry for next addition 
        # of numerals 
        if(res_nml >=14) :
            carry =1
            res_nml -=14
        else:
            carry =0
        res[i+1] =getNumeral(res_nml)
        
    # if there is no carry after last iteration 
    # then result should not include 0th character 
    # of the resultant string 
    if(carry ==0):
        return(res +1) 
    
    # if we have carry after last iteration then 
    # result should include 0th character 
    res[0] ='1'
    returnres

# Driver code
if__name__ ==""__main__"":
    
    num1 =""DC2""
    num2 =""0A3""

    print(""Result is "",end="""")
    res =sumBase14(num1, num2)
    fori inrange(len(res)):
        print(res[i],end="""")

# This code is contributed by chitranayal    
",O(|num1|),O(|num1|)
"# Python program to check if n is a multiple of 3

# Function to check if n is a multiple of 3
defisMultipleOf3(n):

    odd_count =0
    even_count =0

    # Make no positive if + n is multiple of 3
    # then is -n. We are doing this to avoid
    # stack overflow in recursion
    if(n < 0): 
        n =-n
    if(n ==0):
        return1
    if(n ==1): 
        return0

    while(n):
        
        # If odd bit is set then
        # increment odd counter 
        if(n & 1): 
            odd_count +=1

        # If even bit is set then
        # increment even counter 
        if(n & 2):
            even_count +=1
        n =n >> 2

    returnisMultipleOf3(abs(odd_count -even_count))

# Program to test function isMultipleOf3 
num =24
if(isMultipleOf3(num)): 
    print(num, 'is multiple of 3')
else:
    print(num, 'is not a multiple of 3')

# This code is contributed by Danish Raza
",O(logn),O(1)
"# Python program to check if n is a multiple of 3
dp =[-1fori inrange(1001)];

''' Function to check if n is a multiple of 3 '''
defisMultipleOf3(n):
    odd_count =0;
    even_count =0;

    # Base Cases
    if(n < 0):
        n =-n;

    if(n ==0):
        return1;

    if(n ==1):
        return0;

    # If a value is already present
    # in dp, return it
    if(dp[n] !=-1):
        returndp[n];

    while(n > 0):
        '''
         * If odd bit is set then increment odd counter
         '''
        if((n & 1) !=0):
            odd_count+=1;

        '''
         * If even bit is set then increment even counter
         '''
        if((n & 2) !=0):
            even_count+=1;
        n =n >> 2;
    
    dp[n] =isMultipleOf3(abs(odd_count -even_count));

    # return dp
    returndp[n];


''' Program to test function isMultipleOf3 '''
if__name__ =='__main__':
    num =24;

    if(isMultipleOf3(num) ==1):
        print(num,""is multiple of 3"");
    else:
        print(num,"" is not a multiple of 3"");

# This code is contributed by Rajput-Ji 
",O(nlogn),O(n)
"# Python3 program to check if given number is multiple of 3 or
# not using modulo division

# input number
num =24
print(num,end="""")

# checking if the given number if multiple of 3 or not
# using modulo division operator if the output of num%3
# is equal to 0 then it is considered as multiple of 3
# otherwise not a multiple of 3
if(num %3is0):
  print("" is multiple of 3"")
else:
  print( "" is not multiple of 3"")

# This code is contributed by akashish__
",O(1),O(1)
"defis_multiple_of_3(num):
    # Calculate digital root
    whilenum > 9:
        num =sum(map(int, str(num)))
    # Check if digital root is 3, 6, or 9
    ifnum %3==0:
        returnTrue
    else:
        returnFalse

print(is_multiple_of_3(123))
print(is_multiple_of_3(789))
",O(log n),O(1)
"# Python3 implementation of Memory
# efficient Doubly Linked List

# library for providing C 
# compatible data types
importctypes

# Node class for memory
# efficient doubly linked list
classNode:
    
    def__init__(self, data):
        
        self.data =data
        
        # XOR of next and previous node
        self.npx =0

classXorLinkedList:
    
    def__init__(self):
        
        self.head =None
        self.__nodes =[]
        
    # Returns XORed value of the node addresses
    defXOR(self, a, b):
        
        returna ^ b
      
    # Insert a node at the beginning of the
    # XORed linked list and makes the newly
    # inserted node as head
    definsert(self, data):
        
        # New node
        node =Node(data)

        # Since new node is being inserted at 
        # the beginning, npx of new node will
        # always be XOR of current head and NULL
        node.npx =id(self.head)

        # If linked list is not empty, then
        # npx of current head node will be 
        # XOR of new node and node next to
        # current head
        ifself.head isnotNone:
            
            # head.npx is XOR of None and next.
            # So if we do XOR of it with None, 
            # we get next
            self.head.npx =self.XOR(id(node), 
                                     self.head.npx)

        self.__nodes.append(node)
        
        # Change head
        self.head =node

    # Prints contents of doubly linked
    # list in forward direction
    defprintList(self):
      
        ifself.head !=None:
            prev_id =0
            curr =self.head
            next_id =1
            
            print(""Following are the nodes ""
                  ""of Linked List:"")
            
            whilecurr isnotNone:
                
                # Print current node
                print(curr.data, end =' ')
                
                # Get address of next node: curr.npx is
                # next^prev, so curr.npx^prev will be
                # next^prev^prev which is next
                next_id =self.XOR(prev_id, curr.npx)
                
                # Update prev and curr for next iteration
                prev_id =id(curr)
                curr =self.__type_cast(next_id)

    # Method to return a new instance of type
    # which points to the same memory block.
    def__type_cast(self, id):
        
        returnctypes.cast(id, ctypes.py_object).value

# Driver code
if__name__ =='__main__':
    
    obj =XorLinkedList()
    
    # Create following Doubly Linked List
    # head-->40<-->30<-->20<-->10
    obj.insert(10)
    obj.insert(20)
    obj.insert(30)
    obj.insert(40)

    # Print the created list
    obj.printList()

# This code is contributed by MuskanKalra1
",O(n),O(1)
"# Python3 program that implements Z algorithm
# for pattern searching

# Fills Z array for given string str[]
defgetZarr(string, z):
    n =len(string)

    # [L,R] make a window which matches
    # with prefix of s
    l, r, k =0, 0, 0
    fori inrange(1, n):

        # if i>R nothing matches so we will calculate.
        # Z[i] using naive way.
        ifi > r:
            l, r =i, i

            # R-L = 0 in starting, so it will start
            # checking from 0'th index. For example,
            # for ""ababab"" and i = 1, the value of R
            # remains 0 and Z[i] becomes 0. For string
            # ""aaaaaa"" and i = 1, Z[i] and R become 5
            whiler < n andstring[r -l] ==string[r]:
                r +=1
            z[i] =r -l
            r -=1
        else:

            # k = i-L so k corresponds to number which
            # matches in [L,R] interval.
            k =i -l

            # if Z[k] is less than remaining interval
            # then Z[i] will be equal to Z[k].
            # For example, str = ""ababab"", i = 3, R = 5
            # and L = 2
            ifz[k] < r -i +1:
                z[i] =z[k]

            # For example str = ""aaaaaa"" and i = 2, 
            # R is 5, L is 0
            else:

                # else start from R and check manually
                l =i
                whiler < n andstring[r -l] ==string[r]:
                    r +=1
                z[i] =r -l
                r -=1

# prints all occurrences of pattern 
# in text using Z algo
defsearch(text, pattern):

    # Create concatenated string ""P$T""
    concat =pattern +""$""+text
    l =len(concat)

    # Construct Z array
    z =[0] *l
    getZarr(concat, z)

    # now looping through Z array for matching condition
    fori inrange(l):

        # if Z[i] (matched region) is equal to pattern
        # length we got the pattern
        ifz[i] ==len(pattern):
            print(""Pattern found at index"", 
                      i -len(pattern) -1)

# Driver Code
if__name__ ==""__main__"":
    text =""GEEKS FOR GEEKS""
    pattern =""GEEK""
    search(text, pattern)

# This code is contributed by
# sanjeev2552
",O(m+n),O(m+n)
